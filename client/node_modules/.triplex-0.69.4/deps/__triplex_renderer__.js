import {
  Canvas,
  createPortal,
  extend,
  useFrame,
  useThree
} from "./chunk-C6GLWXVO.js";
import {
  BackSide,
  Box3,
  BoxGeometry,
  BufferGeometry,
  Camera,
  CanvasTexture,
  Color,
  CylinderGeometry,
  DepthTexture,
  DoubleSide,
  Euler,
  Float32BufferAttribute,
  FloatType,
  HalfFloatType,
  Layers,
  Line,
  LineBasicMaterial,
  LineSegments,
  LinearFilter,
  MathUtils,
  Matrix4,
  Mesh,
  MeshBasicMaterial,
  Object3D,
  OctahedronGeometry,
  Plane,
  PlaneGeometry,
  Quaternion,
  REVISION,
  Raycaster,
  Scene,
  ShaderMaterial,
  Sphere,
  SphereGeometry,
  Spherical,
  TorusGeometry,
  UniformsUtils,
  Vector2,
  Vector3,
  Vector4,
  WebGLRenderTarget
} from "./chunk-F3XIQ3Q4.js";
import "./chunk-VDQ4ZVCR.js";
import {
  require_react_dom
} from "./chunk-VJPNSDL7.js";
import {
  require_react
} from "./chunk-DNTZS6RX.js";
import {
  __toESM
} from "./chunk-G3PMV62Z.js";

// ../../../../../../../Applications/Triplex.app/Contents/Resources/app/node_modules/@triplex/renderer-r3f/dist/index.mjs
var j = __toESM(require_react(), 1);
var import_react = __toESM(require_react(), 1);
var import_react_dom = __toESM(require_react_dom(), 1);
var qo = Object.defineProperty;
var Qo = (n, t, e) => t in n ? qo(n, t, { enumerable: true, configurable: true, writable: true, value: e }) : n[t] = e;
var pn = (n, t, e) => Qo(n, typeof t != "symbol" ? t + "" : t, e);
var N = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function Hs(n) {
  return n && n.__esModule && Object.prototype.hasOwnProperty.call(n, "default") ? n.default : n;
}
function Ks(n) {
  if (n.__esModule) return n;
  var t = n.default;
  if (typeof t == "function") {
    var e = function r() {
      return this instanceof r ? Reflect.construct(t, arguments, this.constructor) : t.apply(this, arguments);
    };
    e.prototype = t.prototype;
  } else e = {};
  return Object.defineProperty(e, "__esModule", { value: true }), Object.keys(n).forEach(function(r) {
    var i = Object.getOwnPropertyDescriptor(n, r);
    Object.defineProperty(e, r, i.get ? i : {
      enumerable: true,
      get: function() {
        return n[r];
      }
    });
  }), e;
}
var Yn = { exports: {} };
var Ze = {};
var Mi;
function ca() {
  return Mi || (Mi = 1, function() {
    var n = import_react.default, t = Symbol.for("react.element"), e = Symbol.for("react.portal"), r = Symbol.for("react.fragment"), i = Symbol.for("react.strict_mode"), s = Symbol.for("react.profiler"), o = Symbol.for("react.provider"), a = Symbol.for("react.context"), c = Symbol.for("react.forward_ref"), l = Symbol.for("react.suspense"), u = Symbol.for("react.suspense_list"), v = Symbol.for("react.memo"), m = Symbol.for("react.lazy"), p = Symbol.for("react.offscreen"), b = Symbol.iterator, S = "@@iterator";
    function x(w) {
      if (w === null || typeof w != "object")
        return null;
      var k = b && w[b] || w[S];
      return typeof k == "function" ? k : null;
    }
    var d = n.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function g(w) {
      {
        for (var k = arguments.length, z = new Array(k > 1 ? k - 1 : 0), Z = 1; Z < k; Z++)
          z[Z - 1] = arguments[Z];
        E("error", w, z);
      }
    }
    function E(w, k, z) {
      {
        var Z = d.ReactDebugCurrentFrame, at = Z.getStackAddendum();
        at !== "" && (k += "%s", z = z.concat([at]));
        var ct = z.map(function(et) {
          return String(et);
        });
        ct.unshift("Warning: " + k), Function.prototype.apply.call(console[w], console, ct);
      }
    }
    var f = false, y = false, h = false, _ = false, T = false, L;
    L = Symbol.for("react.module.reference");
    function M(w) {
      return !!(typeof w == "string" || typeof w == "function" || w === r || w === s || T || w === i || w === l || w === u || _ || w === p || f || y || h || typeof w == "object" && w !== null && (w.$$typeof === m || w.$$typeof === v || w.$$typeof === o || w.$$typeof === a || w.$$typeof === c || // This needs to include all possible module reference object
      // types supported by any Flight configuration anywhere since
      // we don't know which Flight build this will end up being used
      // with.
      w.$$typeof === L || w.getModuleId !== void 0));
    }
    function I(w, k, z) {
      var Z = w.displayName;
      if (Z)
        return Z;
      var at = k.displayName || k.name || "";
      return at !== "" ? z + "(" + at + ")" : z;
    }
    function D(w) {
      return w.displayName || "Context";
    }
    function O(w) {
      if (w == null)
        return null;
      if (typeof w.tag == "number" && g("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof w == "function")
        return w.displayName || w.name || null;
      if (typeof w == "string")
        return w;
      switch (w) {
        case r:
          return "Fragment";
        case e:
          return "Portal";
        case s:
          return "Profiler";
        case i:
          return "StrictMode";
        case l:
          return "Suspense";
        case u:
          return "SuspenseList";
      }
      if (typeof w == "object")
        switch (w.$$typeof) {
          case a:
            var k = w;
            return D(k) + ".Consumer";
          case o:
            var z = w;
            return D(z._context) + ".Provider";
          case c:
            return I(w, w.render, "ForwardRef");
          case v:
            var Z = w.displayName || null;
            return Z !== null ? Z : O(w.type) || "Memo";
          case m: {
            var at = w, ct = at._payload, et = at._init;
            try {
              return O(et(ct));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    var F = Object.assign, U = 0, X, $, rt, Y, B, V, q;
    function nt() {
    }
    nt.__reactDisabledLog = true;
    function C() {
      {
        if (U === 0) {
          X = console.log, $ = console.info, rt = console.warn, Y = console.error, B = console.group, V = console.groupCollapsed, q = console.groupEnd;
          var w = {
            configurable: true,
            enumerable: true,
            value: nt,
            writable: true
          };
          Object.defineProperties(console, {
            info: w,
            log: w,
            warn: w,
            error: w,
            group: w,
            groupCollapsed: w,
            groupEnd: w
          });
        }
        U++;
      }
    }
    function st() {
      {
        if (U--, U === 0) {
          var w = {
            configurable: true,
            enumerable: true,
            writable: true
          };
          Object.defineProperties(console, {
            log: F({}, w, {
              value: X
            }),
            info: F({}, w, {
              value: $
            }),
            warn: F({}, w, {
              value: rt
            }),
            error: F({}, w, {
              value: Y
            }),
            group: F({}, w, {
              value: B
            }),
            groupCollapsed: F({}, w, {
              value: V
            }),
            groupEnd: F({}, w, {
              value: q
            })
          });
        }
        U < 0 && g("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var St = d.ReactCurrentDispatcher, At;
    function zt(w, k, z) {
      {
        if (At === void 0)
          try {
            throw Error();
          } catch (at) {
            var Z = at.stack.trim().match(/\n( *(at )?)/);
            At = Z && Z[1] || "";
          }
        return `
` + At + w;
      }
    }
    var Xt = false, _r;
    {
      var Oo = typeof WeakMap == "function" ? WeakMap : Map;
      _r = new Oo();
    }
    function _i(w, k) {
      if (!w || Xt)
        return "";
      {
        var z = _r.get(w);
        if (z !== void 0)
          return z;
      }
      var Z;
      Xt = true;
      var at = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var ct;
      ct = St.current, St.current = null, C();
      try {
        if (k) {
          var et = function() {
            throw Error();
          };
          if (Object.defineProperty(et.prototype, "props", {
            set: function() {
              throw Error();
            }
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(et, []);
            } catch (Rt) {
              Z = Rt;
            }
            Reflect.construct(w, [], et);
          } else {
            try {
              et.call();
            } catch (Rt) {
              Z = Rt;
            }
            w.call(et.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (Rt) {
            Z = Rt;
          }
          w();
        }
      } catch (Rt) {
        if (Rt && Z && typeof Rt.stack == "string") {
          for (var tt = Rt.stack.split(`
`), It = Z.stack.split(`
`), ft = tt.length - 1, gt = It.length - 1; ft >= 1 && gt >= 0 && tt[ft] !== It[gt]; )
            gt--;
          for (; ft >= 1 && gt >= 0; ft--, gt--)
            if (tt[ft] !== It[gt]) {
              if (ft !== 1 || gt !== 1)
                do
                  if (ft--, gt--, gt < 0 || tt[ft] !== It[gt]) {
                    var Nt = `
` + tt[ft].replace(" at new ", " at ");
                    return w.displayName && Nt.includes("<anonymous>") && (Nt = Nt.replace("<anonymous>", w.displayName)), typeof w == "function" && _r.set(w, Nt), Nt;
                  }
                while (ft >= 1 && gt >= 0);
              break;
            }
        }
      } finally {
        Xt = false, St.current = ct, st(), Error.prepareStackTrace = at;
      }
      var Ce = w ? w.displayName || w.name : "", ue = Ce ? zt(Ce) : "";
      return typeof w == "function" && _r.set(w, ue), ue;
    }
    function To(w, k, z) {
      return _i(w, false);
    }
    function Co(w) {
      var k = w.prototype;
      return !!(k && k.isReactComponent);
    }
    function yr(w, k, z) {
      if (w == null)
        return "";
      if (typeof w == "function")
        return _i(w, Co(w));
      if (typeof w == "string")
        return zt(w);
      switch (w) {
        case l:
          return zt("Suspense");
        case u:
          return zt("SuspenseList");
      }
      if (typeof w == "object")
        switch (w.$$typeof) {
          case c:
            return To(w.render);
          case v:
            return yr(w.type, k, z);
          case m: {
            var Z = w, at = Z._payload, ct = Z._init;
            try {
              return yr(ct(at), k, z);
            } catch {
            }
          }
        }
      return "";
    }
    var He = Object.prototype.hasOwnProperty, yi = {}, Ei = d.ReactDebugCurrentFrame;
    function Er(w) {
      if (w) {
        var k = w._owner, z = yr(w.type, w._source, k ? k.type : null);
        Ei.setExtraStackFrame(z);
      } else
        Ei.setExtraStackFrame(null);
    }
    function Io(w, k, z, Z, at) {
      {
        var ct = Function.call.bind(He);
        for (var et in w)
          if (ct(w, et)) {
            var tt = void 0;
            try {
              if (typeof w[et] != "function") {
                var It = Error((Z || "React class") + ": " + z + " type `" + et + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof w[et] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw It.name = "Invariant Violation", It;
              }
              tt = w[et](k, et, Z, z, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (ft) {
              tt = ft;
            }
            tt && !(tt instanceof Error) && (Er(at), g("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", Z || "React class", z, et, typeof tt), Er(null)), tt instanceof Error && !(tt.message in yi) && (yi[tt.message] = true, Er(at), g("Failed %s type: %s", z, tt.message), Er(null));
          }
      }
    }
    var Lo = Array.isArray;
    function ln(w) {
      return Lo(w);
    }
    function Do(w) {
      {
        var k = typeof Symbol == "function" && Symbol.toStringTag, z = k && w[Symbol.toStringTag] || w.constructor.name || "Object";
        return z;
      }
    }
    function Ao(w) {
      try {
        return Si(w), false;
      } catch {
        return true;
      }
    }
    function Si(w) {
      return "" + w;
    }
    function bi(w) {
      if (Ao(w))
        return g("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", Do(w)), Si(w);
    }
    var Ke = d.ReactCurrentOwner, Ro = {
      key: true,
      ref: true,
      __self: true,
      __source: true
    }, wi, xi, cn;
    cn = {};
    function Po(w) {
      if (He.call(w, "ref")) {
        var k = Object.getOwnPropertyDescriptor(w, "ref").get;
        if (k && k.isReactWarning)
          return false;
      }
      return w.ref !== void 0;
    }
    function Mo(w) {
      if (He.call(w, "key")) {
        var k = Object.getOwnPropertyDescriptor(w, "key").get;
        if (k && k.isReactWarning)
          return false;
      }
      return w.key !== void 0;
    }
    function ko(w, k) {
      if (typeof w.ref == "string" && Ke.current && k && Ke.current.stateNode !== k) {
        var z = O(Ke.current.type);
        cn[z] || (g('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', O(Ke.current.type), w.ref), cn[z] = true);
      }
    }
    function Uo(w, k) {
      {
        var z = function() {
          wi || (wi = true, g("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", k));
        };
        z.isReactWarning = true, Object.defineProperty(w, "key", {
          get: z,
          configurable: true
        });
      }
    }
    function Fo(w, k) {
      {
        var z = function() {
          xi || (xi = true, g("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", k));
        };
        z.isReactWarning = true, Object.defineProperty(w, "ref", {
          get: z,
          configurable: true
        });
      }
    }
    var jo = function(w, k, z, Z, at, ct, et) {
      var tt = {
        // This tag allows us to uniquely identify this as a React Element
        $$typeof: t,
        // Built-in properties that belong on the element
        type: w,
        key: k,
        ref: z,
        props: et,
        // Record the component responsible for creating this element.
        _owner: ct
      };
      return tt._store = {}, Object.defineProperty(tt._store, "validated", {
        configurable: false,
        enumerable: false,
        writable: true,
        value: false
      }), Object.defineProperty(tt, "_self", {
        configurable: false,
        enumerable: false,
        writable: false,
        value: Z
      }), Object.defineProperty(tt, "_source", {
        configurable: false,
        enumerable: false,
        writable: false,
        value: at
      }), Object.freeze && (Object.freeze(tt.props), Object.freeze(tt)), tt;
    };
    function Vo(w, k, z, Z, at) {
      {
        var ct, et = {}, tt = null, It = null;
        z !== void 0 && (bi(z), tt = "" + z), Mo(k) && (bi(k.key), tt = "" + k.key), Po(k) && (It = k.ref, ko(k, at));
        for (ct in k)
          He.call(k, ct) && !Ro.hasOwnProperty(ct) && (et[ct] = k[ct]);
        if (w && w.defaultProps) {
          var ft = w.defaultProps;
          for (ct in ft)
            et[ct] === void 0 && (et[ct] = ft[ct]);
        }
        if (tt || It) {
          var gt = typeof w == "function" ? w.displayName || w.name || "Unknown" : w;
          tt && Uo(et, gt), It && Fo(et, gt);
        }
        return jo(w, tt, It, at, Z, Ke.current, et);
      }
    }
    var un = d.ReactCurrentOwner, Oi = d.ReactDebugCurrentFrame;
    function Te(w) {
      if (w) {
        var k = w._owner, z = yr(w.type, w._source, k ? k.type : null);
        Oi.setExtraStackFrame(z);
      } else
        Oi.setExtraStackFrame(null);
    }
    var hn;
    hn = false;
    function dn(w) {
      return typeof w == "object" && w !== null && w.$$typeof === t;
    }
    function Ti() {
      {
        if (un.current) {
          var w = O(un.current.type);
          if (w)
            return `

Check the render method of \`` + w + "`.";
        }
        return "";
      }
    }
    function zo(w) {
      return "";
    }
    var Ci = {};
    function No(w) {
      {
        var k = Ti();
        if (!k) {
          var z = typeof w == "string" ? w : w.displayName || w.name;
          z && (k = `

Check the top-level render call using <` + z + ">.");
        }
        return k;
      }
    }
    function Ii(w, k) {
      {
        if (!w._store || w._store.validated || w.key != null)
          return;
        w._store.validated = true;
        var z = No(k);
        if (Ci[z])
          return;
        Ci[z] = true;
        var Z = "";
        w && w._owner && w._owner !== un.current && (Z = " It was passed a child from " + O(w._owner.type) + "."), Te(w), g('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', z, Z), Te(null);
      }
    }
    function Li(w, k) {
      {
        if (typeof w != "object")
          return;
        if (ln(w))
          for (var z = 0; z < w.length; z++) {
            var Z = w[z];
            dn(Z) && Ii(Z, k);
          }
        else if (dn(w))
          w._store && (w._store.validated = true);
        else if (w) {
          var at = x(w);
          if (typeof at == "function" && at !== w.entries)
            for (var ct = at.call(w), et; !(et = ct.next()).done; )
              dn(et.value) && Ii(et.value, k);
        }
      }
    }
    function Yo(w) {
      {
        var k = w.type;
        if (k == null || typeof k == "string")
          return;
        var z;
        if (typeof k == "function")
          z = k.propTypes;
        else if (typeof k == "object" && (k.$$typeof === c || // Note: Memo only checks outer props here.
        // Inner props are checked in the reconciler.
        k.$$typeof === v))
          z = k.propTypes;
        else
          return;
        if (z) {
          var Z = O(k);
          Io(z, w.props, "prop", Z, w);
        } else if (k.PropTypes !== void 0 && !hn) {
          hn = true;
          var at = O(k);
          g("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", at || "Unknown");
        }
        typeof k.getDefaultProps == "function" && !k.getDefaultProps.isReactClassApproved && g("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
      }
    }
    function Bo(w) {
      {
        for (var k = Object.keys(w.props), z = 0; z < k.length; z++) {
          var Z = k[z];
          if (Z !== "children" && Z !== "key") {
            Te(w), g("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", Z), Te(null);
            break;
          }
        }
        w.ref !== null && (Te(w), g("Invalid attribute `ref` supplied to `React.Fragment`."), Te(null));
      }
    }
    var Di = {};
    function Ai(w, k, z, Z, at, ct) {
      {
        var et = M(w);
        if (!et) {
          var tt = "";
          (w === void 0 || typeof w == "object" && w !== null && Object.keys(w).length === 0) && (tt += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
          var It = zo();
          It ? tt += It : tt += Ti();
          var ft;
          w === null ? ft = "null" : ln(w) ? ft = "array" : w !== void 0 && w.$$typeof === t ? (ft = "<" + (O(w.type) || "Unknown") + " />", tt = " Did you accidentally export a JSX literal instead of a component?") : ft = typeof w, g("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", ft, tt);
        }
        var gt = Vo(w, k, z, at, ct);
        if (gt == null)
          return gt;
        if (et) {
          var Nt = k.children;
          if (Nt !== void 0)
            if (Z)
              if (ln(Nt)) {
                for (var Ce = 0; Ce < Nt.length; Ce++)
                  Li(Nt[Ce], w);
                Object.freeze && Object.freeze(Nt);
              } else
                g("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
            else
              Li(Nt, w);
        }
        if (He.call(k, "key")) {
          var ue = O(w), Rt = Object.keys(k).filter(function(Wo) {
            return Wo !== "key";
          }), fn = Rt.length > 0 ? "{key: someKey, " + Rt.join(": ..., ") + ": ...}" : "{key: someKey}";
          if (!Di[ue + fn]) {
            var Zo = Rt.length > 0 ? "{" + Rt.join(": ..., ") + ": ...}" : "{}";
            g(`A props object containing a "key" prop is being spread into JSX:
  let props = %s;
  <%s {...props} />
React keys must be passed directly to JSX without using spread:
  let props = %s;
  <%s key={someKey} {...props} />`, fn, ue, Zo, ue), Di[ue + fn] = true;
          }
        }
        return w === r ? Bo(gt) : Yo(gt), gt;
      }
    }
    function Go(w, k, z) {
      return Ai(w, k, z, true);
    }
    function Ho(w, k, z) {
      return Ai(w, k, z, false);
    }
    var Ko = Ho, Xo = Go;
    Ze.Fragment = r, Ze.jsx = Ko, Ze.jsxs = Xo;
  }()), Ze;
}
false ? Yn.exports = la() : Yn.exports = ca();
var P = Yn.exports;
function dr(n) {
  return () => {
    n.forEach((t) => t());
  };
}
function mt(n, t) {
  const e = async (r) => {
    if (typeof r.data == "object" && r.data.eventName === n) {
      const i = await t(r.data.data);
      i !== void 0 ? ki(n, i) : false;
    }
  };
  return window.addEventListener("message", e, false), () => {
    window.removeEventListener("message", e, false);
  };
}
function pt(n, t, e = false) {
  return n.startsWith("self:") ? window.postMessage({ data: t, eventName: n }, "*") : window.parent.postMessage({ data: t, eventName: n }, "*"), e ? new Promise((r) => {
    const i = `${n}Response`, s = mt(i, (o) => {
      r(o), s();
    });
  }) : Promise.resolve(void 0);
}
function ki(n, t) {
  window.parent.postMessage({ data: t, eventName: `${n}Response` }, "*");
}
function ua({
  RendererElement: n
}) {
  window.SceneObject = n;
}
var Xs = {};
var Ut = {};
var Qr = N && N.__extends || /* @__PURE__ */ function() {
  var n = function(t, e) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(r, i) {
      r.__proto__ = i;
    } || function(r, i) {
      for (var s in i) Object.prototype.hasOwnProperty.call(i, s) && (r[s] = i[s]);
    }, n(t, e);
  };
  return function(t, e) {
    if (typeof e != "function" && e !== null)
      throw new TypeError("Class extends value " + String(e) + " is not a constructor or null");
    n(t, e);
    function r() {
      this.constructor = t;
    }
    t.prototype = e === null ? Object.create(e) : (r.prototype = e.prototype, new r());
  };
}();
Object.defineProperty(Ut, "__esModule", { value: true });
Ut.StatsigInitializationTimeoutError = Ut.StatsigSDKKeyMismatchError = Ut.StatsigInvalidArgumentError = Ut.StatsigUninitializedError = void 0;
var ha = (
  /** @class */
  function(n) {
    Qr(t, n);
    function t(e) {
      var r = n.call(this, e ?? "Call and wait for initialize() to finish first.") || this;
      return Object.setPrototypeOf(r, t.prototype), r;
    }
    return t;
  }(Error)
);
Ut.StatsigUninitializedError = ha;
var da = (
  /** @class */
  function(n) {
    Qr(t, n);
    function t(e) {
      var r = n.call(this, e) || this;
      return Object.setPrototypeOf(r, t.prototype), r;
    }
    return t;
  }(Error)
);
Ut.StatsigInvalidArgumentError = da;
var fa = (
  /** @class */
  function(n) {
    Qr(t, n);
    function t(e) {
      var r = n.call(this, e) || this;
      return Object.setPrototypeOf(r, t.prototype), r;
    }
    return t;
  }(Error)
);
Ut.StatsigSDKKeyMismatchError = fa;
var pa = (
  /** @class */
  function(n) {
    Qr(t, n);
    function t(e) {
      var r = n.call(this, "The initialization timeout of ".concat(e, "ms has been hit before the network request has completed.")) || this;
      return Object.setPrototypeOf(r, t.prototype), r;
    }
    return t;
  }(Error)
);
Ut.StatsigInitializationTimeoutError = pa;
var Yr = {};
var fr = {};
Object.defineProperty(fr, "__esModule", { value: true });
var ga = (
  /** @class */
  function() {
    function n(t, e, r, i, s, o, a, c, l, u) {
      s === void 0 && (s = []), o === void 0 && (o = ""), a === void 0 && (a = null), c === void 0 && (c = null), l === void 0 && (l = null), u === void 0 && (u = null), this.onDefaultValueFallback = null, this.name = t, this.value = JSON.parse(JSON.stringify(e ?? {})), this.ruleID = r ?? "", this.secondaryExposures = s, this.allocatedExperimentName = o, this.evaluationDetails = i, this.onDefaultValueFallback = a, this.groupName = c, this.idType = l, this.isExperimentActive = u;
    }
    return n.prototype.get = function(t, e, r) {
      var i, s, o = this.getValue(t, e);
      if (o == null)
        return e;
      var a = Array.isArray(e) ? "array" : typeof e, c = Array.isArray(o) ? "array" : typeof o;
      return r ? r(o) ? o : ((i = this.onDefaultValueFallback) === null || i === void 0 || i.call(this, this, t, a, c), e) : e == null || a === c ? o : ((s = this.onDefaultValueFallback) === null || s === void 0 || s.call(this, this, t, a, c), e);
    }, n.prototype.getValue = function(t, e) {
      return t == null ? this.value : (e == null && (e = null), this.value[t] == null ? e : this.value[t]);
    }, n.prototype.getRuleID = function() {
      return this.ruleID;
    }, n.prototype.getGroupName = function() {
      return this.groupName;
    }, n.prototype.getIDType = function() {
      return this.idType;
    }, n.prototype.getName = function() {
      return this.name;
    }, n.prototype.getEvaluationDetails = function() {
      return this.evaluationDetails;
    }, n.prototype._getSecondaryExposures = function() {
      return this.secondaryExposures;
    }, n.prototype._getAllocatedExperimentName = function() {
      return this.allocatedExperimentName;
    }, n.prototype.getIsExperimentActive = function() {
      return this.isExperimentActive;
    }, n;
  }()
);
fr.default = ga;
var Zs = {};
var br;
var va = new Uint8Array(16);
function Ws() {
  if (!br && (br = typeof crypto < "u" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto), !br))
    throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
  return br(va);
}
var ma = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;
function $r(n) {
  return typeof n == "string" && ma.test(n);
}
var bt = [];
for (let n = 0; n < 256; ++n)
  bt.push((n + 256).toString(16).slice(1));
function Jr(n, t = 0) {
  return bt[n[t + 0]] + bt[n[t + 1]] + bt[n[t + 2]] + bt[n[t + 3]] + "-" + bt[n[t + 4]] + bt[n[t + 5]] + "-" + bt[n[t + 6]] + bt[n[t + 7]] + "-" + bt[n[t + 8]] + bt[n[t + 9]] + "-" + bt[n[t + 10]] + bt[n[t + 11]] + bt[n[t + 12]] + bt[n[t + 13]] + bt[n[t + 14]] + bt[n[t + 15]];
}
function _a(n, t = 0) {
  const e = Jr(n, t);
  if (!$r(e))
    throw TypeError("Stringified UUID is invalid");
  return e;
}
var Ui;
var gn;
var vn = 0;
var mn = 0;
function ya(n, t, e) {
  let r = t && e || 0;
  const i = t || new Array(16);
  n = n || {};
  let s = n.node || Ui, o = n.clockseq !== void 0 ? n.clockseq : gn;
  if (s == null || o == null) {
    const m = n.random || (n.rng || Ws)();
    s == null && (s = Ui = [m[0] | 1, m[1], m[2], m[3], m[4], m[5]]), o == null && (o = gn = (m[6] << 8 | m[7]) & 16383);
  }
  let a = n.msecs !== void 0 ? n.msecs : Date.now(), c = n.nsecs !== void 0 ? n.nsecs : mn + 1;
  const l = a - vn + (c - mn) / 1e4;
  if (l < 0 && n.clockseq === void 0 && (o = o + 1 & 16383), (l < 0 || a > vn) && n.nsecs === void 0 && (c = 0), c >= 1e4)
    throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
  vn = a, mn = c, gn = o, a += 122192928e5;
  const u = ((a & 268435455) * 1e4 + c) % 4294967296;
  i[r++] = u >>> 24 & 255, i[r++] = u >>> 16 & 255, i[r++] = u >>> 8 & 255, i[r++] = u & 255;
  const v = a / 4294967296 * 1e4 & 268435455;
  i[r++] = v >>> 8 & 255, i[r++] = v & 255, i[r++] = v >>> 24 & 15 | 16, i[r++] = v >>> 16 & 255, i[r++] = o >>> 8 | 128, i[r++] = o & 255;
  for (let m = 0; m < 6; ++m)
    i[r + m] = s[m];
  return t || Jr(i);
}
function qs(n) {
  if (!$r(n))
    throw TypeError("Invalid UUID");
  let t;
  const e = new Uint8Array(16);
  return e[0] = (t = parseInt(n.slice(0, 8), 16)) >>> 24, e[1] = t >>> 16 & 255, e[2] = t >>> 8 & 255, e[3] = t & 255, e[4] = (t = parseInt(n.slice(9, 13), 16)) >>> 8, e[5] = t & 255, e[6] = (t = parseInt(n.slice(14, 18), 16)) >>> 8, e[7] = t & 255, e[8] = (t = parseInt(n.slice(19, 23), 16)) >>> 8, e[9] = t & 255, e[10] = (t = parseInt(n.slice(24, 36), 16)) / 1099511627776 & 255, e[11] = t / 4294967296 & 255, e[12] = t >>> 24 & 255, e[13] = t >>> 16 & 255, e[14] = t >>> 8 & 255, e[15] = t & 255, e;
}
function Ea(n) {
  n = unescape(encodeURIComponent(n));
  const t = [];
  for (let e = 0; e < n.length; ++e)
    t.push(n.charCodeAt(e));
  return t;
}
var Sa = "6ba7b810-9dad-11d1-80b4-00c04fd430c8";
var ba = "6ba7b811-9dad-11d1-80b4-00c04fd430c8";
function Qs(n, t, e) {
  function r(i, s, o, a) {
    var c;
    if (typeof i == "string" && (i = Ea(i)), typeof s == "string" && (s = qs(s)), ((c = s) === null || c === void 0 ? void 0 : c.length) !== 16)
      throw TypeError("Namespace must be array-like (16 iterable integer values, 0-255)");
    let l = new Uint8Array(16 + i.length);
    if (l.set(s), l.set(i, s.length), l = e(l), l[6] = l[6] & 15 | t, l[8] = l[8] & 63 | 128, o) {
      a = a || 0;
      for (let u = 0; u < 16; ++u)
        o[a + u] = l[u];
      return o;
    }
    return Jr(l);
  }
  try {
    r.name = n;
  } catch {
  }
  return r.DNS = Sa, r.URL = ba, r;
}
function wa(n) {
  if (typeof n == "string") {
    const t = unescape(encodeURIComponent(n));
    n = new Uint8Array(t.length);
    for (let e = 0; e < t.length; ++e)
      n[e] = t.charCodeAt(e);
  }
  return xa(Oa(Ta(n), n.length * 8));
}
function xa(n) {
  const t = [], e = n.length * 32, r = "0123456789abcdef";
  for (let i = 0; i < e; i += 8) {
    const s = n[i >> 5] >>> i % 32 & 255, o = parseInt(r.charAt(s >>> 4 & 15) + r.charAt(s & 15), 16);
    t.push(o);
  }
  return t;
}
function $s(n) {
  return (n + 64 >>> 9 << 4) + 14 + 1;
}
function Oa(n, t) {
  n[t >> 5] |= 128 << t % 32, n[$s(t) - 1] = t;
  let e = 1732584193, r = -271733879, i = -1732584194, s = 271733878;
  for (let o = 0; o < n.length; o += 16) {
    const a = e, c = r, l = i, u = s;
    e = wt(e, r, i, s, n[o], 7, -680876936), s = wt(s, e, r, i, n[o + 1], 12, -389564586), i = wt(i, s, e, r, n[o + 2], 17, 606105819), r = wt(r, i, s, e, n[o + 3], 22, -1044525330), e = wt(e, r, i, s, n[o + 4], 7, -176418897), s = wt(s, e, r, i, n[o + 5], 12, 1200080426), i = wt(i, s, e, r, n[o + 6], 17, -1473231341), r = wt(r, i, s, e, n[o + 7], 22, -45705983), e = wt(e, r, i, s, n[o + 8], 7, 1770035416), s = wt(s, e, r, i, n[o + 9], 12, -1958414417), i = wt(i, s, e, r, n[o + 10], 17, -42063), r = wt(r, i, s, e, n[o + 11], 22, -1990404162), e = wt(e, r, i, s, n[o + 12], 7, 1804603682), s = wt(s, e, r, i, n[o + 13], 12, -40341101), i = wt(i, s, e, r, n[o + 14], 17, -1502002290), r = wt(r, i, s, e, n[o + 15], 22, 1236535329), e = xt(e, r, i, s, n[o + 1], 5, -165796510), s = xt(s, e, r, i, n[o + 6], 9, -1069501632), i = xt(i, s, e, r, n[o + 11], 14, 643717713), r = xt(r, i, s, e, n[o], 20, -373897302), e = xt(e, r, i, s, n[o + 5], 5, -701558691), s = xt(s, e, r, i, n[o + 10], 9, 38016083), i = xt(i, s, e, r, n[o + 15], 14, -660478335), r = xt(r, i, s, e, n[o + 4], 20, -405537848), e = xt(e, r, i, s, n[o + 9], 5, 568446438), s = xt(s, e, r, i, n[o + 14], 9, -1019803690), i = xt(i, s, e, r, n[o + 3], 14, -187363961), r = xt(r, i, s, e, n[o + 8], 20, 1163531501), e = xt(e, r, i, s, n[o + 13], 5, -1444681467), s = xt(s, e, r, i, n[o + 2], 9, -51403784), i = xt(i, s, e, r, n[o + 7], 14, 1735328473), r = xt(r, i, s, e, n[o + 12], 20, -1926607734), e = Ot(e, r, i, s, n[o + 5], 4, -378558), s = Ot(s, e, r, i, n[o + 8], 11, -2022574463), i = Ot(i, s, e, r, n[o + 11], 16, 1839030562), r = Ot(r, i, s, e, n[o + 14], 23, -35309556), e = Ot(e, r, i, s, n[o + 1], 4, -1530992060), s = Ot(s, e, r, i, n[o + 4], 11, 1272893353), i = Ot(i, s, e, r, n[o + 7], 16, -155497632), r = Ot(r, i, s, e, n[o + 10], 23, -1094730640), e = Ot(e, r, i, s, n[o + 13], 4, 681279174), s = Ot(s, e, r, i, n[o], 11, -358537222), i = Ot(i, s, e, r, n[o + 3], 16, -722521979), r = Ot(r, i, s, e, n[o + 6], 23, 76029189), e = Ot(e, r, i, s, n[o + 9], 4, -640364487), s = Ot(s, e, r, i, n[o + 12], 11, -421815835), i = Ot(i, s, e, r, n[o + 15], 16, 530742520), r = Ot(r, i, s, e, n[o + 2], 23, -995338651), e = Tt(e, r, i, s, n[o], 6, -198630844), s = Tt(s, e, r, i, n[o + 7], 10, 1126891415), i = Tt(i, s, e, r, n[o + 14], 15, -1416354905), r = Tt(r, i, s, e, n[o + 5], 21, -57434055), e = Tt(e, r, i, s, n[o + 12], 6, 1700485571), s = Tt(s, e, r, i, n[o + 3], 10, -1894986606), i = Tt(i, s, e, r, n[o + 10], 15, -1051523), r = Tt(r, i, s, e, n[o + 1], 21, -2054922799), e = Tt(e, r, i, s, n[o + 8], 6, 1873313359), s = Tt(s, e, r, i, n[o + 15], 10, -30611744), i = Tt(i, s, e, r, n[o + 6], 15, -1560198380), r = Tt(r, i, s, e, n[o + 13], 21, 1309151649), e = Tt(e, r, i, s, n[o + 4], 6, -145523070), s = Tt(s, e, r, i, n[o + 11], 10, -1120210379), i = Tt(i, s, e, r, n[o + 2], 15, 718787259), r = Tt(r, i, s, e, n[o + 9], 21, -343485551), e = ae(e, a), r = ae(r, c), i = ae(i, l), s = ae(s, u);
  }
  return [e, r, i, s];
}
function Ta(n) {
  if (n.length === 0)
    return [];
  const t = n.length * 8, e = new Uint32Array($s(t));
  for (let r = 0; r < t; r += 8)
    e[r >> 5] |= (n[r / 8] & 255) << r % 32;
  return e;
}
function ae(n, t) {
  const e = (n & 65535) + (t & 65535);
  return (n >> 16) + (t >> 16) + (e >> 16) << 16 | e & 65535;
}
function Ca(n, t) {
  return n << t | n >>> 32 - t;
}
function tn(n, t, e, r, i, s) {
  return ae(Ca(ae(ae(t, n), ae(r, s)), i), e);
}
function wt(n, t, e, r, i, s, o) {
  return tn(t & e | ~t & r, n, t, i, s, o);
}
function xt(n, t, e, r, i, s, o) {
  return tn(t & r | e & ~r, n, t, i, s, o);
}
function Ot(n, t, e, r, i, s, o) {
  return tn(t ^ e ^ r, n, t, i, s, o);
}
function Tt(n, t, e, r, i, s, o) {
  return tn(e ^ (t | ~r), n, t, i, s, o);
}
var Ia = Qs("v3", 48, wa);
var La = Ia;
var Da = typeof crypto < "u" && crypto.randomUUID && crypto.randomUUID.bind(crypto);
var Fi = {
  randomUUID: Da
};
function Aa(n, t, e) {
  if (Fi.randomUUID && !t && !n)
    return Fi.randomUUID();
  n = n || {};
  const r = n.random || (n.rng || Ws)();
  if (r[6] = r[6] & 15 | 64, r[8] = r[8] & 63 | 128, t) {
    e = e || 0;
    for (let i = 0; i < 16; ++i)
      t[e + i] = r[i];
    return t;
  }
  return Jr(r);
}
function Ra(n, t, e, r) {
  switch (n) {
    case 0:
      return t & e ^ ~t & r;
    case 1:
      return t ^ e ^ r;
    case 2:
      return t & e ^ t & r ^ e & r;
    case 3:
      return t ^ e ^ r;
  }
}
function _n(n, t) {
  return n << t | n >>> 32 - t;
}
function Pa(n) {
  const t = [1518500249, 1859775393, 2400959708, 3395469782], e = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
  if (typeof n == "string") {
    const o = unescape(encodeURIComponent(n));
    n = [];
    for (let a = 0; a < o.length; ++a)
      n.push(o.charCodeAt(a));
  } else Array.isArray(n) || (n = Array.prototype.slice.call(n));
  n.push(128);
  const r = n.length / 4 + 2, i = Math.ceil(r / 16), s = new Array(i);
  for (let o = 0; o < i; ++o) {
    const a = new Uint32Array(16);
    for (let c = 0; c < 16; ++c)
      a[c] = n[o * 64 + c * 4] << 24 | n[o * 64 + c * 4 + 1] << 16 | n[o * 64 + c * 4 + 2] << 8 | n[o * 64 + c * 4 + 3];
    s[o] = a;
  }
  s[i - 1][14] = (n.length - 1) * 8 / Math.pow(2, 32), s[i - 1][14] = Math.floor(s[i - 1][14]), s[i - 1][15] = (n.length - 1) * 8 & 4294967295;
  for (let o = 0; o < i; ++o) {
    const a = new Uint32Array(80);
    for (let p = 0; p < 16; ++p)
      a[p] = s[o][p];
    for (let p = 16; p < 80; ++p)
      a[p] = _n(a[p - 3] ^ a[p - 8] ^ a[p - 14] ^ a[p - 16], 1);
    let c = e[0], l = e[1], u = e[2], v = e[3], m = e[4];
    for (let p = 0; p < 80; ++p) {
      const b = Math.floor(p / 20), S = _n(c, 5) + Ra(b, l, u, v) + m + t[b] + a[p] >>> 0;
      m = v, v = u, u = _n(l, 30) >>> 0, l = c, c = S;
    }
    e[0] = e[0] + c >>> 0, e[1] = e[1] + l >>> 0, e[2] = e[2] + u >>> 0, e[3] = e[3] + v >>> 0, e[4] = e[4] + m >>> 0;
  }
  return [e[0] >> 24 & 255, e[0] >> 16 & 255, e[0] >> 8 & 255, e[0] & 255, e[1] >> 24 & 255, e[1] >> 16 & 255, e[1] >> 8 & 255, e[1] & 255, e[2] >> 24 & 255, e[2] >> 16 & 255, e[2] >> 8 & 255, e[2] & 255, e[3] >> 24 & 255, e[3] >> 16 & 255, e[3] >> 8 & 255, e[3] & 255, e[4] >> 24 & 255, e[4] >> 16 & 255, e[4] >> 8 & 255, e[4] & 255];
}
var Ma = Qs("v5", 80, Pa);
var ka = Ma;
var Ua = "00000000-0000-0000-0000-000000000000";
function Fa(n) {
  if (!$r(n))
    throw TypeError("Invalid UUID");
  return parseInt(n.slice(14, 15), 16);
}
var ja = Object.freeze(Object.defineProperty({
  __proto__: null,
  NIL: Ua,
  parse: qs,
  stringify: _a,
  v1: ya,
  v3: La,
  v4: Aa,
  v5: ka,
  validate: $r,
  version: Fa
}, Symbol.toStringTag, { value: "Module" }));
var ei = Ks(ja);
var ce = {};
var be = {};
Object.defineProperty(be, "__esModule", { value: true });
be.difference = be.now = void 0;
function Js(n) {
  return n === void 0 && (n = { withPrecision: false }), typeof performance > "u" || !performance ? Date.now() : n.withPrecision ? performance.now() : performance.now() | 0;
}
be.now = Js;
function Va(n) {
  return Js() - n;
}
be.difference = Va;
var Br = N && N.__assign || function() {
  return Br = Object.assign || function(n) {
    for (var t, e = 1, r = arguments.length; e < r; e++) {
      t = arguments[e];
      for (var i in t) Object.prototype.hasOwnProperty.call(t, i) && (n[i] = t[i]);
    }
    return n;
  }, Br.apply(this, arguments);
};
Object.defineProperty(ce, "__esModule", { value: true });
ce.DiagnosticsImpl = void 0;
var ji = be;
var to = (
  /** @class */
  function() {
    function n(t) {
      var e = this, r, i, s;
      this.mark = {
        overall: this.selectAction("overall"),
        initialize: this.selectStep("initialize"),
        bootstrap: this.selectStep("bootstrap"),
        api_call: function(o) {
          switch (o) {
            case "getConfig":
              return e.selectAction("get_config");
            case "getExperiment":
              return e.selectAction("get_experiment");
            case "checkGate":
              return e.selectAction("check_gate");
            case "getLayer":
              return e.selectAction("get_layer");
          }
          return null;
        }
      }, this.context = "initialize", this.defaultMaxMarkers = 30, this.maxMarkers = {
        initialize: this.defaultMaxMarkers,
        config_sync: this.defaultMaxMarkers,
        event_logging: this.defaultMaxMarkers,
        api_call: this.defaultMaxMarkers
      }, this.markers = (r = t.markers) !== null && r !== void 0 ? r : {
        initialize: [],
        config_sync: [],
        event_logging: [],
        api_call: []
      }, this.disabled = (s = (i = t.options) === null || i === void 0 ? void 0 : i.getDisableDiagnosticsLogging()) !== null && s !== void 0 ? s : false;
    }
    return n.prototype.setContext = function(t) {
      this.context = t;
    }, n.prototype.selectAction = function(t, e) {
      var r = this;
      return {
        start: function(i, s) {
          return r.addMarker(Br({ key: t, step: e, action: "start", timestamp: (0, ji.now)({ withPrecision: true }) }, i ?? {}), s);
        },
        end: function(i, s) {
          return r.addMarker(Br({ key: t, step: e, action: "end", timestamp: (0, ji.now)({ withPrecision: true }) }, i ?? {}), s);
        }
      };
    }, n.prototype.selectStep = function(t) {
      return {
        process: this.selectAction(t, "process"),
        networkRequest: this.selectAction(t, "network_request")
      };
    }, n.prototype.addMarker = function(t, e) {
      var r, i = e ?? this.context;
      return this.disabled && i === "api_call" || this.maxMarkers[i] !== void 0 && this.markers[i].length >= ((r = this.maxMarkers[i]) !== null && r !== void 0 ? r : this.defaultMaxMarkers) ? false : (this.markers[i].push(t), true);
    }, n.prototype.getMarkers = function(t) {
      return this.markers[t];
    }, n.prototype.setMaxMarkers = function(t, e) {
      this.maxMarkers[t] = e;
    }, n.prototype.getMarkerCount = function(t) {
      return this.markers[t].length;
    }, n.prototype.clearContext = function(t) {
      this.markers[t] = [];
    }, n;
  }()
);
ce.DiagnosticsImpl = to;
var za = (
  /** @class */
  function() {
    function n() {
    }
    return n.initialize = function(t) {
      this.instance = new to(t), this.mark = this.instance.mark, this.disabled = this.instance.disabled, this.getMarkers = this.instance.getMarkers.bind(this.instance), this.getMarkerCount = this.instance.getMarkerCount.bind(this.instance), this.setMaxMarkers = this.instance.setMaxMarkers.bind(this.instance), this.setContext = this.instance.setContext.bind(this.instance), this.clearContext = this.instance.clearContext.bind(this.instance);
    }, n.formatError = function(t) {
      if (t && typeof t == "object")
        return {
          code: this.safeGetField(t, "code"),
          name: this.safeGetField(t, "name"),
          message: this.safeGetField(t, "message")
        };
    }, n.safeGetField = function(t, e) {
      if (e in t)
        return t[e];
    }, n;
  }()
);
ce.default = za;
var xe = {};
var ri = {};
(function(n) {
  Object.defineProperty(n, "__esModule", { value: true }), n.LogLevel = n.INIT_TIMEOUT_DEFAULT_MS = void 0;
  var t = "https://featureassets.org/v1/", e = "https://prodregistryv2.org/v1/", r = 3;
  n.INIT_TIMEOUT_DEFAULT_MS = 3e3;
  var i;
  (function(o) {
    o.NONE = "NONE", o.INFO = "INFO", o.DEBUG = "DEBUG", o.WARN = "WARN", o.ERROR = "ERROR";
  })(i = n.LogLevel || (n.LogLevel = {}));
  var s = (
    /** @class */
    function() {
      function o(a) {
        var c, l, u, v, m, p, b, S, x, d, g, E, f, y, h, _, T, L, M, I, D, O, F, U, X, $, rt;
        a == null && (a = {});
        var Y = (c = a.api) !== null && c !== void 0 ? c : t;
        this.api = Y.endsWith("/") ? Y : Y + "/", this.disableCurrentPageLogging = (l = a.disableCurrentPageLogging) !== null && l !== void 0 ? l : false, this.environment = (u = a.environment) !== null && u !== void 0 ? u : null, this.loggingIntervalMillis = this.normalizeNumberInput(a.loggingIntervalMillis, {
          default: 1e4,
          min: 1e3,
          max: 6e4
        }), this.loggingBufferMaxSize = this.normalizeNumberInput(a.loggingBufferMaxSize, {
          default: 100,
          min: 2,
          max: 500
        }), this.disableNetworkKeepalive = (v = a.disableNetworkKeepalive) !== null && v !== void 0 ? v : false, this.initRequestRetries = (m = a.initRequestRetries) !== null && m !== void 0 ? m : r, this.overrideStableID = (p = a.overrideStableID) !== null && p !== void 0 ? p : null, this.localMode = (b = a.localMode) !== null && b !== void 0 ? b : false, this.initTimeoutMs = a.initTimeoutMs && a.initTimeoutMs >= 0 ? a.initTimeoutMs : n.INIT_TIMEOUT_DEFAULT_MS, this.disableErrorLogging = (S = a.disableErrorLogging) !== null && S !== void 0 ? S : false, this.disableAutoMetricsLogging = (x = a.disableAutoMetricsLogging) !== null && x !== void 0 ? x : false, this.initializeValues = (d = a.initializeValues) !== null && d !== void 0 ? d : null;
        var B = (E = (g = a.eventLoggingApi) !== null && g !== void 0 ? g : a.api) !== null && E !== void 0 ? E : e;
        this.eventLoggingApi = B.endsWith("/") ? B : B + "/", this.prefetchUsers = (f = a.prefetchUsers) !== null && f !== void 0 ? f : [], this.disableLocalStorage = (y = a.disableLocalStorage) !== null && y !== void 0 ? y : false, this.initCompletionCallback = (h = a.initCompletionCallback) !== null && h !== void 0 ? h : null, this.updateCompletionCallback = (_ = a.updateUserCompletionCallback) !== null && _ !== void 0 ? _ : null, this.disableDiagnosticsLogging = (T = a.disableDiagnosticsLogging) !== null && T !== void 0 ? T : false, this.logLevel = (L = a == null ? void 0 : a.logLevel) !== null && L !== void 0 ? L : i.NONE, this.logger = (M = a == null ? void 0 : a.logger) !== null && M !== void 0 ? M : console, this.ignoreWindowUndefined = (I = a == null ? void 0 : a.ignoreWindowUndefined) !== null && I !== void 0 ? I : false, this.fetchMode = (D = a.fetchMode) !== null && D !== void 0 ? D : "network-only", this.disableLocalOverrides = (O = a == null ? void 0 : a.disableLocalOverrides) !== null && O !== void 0 ? O : false, this.gateEvaluationCallback = (F = a == null ? void 0 : a.gateEvaluationCallback) !== null && F !== void 0 ? F : null, this.userPersistentStorage = (U = a == null ? void 0 : a.userPersistentStorage) !== null && U !== void 0 ? U : null, this.disableAllLogging = (X = a.disableAllLogging) !== null && X !== void 0 ? X : false, this.setLoggingCopy(a), this.disableHashing = ($ = a.disableHashing) !== null && $ !== void 0 ? $ : false, this.evaluationCallback = (rt = a.evaluationCallback) !== null && rt !== void 0 ? rt : null;
      }
      return o.prototype.setLoggingCopy = function(a) {
        if (!(a == null || this.loggingCopy != null)) {
          var c = {};
          Object.entries(a).forEach(function(l) {
            var u, v, m = l[0], p = l[1], b = typeof p;
            switch (b) {
              case "number":
              case "bigint":
              case "boolean":
                c[String(m)] = p;
                break;
              case "string":
                p.length < 50 ? c[String(m)] = p : c[String(m)] = "set";
                break;
              case "object":
                m === "environment" ? c.environment = p : m === "prefetchUsers" ? c.prefetchUsers = ((v = (u = a.prefetchUsers) === null || u === void 0 ? void 0 : u.length) !== null && v !== void 0 ? v : 0) > 0 : c[String(m)] = p != null ? "set" : "unset";
                break;
              case "function":
                m === "userPersistentStorage" && (c.userPersistentStorage = p != null ? "set" : "unset");
            }
          }), this.loggingCopy = c;
        }
      }, o.prototype.getLoggingCopy = function() {
        return this.loggingCopy;
      }, o.prototype.getOutputLogger = function() {
        return this.logger;
      }, o.prototype.getApi = function() {
        return this.api;
      }, o.prototype.getEnvironment = function() {
        return this.environment;
      }, o.prototype.getDisableCurrentPageLogging = function() {
        return this.disableCurrentPageLogging;
      }, o.prototype.getLoggingIntervalMillis = function() {
        return this.loggingIntervalMillis;
      }, o.prototype.getLoggingBufferMaxSize = function() {
        return this.loggingBufferMaxSize;
      }, o.prototype.getDisableNetworkKeepalive = function() {
        return this.disableNetworkKeepalive;
      }, o.prototype.getOverrideStableID = function() {
        return this.overrideStableID;
      }, o.prototype.getLocalModeEnabled = function() {
        return this.localMode;
      }, o.prototype.getInitTimeoutMs = function() {
        return this.initTimeoutMs;
      }, o.prototype.getDisableErrorLogging = function() {
        return this.disableErrorLogging;
      }, o.prototype.getDisableAutoMetricsLogging = function() {
        return this.disableAutoMetricsLogging;
      }, o.prototype.getInitializeValues = function() {
        return this.initializeValues;
      }, o.prototype.getEventLoggingApi = function() {
        return this.eventLoggingApi;
      }, o.prototype.getPrefetchUsers = function() {
        return this.prefetchUsers;
      }, o.prototype.getDisableLocalStorage = function() {
        return this.disableLocalStorage;
      }, o.prototype.getInitCompletionCallback = function() {
        return this.initCompletionCallback;
      }, o.prototype.getUpdateUserCompletionCallback = function() {
        return this.updateCompletionCallback;
      }, o.prototype.getDisableDiagnosticsLogging = function() {
        return this.disableDiagnosticsLogging;
      }, o.prototype.getLogLevel = function() {
        return this.logLevel;
      }, o.prototype.getIgnoreWindowUndefined = function() {
        return this.ignoreWindowUndefined;
      }, o.prototype.getFetchMode = function() {
        return this.fetchMode;
      }, o.prototype.getDisableLocalOverrides = function() {
        return this.disableLocalOverrides;
      }, o.prototype.getGateEvaluationCallback = function() {
        return this.gateEvaluationCallback;
      }, o.prototype.getUserPersistentStorage = function() {
        return this.userPersistentStorage;
      }, o.prototype.getDisableHashing = function() {
        return this.disableHashing;
      }, o.prototype.getInitRequestRetries = function() {
        return this.initRequestRetries;
      }, o.prototype.isAllLoggingDisabled = function() {
        return this.disableAllLogging;
      }, o.prototype.reenableAllLogging = function() {
        this.disableAllLogging = false;
      }, o.prototype.getEvaluationCallback = function() {
        return this.evaluationCallback;
      }, o.prototype.normalizeNumberInput = function(a, c) {
        return a == null ? c.default : Math.max(Math.min(a, c.max), c.min);
      }, o;
    }()
  );
  n.default = s;
})(ri);
var wr = N && N.__spreadArray || function(n, t, e) {
  if (e || arguments.length === 2) for (var r = 0, i = t.length, s; r < i; r++)
    (s || !(r in t)) && (s || (s = Array.prototype.slice.call(t, 0, r)), s[r] = t[r]);
  return n.concat(s || Array.prototype.slice.call(t));
};
Object.defineProperty(xe, "__esModule", { value: true });
var ze = ri;
var Yt = console;
var Ie = ze.LogLevel.WARN;
var Na = (
  /** @class */
  function() {
    function n() {
    }
    return n.getLogger = function() {
      return Yt;
    }, n.debug = function(t) {
      for (var e = [], r = 1; r < arguments.length; r++)
        e[r - 1] = arguments[r];
      Ie !== ze.LogLevel.NONE && Yt.debug && Yt.debug.apply(Yt, wr(["".concat(this.LOG_PREFIX, " ").concat(t)], e, false));
    }, n.info = function(t) {
      for (var e = [], r = 1; r < arguments.length; r++)
        e[r - 1] = arguments[r];
      Ie === ze.LogLevel.INFO && Yt.info.apply(Yt, wr(["".concat(this.LOG_PREFIX, " ").concat(t)], e, false));
    }, n.warn = function(t) {
      for (var e = [], r = 1; r < arguments.length; r++)
        e[r - 1] = arguments[r];
      Ie === ze.LogLevel.WARN && Yt.warn.apply(Yt, wr(["".concat(this.LOG_PREFIX, " ").concat(t)], e, false));
    }, n.error = function(t) {
      for (var e = [], r = 1; r < arguments.length; r++)
        e[r - 1] = arguments[r];
      Ie === ze.LogLevel.ERROR && Yt.error.apply(Yt, wr(["".concat(this.LOG_PREFIX, " ").concat(t)], e, false));
    }, n.setLogger = function(t) {
      Yt = t;
    }, n.setLogLevel = function(t) {
      Ie = t;
    }, n.resetLogger = function() {
      Yt = console, Ie = ze.LogLevel.WARN;
    }, n.LOG_PREFIX = "[Statsig]", n;
  }()
);
xe.default = Na;
var ni = {};
Object.defineProperty(ni, "__esModule", { value: true });
function Ya(n) {
  var t = n ?? Error("[Statsig] Error was empty"), e = t instanceof Error, r = e ? t.name : "No Name", i = e ? t.message : void 0, s = e ? t.stack : Ba(t);
  return { name: r, message: i, trace: s };
}
ni.default = Ya;
function Ba(n) {
  try {
    return JSON.stringify(n);
  } catch {
    return "[Statsig] Failed to get string for error.";
  }
}
(function(n) {
  var t = N && N.__awaiter || function(m, p, b, S) {
    function x(d) {
      return d instanceof b ? d : new b(function(g) {
        g(d);
      });
    }
    return new (b || (b = Promise))(function(d, g) {
      function E(h) {
        try {
          y(S.next(h));
        } catch (_) {
          g(_);
        }
      }
      function f(h) {
        try {
          y(S.throw(h));
        } catch (_) {
          g(_);
        }
      }
      function y(h) {
        h.done ? d(h.value) : x(h.value).then(E, f);
      }
      y((S = S.apply(m, p || [])).next());
    });
  }, e = N && N.__generator || function(m, p) {
    var b = { label: 0, sent: function() {
      if (d[0] & 1) throw d[1];
      return d[1];
    }, trys: [], ops: [] }, S, x, d, g;
    return g = { next: E(0), throw: E(1), return: E(2) }, typeof Symbol == "function" && (g[Symbol.iterator] = function() {
      return this;
    }), g;
    function E(y) {
      return function(h) {
        return f([y, h]);
      };
    }
    function f(y) {
      if (S) throw new TypeError("Generator is already executing.");
      for (; g && (g = 0, y[0] && (b = 0)), b; ) try {
        if (S = 1, x && (d = y[0] & 2 ? x.return : y[0] ? x.throw || ((d = x.return) && d.call(x), 0) : x.next) && !(d = d.call(x, y[1])).done) return d;
        switch (x = 0, d && (y = [y[0] & 2, d.value]), y[0]) {
          case 0:
          case 1:
            d = y;
            break;
          case 4:
            return b.label++, { value: y[1], done: false };
          case 5:
            b.label++, x = y[1], y = [0];
            continue;
          case 7:
            y = b.ops.pop(), b.trys.pop();
            continue;
          default:
            if (d = b.trys, !(d = d.length > 0 && d[d.length - 1]) && (y[0] === 6 || y[0] === 2)) {
              b = 0;
              continue;
            }
            if (y[0] === 3 && (!d || y[1] > d[0] && y[1] < d[3])) {
              b.label = y[1];
              break;
            }
            if (y[0] === 6 && b.label < d[1]) {
              b.label = d[1], d = y;
              break;
            }
            if (d && b.label < d[2]) {
              b.label = d[2], b.ops.push(y);
              break;
            }
            d[2] && b.ops.pop(), b.trys.pop();
            continue;
        }
        y = p.call(m, b);
      } catch (h) {
        y = [6, h], x = 0;
      } finally {
        S = d = 0;
      }
      if (y[0] & 5) throw y[1];
      return { value: y[0] ? y[1] : void 0, done: true };
    }
  }, r = N && N.__importDefault || function(m) {
    return m && m.__esModule ? m : { default: m };
  };
  Object.defineProperty(n, "__esModule", { value: true }), n.ExceptionEndpoint = void 0;
  var i = ei, s = Ut, o = r(ce), a = r(xe), c = r(ni);
  n.ExceptionEndpoint = "https://prodregistryv2.org/v1/rgstr_e";
  var l = 30, u = 1e4, v = (
    /** @class */
    function() {
      function m(p, b) {
        this.sdkKey = p, this.sdkOptions = b, this.seen = /* @__PURE__ */ new Set();
        var S = Math.floor(Math.random() * u);
        this.setupDiagnostics(S === 0 ? l : 0);
      }
      return m.prototype.setStatsigMetadata = function(p) {
        this.statsigMetadata = p;
      }, m.prototype.swallow = function(p, b, S) {
        S === void 0 && (S = {}), this.capture(p, b, function() {
        }, S);
      }, m.prototype.capture = function(p, b, S, x) {
        var d = this;
        x === void 0 && (x = {});
        var g = null;
        try {
          g = this.beginMarker(p);
          var E = b(), f = true;
          return E instanceof Promise ? E.catch(function(y) {
            return f = false, d.onCaught(p, y, S, x);
          }).then(function(y) {
            return d.endMarker(p, f, g), y;
          }) : (this.endMarker(p, true, g, x.configName), E);
        } catch (y) {
          return this.endMarker(p, false, g, x.configName), this.onCaught(p, y, S, x);
        }
      }, m.prototype.logError = function(p, b, S) {
        var x = this, d = S === void 0 ? {} : S, g = d.getExtraData, E = d.configName;
        this.sdkOptions.isAllLoggingDisabled() || function() {
          return t(x, void 0, void 0, function() {
            var f, y, h, _, T, L, M;
            return e(this, function(I) {
              try {
                return f = typeof g == "function" ? g() : {}, y = (0, c.default)(b), h = y.name, _ = y.trace, f.configName = E, this.seen.has(h) ? [
                  2
                  /*return*/
                ] : (this.seen.add(h), T = (M = this.statsigMetadata) !== null && M !== void 0 ? M : {}, T.sessionID == null && (T.sessionID = (0, i.v4)()), L = JSON.stringify({
                  tag: p,
                  exception: h,
                  info: _,
                  statsigMetadata: T,
                  statsigOptions: this.sdkOptions.getLoggingCopy(),
                  extra: f
                }), [2, fetch(n.ExceptionEndpoint, {
                  method: "POST",
                  headers: {
                    "STATSIG-API-KEY": this.sdkKey,
                    "STATSIG-SDK-TYPE": String(T.sdkType),
                    "STATSIG-SDK-VERSION": String(T.sdkVersion),
                    "Content-Type": "application/json; charset=UTF-8"
                  },
                  body: L
                })]);
              } catch {
              }
              return [
                2
                /*return*/
              ];
            });
          });
        }().catch(function() {
        });
      }, m.prototype.setupDiagnostics = function(p) {
        o.default.setMaxMarkers("api_call", p);
      }, m.prototype.beginMarker = function(p) {
        var b = o.default.mark.api_call(p);
        if (!b)
          return null;
        var S = o.default.getMarkerCount("api_call"), x = "".concat(p, "_").concat(S), d = b.start({
          markerID: x
        }, "api_call");
        return d ? x : null;
      }, m.prototype.endMarker = function(p, b, S, x) {
        var d = o.default.mark.api_call(p);
        !S || !d || d.end({
          markerID: S,
          success: b,
          configName: x
        }, "api_call");
      }, m.prototype.onCaught = function(p, b, S, x) {
        if (x === void 0 && (x = {}), b instanceof s.StatsigUninitializedError || b instanceof s.StatsigInvalidArgumentError)
          throw b;
        return b instanceof s.StatsigInitializationTimeoutError ? (a.default.error("Timeout occured.", b), S()) : (a.default.error("An unexpected exception occurred.", b), this.logError(p, b, x), S());
      }, m;
    }()
  );
  n.default = v;
})(Zs);
var en = {};
Object.defineProperty(en, "__esModule", { value: true });
var Ga = (
  /** @class */
  function() {
    function n(t, e, r, i, s, o, a) {
      s === void 0 && (s = null), o === void 0 && (o = null), a === void 0 && (a = []), this.name = t, this.value = e, this.ruleID = r ?? "", this.evaluationDetails = i, this.groupName = s, this.idType = o, this.secondaryExposures = a;
    }
    return n.prototype.getRuleID = function() {
      return this.ruleID;
    }, n.prototype.getGroupName = function() {
      return this.groupName;
    }, n.prototype.getIDType = function() {
      return this.idType;
    }, n.prototype.getName = function() {
      return this.name;
    }, n.prototype.getValue = function() {
      return this.value;
    }, n.prototype.getEvaluationDetails = function() {
      return this.evaluationDetails;
    }, n.prototype.getSecondaryExposures = function() {
      return this.secondaryExposures;
    }, n;
  }()
);
en.default = Ga;
var pr = {};
Object.defineProperty(pr, "__esModule", { value: true });
var Ha = (
  /** @class */
  function() {
    function n(t, e, r, i, s, o, a, c, l, u) {
      s === void 0 && (s = null), o === void 0 && (o = []), a === void 0 && (a = []), c === void 0 && (c = ""), l === void 0 && (l = []), u === void 0 && (u = null), this.logParameterFunction = s, this.name = t, this.value = JSON.parse(JSON.stringify(e ?? {})), this.ruleID = r ?? "", this.evaluationDetails = i, this.secondaryExposures = o, this.undelegatedSecondaryExposures = a, this.allocatedExperimentName = c, this.explicitParameters = l, this.groupName = u;
    }
    return n._create = function(t, e, r, i, s, o, a, c, l, u) {
      return s === void 0 && (s = null), o === void 0 && (o = []), a === void 0 && (a = []), c === void 0 && (c = ""), l === void 0 && (l = []), u === void 0 && (u = null), new n(t, e, r, i, s, o, a, c, l, u);
    }, n.prototype.get = function(t, e, r) {
      var i = this, s = this.value[t];
      if (s == null)
        return e;
      var o = function() {
        return i.logLayerParameterExposure(t), s;
      };
      return r ? r(s) ? o() : e : e == null || typeof s == typeof e && Array.isArray(e) === Array.isArray(s) ? o() : e;
    }, n.prototype.getValue = function(t, e) {
      e == null && (e = null);
      var r = this.value[t];
      return r != null && this.logLayerParameterExposure(t), r ?? e;
    }, n.prototype.getRuleID = function() {
      return this.ruleID;
    }, n.prototype.getGroupName = function() {
      return this.groupName;
    }, n.prototype.getName = function() {
      return this.name;
    }, n.prototype.getEvaluationDetails = function() {
      return this.evaluationDetails;
    }, n.prototype._getSecondaryExposures = function() {
      return this.secondaryExposures;
    }, n.prototype._getUndelegatedSecondaryExposures = function() {
      return this.undelegatedSecondaryExposures;
    }, n.prototype._getAllocatedExperimentName = function() {
      return this.allocatedExperimentName;
    }, n.prototype._getExplicitParameters = function() {
      return this.explicitParameters;
    }, n.prototype._getEvaluationDetails = function() {
      return this.evaluationDetails;
    }, n.prototype.logLayerParameterExposure = function(t) {
      var e;
      (e = this.logParameterFunction) === null || e === void 0 || e.call(this, this, t);
    }, n;
  }()
);
pr.default = Ha;
var rn = {};
var Bn = N && N.__assign || function() {
  return Bn = Object.assign || function(n) {
    for (var t, e = 1, r = arguments.length; e < r; e++) {
      t = arguments[e];
      for (var i in t) Object.prototype.hasOwnProperty.call(t, i) && (n[i] = t[i]);
    }
    return n;
  }, Bn.apply(this, arguments);
};
Object.defineProperty(rn, "__esModule", { value: true });
var Ka = (
  /** @class */
  function() {
    function n(t) {
      this.user = null, this.value = null, this.metadata = null, this.eventName = t, this.statsigMetadata = {}, this.time = Date.now();
    }
    return n.prototype.getName = function() {
      return this.eventName;
    }, n.prototype.setValue = function(t) {
      this.value = t;
    }, n.prototype.setMetadata = function(t) {
      this.metadata = t;
    }, n.prototype.addStatsigMetadata = function(t, e) {
      this.statsigMetadata[t] = e;
    }, n.prototype.setUser = function(t) {
      this.user = Bn({}, t), delete this.user.privateAttributes;
    }, n.prototype.setSecondaryExposures = function(t) {
      t === void 0 && (t = []), this.secondaryExposures = t;
    }, n.prototype.toJsonObject = function() {
      var t;
      return {
        eventName: this.eventName,
        user: this.user,
        value: this.value,
        metadata: this.metadata,
        time: this.time,
        statsigMetadata: this.statsigMetadata,
        secondaryExposures: (t = this.secondaryExposures) !== null && t !== void 0 ? t : void 0
      };
    }, n;
  }()
);
rn.default = Ka;
var ii = {};
var nn = {};
Object.defineProperty(nn, "__esModule", { value: true });
nn.version = void 0;
nn.version = "5.1.0";
var yt = {};
Object.defineProperty(yt, "__esModule", { value: true });
yt.STORAGE_PREFIX = yt.LOCAL_STORAGE_KEYS = yt.STATSIG_LOCAL_STORAGE_LOGGING_REQUEST_KEY = yt.STATSIG_STABLE_ID_KEY = yt.INTERNAL_STORE_KEY = yt.STICKY_DEVICE_EXPERIMENTS_KEY = yt.OVERRIDES_STORE_KEY = void 0;
yt.OVERRIDES_STORE_KEY = "STATSIG_LOCAL_STORAGE_INTERNAL_STORE_OVERRIDES_V3";
yt.STICKY_DEVICE_EXPERIMENTS_KEY = "STATSIG_LOCAL_STORAGE_STICKY_DEVICE_EXPERIMENTS";
yt.INTERNAL_STORE_KEY = "STATSIG_LOCAL_STORAGE_INTERNAL_STORE_V4";
yt.STATSIG_STABLE_ID_KEY = "STATSIG_LOCAL_STORAGE_STABLE_ID";
yt.STATSIG_LOCAL_STORAGE_LOGGING_REQUEST_KEY = "STATSIG_LOCAL_STORAGE_LOGGING_REQUEST";
yt.LOCAL_STORAGE_KEYS = {
  STATSIG_LOCAL_STORAGE_STABLE_ID: true,
  STATSIG_LOCAL_STORAGE_INTERNAL_STORE_V4: true,
  STATSIG_LOCAL_STORAGE_STICKY_DEVICE_EXPERIMENTS: true,
  STATSIG_LOCAL_STORAGE_INTERNAL_STORE_OVERRIDES_V3: true,
  STATSIG_LOCAL_STORAGE_LOGGING_REQUEST: true
};
yt.STORAGE_PREFIX = "STATSIG_LOCAL_STORAGE";
var Oe = {};
Object.defineProperty(Oe, "__esModule", { value: true });
var Xa = (
  /** @class */
  function() {
    function n() {
    }
    return n.getItemAsync = function(t) {
      var e;
      return n.asyncStorage ? (e = n.asyncStorage.getItem(t)) !== null && e !== void 0 ? e : null : Promise.resolve(null);
    }, n.setItemAsync = function(t, e) {
      return n.asyncStorage ? n.asyncStorage.setItem(t, e) : Promise.resolve();
    }, n.removeItemAsync = function(t) {
      return n.asyncStorage ? n.asyncStorage.removeItem(t) : Promise.resolve();
    }, n;
  }()
);
Oe.default = Xa;
var Be = {};
Object.defineProperty(Be, "__esModule", { value: true });
var yn = yt;
var Za = (
  /** @class */
  function() {
    function n() {
    }
    return n.getItem = function(t) {
      var e;
      try {
        if (this.isStorageAccessible())
          return window.localStorage.getItem(t);
      } catch {
      }
      return (e = this.fallbackSessionCache[t]) !== null && e !== void 0 ? e : null;
    }, n.setItem = function(t, e) {
      try {
        if (this.isStorageAccessible()) {
          window.localStorage.setItem(t, e);
          return;
        }
      } catch {
      }
      this.fallbackSessionCache[t] = e;
    }, n.removeItem = function(t) {
      try {
        if (this.isStorageAccessible()) {
          window.localStorage.removeItem(t);
          return;
        }
      } catch {
      }
      delete this.fallbackSessionCache[t];
    }, n.cleanup = function() {
      try {
        if (this.isStorageAccessible(true))
          for (var t in window.localStorage)
            typeof window.localStorage[t] == "string" && t != null && (!this.disabled && t in yn.LOCAL_STORAGE_KEYS || !this.disabled && t.substring(0, yn.STORAGE_PREFIX.length) !== yn.STORAGE_PREFIX || window.localStorage.removeItem(t));
      } catch {
      }
    }, n.isStorageAccessible = function(t) {
      t === void 0 && (t = false), this.canAccessStorageAccessible == null && (this.canAccessStorageAccessible = typeof Storage < "u" && typeof window < "u" && window != null && window.localStorage != null);
      var e = this.canAccessStorageAccessible;
      return (t || !this.disabled) && e;
    }, n.disabled = false, n.fallbackSessionCache = {}, n.canAccessStorageAccessible = null, n;
  }()
);
Be.default = Za;
var Wa = N && N.__awaiter || function(n, t, e, r) {
  function i(s) {
    return s instanceof e ? s : new e(function(o) {
      o(s);
    });
  }
  return new (e || (e = Promise))(function(s, o) {
    function a(u) {
      try {
        l(r.next(u));
      } catch (v) {
        o(v);
      }
    }
    function c(u) {
      try {
        l(r.throw(u));
      } catch (v) {
        o(v);
      }
    }
    function l(u) {
      u.done ? s(u.value) : i(u.value).then(a, c);
    }
    l((r = r.apply(n, t || [])).next());
  });
};
var qa = N && N.__generator || function(n, t) {
  var e = { label: 0, sent: function() {
    if (s[0] & 1) throw s[1];
    return s[1];
  }, trys: [], ops: [] }, r, i, s, o;
  return o = { next: a(0), throw: a(1), return: a(2) }, typeof Symbol == "function" && (o[Symbol.iterator] = function() {
    return this;
  }), o;
  function a(l) {
    return function(u) {
      return c([l, u]);
    };
  }
  function c(l) {
    if (r) throw new TypeError("Generator is already executing.");
    for (; o && (o = 0, l[0] && (e = 0)), e; ) try {
      if (r = 1, i && (s = l[0] & 2 ? i.return : l[0] ? i.throw || ((s = i.return) && s.call(i), 0) : i.next) && !(s = s.call(i, l[1])).done) return s;
      switch (i = 0, s && (l = [l[0] & 2, s.value]), l[0]) {
        case 0:
        case 1:
          s = l;
          break;
        case 4:
          return e.label++, { value: l[1], done: false };
        case 5:
          e.label++, i = l[1], l = [0];
          continue;
        case 7:
          l = e.ops.pop(), e.trys.pop();
          continue;
        default:
          if (s = e.trys, !(s = s.length > 0 && s[s.length - 1]) && (l[0] === 6 || l[0] === 2)) {
            e = 0;
            continue;
          }
          if (l[0] === 3 && (!s || l[1] > s[0] && l[1] < s[3])) {
            e.label = l[1];
            break;
          }
          if (l[0] === 6 && e.label < s[1]) {
            e.label = s[1], s = l;
            break;
          }
          if (s && e.label < s[2]) {
            e.label = s[2], e.ops.push(l);
            break;
          }
          s[2] && e.ops.pop(), e.trys.pop();
          continue;
      }
      l = t.call(n, e);
    } catch (u) {
      l = [6, u], i = 0;
    } finally {
      r = s = 0;
    }
    if (l[0] & 5) throw l[1];
    return { value: l[0] ? l[1] : void 0, done: true };
  }
};
var eo = N && N.__importDefault || function(n) {
  return n && n.__esModule ? n : { default: n };
};
Object.defineProperty(ii, "__esModule", { value: true });
var Qa = ei;
var $a = nn;
var xr = yt;
var En = eo(Oe);
var Vi = eo(Be);
var Ja = (
  /** @class */
  function() {
    function n(t, e, r) {
      var i;
      this.platform = null, this.nativeModules = null, this.sdkType = "js-client", this.reactNativeUUID = r, this.user = t, this.sdkVersion = $a.version, this.statsigMetadata = {
        sdkType: this.sdkType,
        sdkVersion: this.sdkVersion
      };
      var s = e;
      En.default.asyncStorage || (s = (i = s ?? Vi.default.getItem(xr.STATSIG_STABLE_ID_KEY)) !== null && i !== void 0 ? i : this.getUUID()), s && (this.statsigMetadata.stableID = s);
    }
    return n.prototype.saveStableID = function() {
      this.statsigMetadata.stableID != null && Vi.default.setItem(xr.STATSIG_STABLE_ID_KEY, this.statsigMetadata.stableID);
    }, n.prototype.initAsync = function() {
      return Wa(this, void 0, void 0, function() {
        var t;
        return qa(this, function(e) {
          switch (e.label) {
            case 0:
              return t = this.statsigMetadata.stableID, t ? [3, 2] : [4, En.default.getItemAsync(xr.STATSIG_STABLE_ID_KEY)];
            case 1:
              t = e.sent(), t = t ?? this.getUUID(), e.label = 2;
            case 2:
              return this.statsigMetadata.stableID = t, En.default.setItemAsync(xr.STATSIG_STABLE_ID_KEY, t).catch(function() {
              }), [2, this];
          }
        });
      });
    }, n.prototype.getSDKType = function() {
      return this.sdkType;
    }, n.prototype.getSDKVersion = function() {
      return this.sdkVersion;
    }, n.prototype.getStatsigMetadata = function() {
      return this.statsigMetadata.sdkType = this.sdkType, this.statsigMetadata.sdkVersion = this.sdkVersion, this.statsigMetadata;
    }, n.prototype.getUser = function() {
      return this.user;
    }, n.prototype.updateUser = function(t) {
      this.user = t;
    }, n.prototype.setSDKPackageInfo = function(t) {
      this.sdkType = t.sdkType, this.sdkVersion = t.sdkVersion;
    }, n.prototype.setPlatform = function(t) {
      this.platform = t, this.updateMetadataFromNativeModules();
    }, n.prototype.setNativeModules = function(t) {
      this.nativeModules = t, this.updateMetadataFromNativeModules();
    }, n.prototype.updateMetadataFromNativeModules = function() {
      var t, e, r, i, s, o, a;
      this.platform == null || this.nativeModules == null || (((t = this.platform.OS) === null || t === void 0 ? void 0 : t.toLocaleLowerCase()) === "android" ? this.statsigMetadata.locale = (e = this.nativeModules.I18nManager) === null || e === void 0 ? void 0 : e.localeIdentifier : ((r = this.platform.OS) === null || r === void 0 ? void 0 : r.toLocaleLowerCase()) === "ios" && (this.statsigMetadata.locale = ((s = (i = this.nativeModules.SettingsManager) === null || i === void 0 ? void 0 : i.settings) === null || s === void 0 ? void 0 : s.AppleLocale) || ((a = (o = this.nativeModules.SettingsManager) === null || o === void 0 ? void 0 : o.settings) === null || a === void 0 ? void 0 : a.AppleLanguages[0])));
    }, n.prototype.getUUID = function() {
      var t, e;
      return (e = (t = this.reactNativeUUID) === null || t === void 0 ? void 0 : t.v4()) !== null && e !== void 0 ? e : (0, Qa.v4)();
    }, n.prototype.setRNDeviceInfo = function(t) {
      var e, r, i, s, o;
      this.statsigMetadata.appVersion = (e = t.getVersion()) !== null && e !== void 0 ? e : "", this.statsigMetadata.systemVersion = (r = t.getSystemVersion()) !== null && r !== void 0 ? r : "", this.statsigMetadata.systemName = (i = t.getSystemName()) !== null && i !== void 0 ? i : "", this.statsigMetadata.deviceModelName = (s = t.getModel()) !== null && s !== void 0 ? s : "", this.statsigMetadata.deviceModel = (o = t.getDeviceId()) !== null && o !== void 0 ? o : "";
    }, n.prototype.setExpoConstants = function(t) {
      var e, r;
      this.statsigMetadata.appVersion = (r = (e = t.nativeAppVersion) !== null && e !== void 0 ? e : t.nativeBuildVersion) !== null && r !== void 0 ? r : "";
    }, n.prototype.setExpoDevice = function(t) {
      var e, r, i, s;
      this.statsigMetadata.systemVersion = (e = t.osVersion) !== null && e !== void 0 ? e : "", this.statsigMetadata.systemName = (r = t.osName) !== null && r !== void 0 ? r : "", this.statsigMetadata.deviceModelName = (i = t.modelName) !== null && i !== void 0 ? i : "", this.statsigMetadata.deviceModel = (s = t.modelId) !== null && s !== void 0 ? s : "";
    }, n;
  }()
);
ii.default = Ja;
var si = {};
var oi = {};
var sn = {};
Object.defineProperty(sn, "__esModule", { value: true });
var tl = (
  /** @class */
  function() {
    function n() {
    }
    return n.encodeInitializeCall = true, n;
  }()
);
sn.default = tl;
(function(n) {
  var t = N && N.__assign || function() {
    return t = Object.assign || function(m) {
      for (var p, b = 1, S = arguments.length; b < S; b++) {
        p = arguments[b];
        for (var x in p) Object.prototype.hasOwnProperty.call(p, x) && (m[x] = p[x]);
      }
      return m;
    }, t.apply(this, arguments);
  }, e = N && N.__awaiter || function(m, p, b, S) {
    function x(d) {
      return d instanceof b ? d : new b(function(g) {
        g(d);
      });
    }
    return new (b || (b = Promise))(function(d, g) {
      function E(h) {
        try {
          y(S.next(h));
        } catch (_) {
          g(_);
        }
      }
      function f(h) {
        try {
          y(S.throw(h));
        } catch (_) {
          g(_);
        }
      }
      function y(h) {
        h.done ? d(h.value) : x(h.value).then(E, f);
      }
      y((S = S.apply(m, p || [])).next());
    });
  }, r = N && N.__generator || function(m, p) {
    var b = { label: 0, sent: function() {
      if (d[0] & 1) throw d[1];
      return d[1];
    }, trys: [], ops: [] }, S, x, d, g;
    return g = { next: E(0), throw: E(1), return: E(2) }, typeof Symbol == "function" && (g[Symbol.iterator] = function() {
      return this;
    }), g;
    function E(y) {
      return function(h) {
        return f([y, h]);
      };
    }
    function f(y) {
      if (S) throw new TypeError("Generator is already executing.");
      for (; g && (g = 0, y[0] && (b = 0)), b; ) try {
        if (S = 1, x && (d = y[0] & 2 ? x.return : y[0] ? x.throw || ((d = x.return) && d.call(x), 0) : x.next) && !(d = d.call(x, y[1])).done) return d;
        switch (x = 0, d && (y = [y[0] & 2, d.value]), y[0]) {
          case 0:
          case 1:
            d = y;
            break;
          case 4:
            return b.label++, { value: y[1], done: false };
          case 5:
            b.label++, x = y[1], y = [0];
            continue;
          case 7:
            y = b.ops.pop(), b.trys.pop();
            continue;
          default:
            if (d = b.trys, !(d = d.length > 0 && d[d.length - 1]) && (y[0] === 6 || y[0] === 2)) {
              b = 0;
              continue;
            }
            if (y[0] === 3 && (!d || y[1] > d[0] && y[1] < d[3])) {
              b.label = y[1];
              break;
            }
            if (y[0] === 6 && b.label < d[1]) {
              b.label = d[1], d = y;
              break;
            }
            if (d && b.label < d[2]) {
              b.label = d[2], b.ops.push(y);
              break;
            }
            d[2] && b.ops.pop(), b.trys.pop();
            continue;
        }
        y = p.call(m, b);
      } catch (h) {
        y = [6, h], x = 0;
      } finally {
        S = d = 0;
      }
      if (y[0] & 5) throw y[1];
      return { value: y[0] ? y[1] : void 0, done: true };
    }
  }, i = N && N.__importDefault || function(m) {
    return m && m.__esModule ? m : { default: m };
  };
  Object.defineProperty(n, "__esModule", { value: true }), n.StatsigEndpoint = void 0;
  var s = Ut, o = i(sn), a = i(ce), c = i(xe), l;
  (function(m) {
    m.Initialize = "initialize", m.Rgstr = "rgstr", m.LogEventBeacon = "rgstr_b";
  })(l = n.StatsigEndpoint || (n.StatsigEndpoint = {}));
  var u = 204, v = (
    /** @class */
    function() {
      function m(p) {
        this.retryCodes = {
          408: true,
          500: true,
          502: true,
          503: true,
          504: true,
          522: true,
          524: true,
          599: true
        }, this.canUseKeepalive = false, this.sdkInternal = p, this.leakyBucket = {}, this.init();
      }
      return m.prototype.init = function() {
        if (!this.sdkInternal.getOptions().getDisableNetworkKeepalive())
          try {
            this.canUseKeepalive = "keepalive" in new Request("");
          } catch {
            this.canUseKeepalive = false;
          }
      }, m.prototype.fetchValues = function(p) {
        var b = p.user, S = p.sinceTime, x = p.timeout, d = p.useDeltas, g = p.prefetchUsers, E = p.previousDerivedFields, f = p.hadBadDeltaChecksum, y = p.badChecksum, h = p.badMergedConfigs, _ = p.badFullResponse, T = {
          user: b,
          prefetchUsers: g,
          statsigMetadata: this.sdkInternal.getStatsigMetadata(),
          sinceTime: S ?? void 0,
          deltasResponseRequested: d,
          hash: this.sdkInternal.getOptions().getDisableHashing() ? "none" : "djb2",
          previousDerivedFields: E,
          hadBadDeltaChecksum: f,
          badChecksum: y,
          badMergedConfigs: h,
          badFullResponse: _
        };
        return this.postWithTimeout(l.Initialize, T, {
          timeout: x,
          retries: this.sdkInternal.getOptions().getInitRequestRetries(),
          diagnostics: a.default.mark.initialize.networkRequest
        });
      }, m.prototype.postWithTimeout = function(p, b, S) {
        var x = this, d = S ?? {}, g = d.timeout, E = g === void 0 ? 0 : g, f = d.retries, y = f === void 0 ? 0 : f, h = d.backoff, _ = h === void 0 ? 1e3 : h, T = d.diagnostics, L = T === void 0 ? null : T, M = false, I = null, D, O = null, F = [], U = function(Y) {
          return function(B) {
            return M && O ? B(O) : F.push(B), Y;
          };
        };
        E != 0 && (I = new Promise(function(Y, B) {
          D = setTimeout(function() {
            M = true, B(new s.StatsigInitializationTimeoutError(E));
          }, E);
        }));
        var X, $ = this.postToEndpoint(p, b, {
          retryOptions: {
            retryLimit: y,
            backoff: _
          },
          diagnostics: L
        }).then(function(Y) {
          if (X = Y, !X.ok) {
            var B = "Request to ".concat(p, " failed with status ").concat(X.status);
            return c.default.error(B), Promise.reject(new Error(B));
          }
          if (typeof X.data != "object") {
            var B = "Request to ".concat(p, " received invalid response type. Expected 'object' but got '").concat(typeof X.data, "'");
            c.default.error(B);
            var V = new Error(B);
            return x.sdkInternal.getErrorBoundary().logError("postWithTimeoutInvalidRes", V, {
              getExtraData: function() {
                return x.getErrorData(p, b, y, _, X);
              }
            }), Promise.reject(V);
          }
          var q = X.data;
          return x.sdkInternal.getErrorBoundary().capture("postWithTimeout", function() {
            return e(x, void 0, void 0, function() {
              return r(this, function(nt) {
                return O = q, M && (F.forEach(function(C) {
                  return C(q);
                }), F = []), [2, Promise.resolve(q)];
              });
            });
          }, function() {
            return Promise.resolve({});
          }, {
            getExtraData: function() {
              return x.getErrorData(p, b, y, _, X);
            }
          });
        }).catch(function(Y) {
          return Promise.reject(Y);
        }).finally(function() {
          clearTimeout(D);
        }), rt = I ? Promise.race([$, I]) : $;
        return rt.eventually = U(rt), rt;
      }, m.prototype.sendLogBeacon = function(p) {
        var b = this.sdkInternal.getOptions();
        if (b.getLocalModeEnabled())
          return true;
        var S = new URL(b.getEventLoggingApi() + l.LogEventBeacon);
        S.searchParams.append("k", this.sdkInternal.getSDKKey()), p.clientTime = Date.now() + "";
        var x = null;
        try {
          x = JSON.stringify(p);
        } catch {
          return false;
        }
        return navigator.sendBeacon(S.toString(), x);
      }, m.prototype.postToEndpoint = function(p, b, S) {
        var x;
        return e(this, void 0, void 0, function() {
          var d, g, E, f, y, h, _, T, L, M, I, D, O, F, U, X, $, rt, Y, B, V, q, nt = this;
          return r(this, function(C) {
            if (d = S ?? {}, g = d.useKeepalive, E = g === void 0 ? false : g, f = d.diagnostics, y = f === void 0 ? null : f, h = (x = S == null ? void 0 : S.retryOptions) !== null && x !== void 0 ? x : {}, _ = h.retryLimit, T = _ === void 0 ? 0 : _, L = h.attempt, M = L === void 0 ? 1 : L, I = h.backoff, D = I === void 0 ? 1e3 : I, O = this.sdkInternal.getOptions(), O.getLocalModeEnabled())
              return [2, Promise.resolve({})];
            if (typeof fetch != "function")
              return c.default.error("Not issuing network request because fetch is not defined"), [2, Promise.resolve({})];
            if (typeof window > "u" && !O.getIgnoreWindowUndefined())
              return c.default.error("Not issuing network request because window is not defined. To bypass this, set ignoreWindowUndefined in StatsigOptions"), [2, Promise.resolve({})];
            if (F = [l.Initialize].includes(p) ? O.getApi() : O.getEventLoggingApi(), U = F + p, X = this.leakyBucket[U], X != null && X >= 30)
              return [2, Promise.reject(new Error("Request failed because you are making the same request too frequently."))];
            if (X == null ? this.leakyBucket[U] = 1 : this.leakyBucket[U] = X + 1, $ = p === l.Initialize && o.default.encodeInitializeCall && typeof window < "u" && typeof (window == null ? void 0 : window.btoa) == "function", rt = JSON.stringify(b), $)
              try {
                Y = window.btoa(rt).split("").reverse().join(""), rt = Y;
              } catch {
                $ = false;
              }
            return B = {
              method: "POST",
              body: rt,
              headers: t({ "Content-type": "application/json; charset=UTF-8", "STATSIG-API-KEY": this.sdkInternal.getSDKKey(), "STATSIG-CLIENT-TIME": Date.now() + "", "STATSIG-SDK-TYPE": this.sdkInternal.getSDKType(), "STATSIG-SDK-VERSION": this.sdkInternal.getSDKVersion(), "STATSIG-ENCODED": $ ? "1" : "0" }, S == null ? void 0 : S.additionalHeaders)
            }, this.canUseKeepalive && E && (B.keepalive = true), y == null || y.start({ attempt: M }), q = true, [2, fetch(U, B).then(function(st) {
              return e(nt, void 0, void 0, function() {
                var St, At, zt;
                return r(this, function(Xt) {
                  switch (Xt.label) {
                    case 0:
                      return V = st, V.ok ? (St = V, V.status !== u ? [3, 1] : (St.data = { has_updates: false, is_no_content: true }, [3, 3])) : [3, 4];
                    case 1:
                      return [4, V.text()];
                    case 2:
                      At = Xt.sent(), St.data = JSON.parse(At), Xt.label = 3;
                    case 3:
                      return y == null || y.end(this.getDiagnosticsData(V, M)), [2, Promise.resolve(St)];
                    case 4:
                      return this.retryCodes[V.status] || (q = false), [4, V.text()];
                    case 5:
                      return zt = Xt.sent(), [2, Promise.reject(new Error("".concat(V.status, ": ").concat(zt)))];
                  }
                });
              });
            }).catch(function(st) {
              y == null || y.end(nt.getDiagnosticsData(V, M, st));
              var St = "Error occurred while posting to endpoint: ".concat(st.message, `
`) + "Error Details: ".concat(JSON.stringify(st), `
`) + "Endpoint: ".concat(p, `
`) + "Attempt: ".concat(M, `
`) + "Retry Limit: ".concat(T, `
`) + "Backoff: ".concat(D);
              return c.default.error(St), M < T && q ? new Promise(function(At, zt) {
                setTimeout(function() {
                  nt.leakyBucket[U] = Math.max(nt.leakyBucket[U] - 1, 0), nt.postToEndpoint(p, b, {
                    retryOptions: {
                      retryLimit: T,
                      attempt: M + 1,
                      backoff: D * 2
                    },
                    useKeepalive: E,
                    diagnostics: y
                  }).then(At).catch(zt);
                }, D);
              }) : Promise.reject(st);
            }).finally(function() {
              nt.leakyBucket[U] = Math.max(nt.leakyBucket[U] - 1, 0);
            })];
          });
        });
      }, m.prototype.supportsKeepalive = function() {
        return this.canUseKeepalive;
      }, m.prototype.getDiagnosticsData = function(p, b, S) {
        var x, d;
        return {
          success: (p == null ? void 0 : p.ok) === true,
          statusCode: p == null ? void 0 : p.status,
          sdkRegion: (x = p == null ? void 0 : p.headers) === null || x === void 0 ? void 0 : x.get("x-statsig-region"),
          isDelta: ((d = p == null ? void 0 : p.data) === null || d === void 0 ? void 0 : d.is_delta) === true,
          attempt: b,
          error: a.default.formatError(S)
        };
      }, m.prototype.getErrorData = function(p, b, S, x, d) {
        var g;
        try {
          var E = {};
          return ((g = d.headers) !== null && g !== void 0 ? g : []).forEach(function(f, y) {
            E[y] = f;
          }), {
            responseInfo: {
              headers: E,
              status: d.status,
              statusText: d.statusText,
              type: d.type,
              url: d.url,
              redirected: d.redirected,
              bodySnippet: d.data ? JSON.stringify(d.data).slice(0, 500) : null
            },
            requestInfo: {
              endpointName: p,
              bodySnippet: JSON.stringify(b).slice(0, 500),
              retries: S,
              backoff: x
            }
          };
        } catch {
          return {
            statusText: "statsig::failed to extract extra data"
          };
        }
      }, m;
    }()
  );
  n.default = v;
})(oi);
var Gn = N && N.__assign || function() {
  return Gn = Object.assign || function(n) {
    for (var t, e = 1, r = arguments.length; e < r; e++) {
      t = arguments[e];
      for (var i in t) Object.prototype.hasOwnProperty.call(t, i) && (n[i] = t[i]);
    }
    return n;
  }, Gn.apply(this, arguments);
};
var el = N && N.__awaiter || function(n, t, e, r) {
  function i(s) {
    return s instanceof e ? s : new e(function(o) {
      o(s);
    });
  }
  return new (e || (e = Promise))(function(s, o) {
    function a(u) {
      try {
        l(r.next(u));
      } catch (v) {
        o(v);
      }
    }
    function c(u) {
      try {
        l(r.throw(u));
      } catch (v) {
        o(v);
      }
    }
    function l(u) {
      u.done ? s(u.value) : i(u.value).then(a, c);
    }
    l((r = r.apply(n, t || [])).next());
  });
};
var rl = N && N.__generator || function(n, t) {
  var e = { label: 0, sent: function() {
    if (s[0] & 1) throw s[1];
    return s[1];
  }, trys: [], ops: [] }, r, i, s, o;
  return o = { next: a(0), throw: a(1), return: a(2) }, typeof Symbol == "function" && (o[Symbol.iterator] = function() {
    return this;
  }), o;
  function a(l) {
    return function(u) {
      return c([l, u]);
    };
  }
  function c(l) {
    if (r) throw new TypeError("Generator is already executing.");
    for (; o && (o = 0, l[0] && (e = 0)), e; ) try {
      if (r = 1, i && (s = l[0] & 2 ? i.return : l[0] ? i.throw || ((s = i.return) && s.call(i), 0) : i.next) && !(s = s.call(i, l[1])).done) return s;
      switch (i = 0, s && (l = [l[0] & 2, s.value]), l[0]) {
        case 0:
        case 1:
          s = l;
          break;
        case 4:
          return e.label++, { value: l[1], done: false };
        case 5:
          e.label++, i = l[1], l = [0];
          continue;
        case 7:
          l = e.ops.pop(), e.trys.pop();
          continue;
        default:
          if (s = e.trys, !(s = s.length > 0 && s[s.length - 1]) && (l[0] === 6 || l[0] === 2)) {
            e = 0;
            continue;
          }
          if (l[0] === 3 && (!s || l[1] > s[0] && l[1] < s[3])) {
            e.label = l[1];
            break;
          }
          if (l[0] === 6 && e.label < s[1]) {
            e.label = s[1], s = l;
            break;
          }
          if (s && e.label < s[2]) {
            e.label = s[2], e.ops.push(l);
            break;
          }
          s[2] && e.ops.pop(), e.trys.pop();
          continue;
      }
      l = t.call(n, e);
    } catch (u) {
      l = [6, u], i = 0;
    } finally {
      r = s = 0;
    }
    if (l[0] & 5) throw l[1];
    return { value: l[0] ? l[1] : void 0, done: true };
  }
};
var gr = N && N.__importDefault || function(n) {
  return n && n.__esModule ? n : { default: n };
};
Object.defineProperty(si, "__esModule", { value: true });
var nl = ei;
var Le = gr(rn);
var zi = oi;
var De = yt;
var We = gr(ce);
var Ni = gr(xe);
var Ae = gr(Oe);
var Sn = gr(Be);
var Kt = "statsig::";
var il = Kt + "config_exposure";
var sl = Kt + "layer_exposure";
var ol = Kt + "gate_exposure";
var al = Kt + "log_event_failed";
var ll = Kt + "app_error";
var cl = Kt + "app_metrics::page_load_time";
var ul = Kt + "app_metrics::dom_interactive_time";
var hl = Kt + "app_metrics::scroll_depth";
var dl = Kt + "app_metrics::time_on_page_ms";
var fl = Kt + "diagnostics";
var pl = Kt + "default_value_type_mismatch";
var gl = Kt + "non_exposed_checks";
var vl = 5 * 24 * 60 * 60 * 1e3;
var ml = 100;
var ro = 1e3;
var Yi = 1024 * ro;
var _l = 10;
var yl = (
  /** @class */
  function() {
    function n(t) {
      this.failedLogEventCount = 0, this.debugInfo = void 0, this.sdkInternal = t, this.queue = [], this.nonExposedChecks = {}, this.flushInterval = null, this.loggedErrors = /* @__PURE__ */ new Set(), this.failedLogEvents = [], this.exposureDedupeKeys = {}, this.failedLogEventCount = 0, this.init();
    }
    return n.prototype.init = function() {
      var t = this;
      typeof window < "u" && typeof window.addEventListener == "function" && (window.addEventListener("blur", function() {
        return t.flush(true);
      }), window.addEventListener("beforeunload", function() {
        return t.flush(true);
      }), window.addEventListener("load", function() {
        setTimeout(function() {
          return t.flush();
        }, 100), setTimeout(function() {
          return t.flush();
        }, 1e3);
      })), typeof document < "u" && typeof document.addEventListener == "function" && document.addEventListener("visibilitychange", function() {
        t.flush(document.visibilityState !== "visible");
      }), !(!this.sdkInternal.getOptions().getIgnoreWindowUndefined() && (typeof window > "u" || window == null)) && (this.sdkInternal.getOptions().getLocalModeEnabled() || (this.flushInterval = setInterval(function() {
        t.flush();
      }, this.sdkInternal.getOptions().getLoggingIntervalMillis()), setTimeout(function() {
        return t.flush();
      }, 100), setTimeout(function() {
        return t.flush();
      }, 1e3)));
    }, n.prototype.log = function(t) {
      if (!this.sdkInternal.getOptions().isAllLoggingDisabled()) {
        try {
          if (!this.sdkInternal.getOptions().getDisableCurrentPageLogging() && typeof window < "u" && window != null && typeof window.location == "object" && typeof window.location.href == "string") {
            var e = window.location.href.split(/[?#]/);
            (e == null ? void 0 : e.length) > 0 && t.addStatsigMetadata("currentPage", e[0]);
          }
        } catch {
        }
        this.queue.push(t.toJsonObject()), this.queue.length >= this.sdkInternal.getOptions().getLoggingBufferMaxSize() && this.flush();
      }
    }, n.prototype.resetDedupeKeys = function() {
      this.exposureDedupeKeys = {};
    }, n.prototype.setDebugInfo = function(t) {
      this.debugInfo = t;
    }, n.prototype.shouldLogExposure = function(t) {
      var e = this.exposureDedupeKeys[t], r = Date.now();
      return e == null ? (this.exposureDedupeKeys[t] = r, true) : e >= r - 600 * 1e3 ? false : (this.exposureDedupeKeys[t] = r, true);
    }, n.prototype.addNonExposedCheck = function(t) {
      this.nonExposedChecks[t] == null ? this.nonExposedChecks[t] = 1 : this.nonExposedChecks[t]++;
    }, n.prototype.logGateExposure = function(t, e, r, i, s, o, a, c) {
      var l = e + String(r) + i + o.reason;
      if (this.shouldLogExposure(l)) {
        var u = {
          gate: e,
          gateValue: String(r),
          ruleID: i,
          reason: o.reason,
          time: o.time,
          debugInfo: this.debugInfo
        };
        a && (u.isManualExposure = "true"), c != null && (u.bootstrapMetadata = c);
        var v = new Le.default(ol);
        v.setUser(t), v.setMetadata(u), v.setSecondaryExposures(s), this.log(v);
      }
    }, n.prototype.logConfigExposure = function(t, e, r, i, s, o, a) {
      var c = e + r + s.reason;
      if (this.shouldLogExposure(c)) {
        var l = {
          config: e,
          ruleID: r,
          reason: s.reason,
          time: s.time,
          debugInfo: this.debugInfo
        };
        o && (l.isManualExposure = "true"), a != null && (l.bootstrapMetadata = a);
        var u = new Le.default(il);
        u.setUser(t), u.setMetadata(l), u.setSecondaryExposures(i), this.log(u);
      }
    }, n.prototype.logLayerExposure = function(t, e, r, i, s, o, a, c, l, u) {
      var v = [
        e,
        r,
        s,
        o,
        String(a),
        c.reason
      ].join("|");
      if (this.shouldLogExposure(v)) {
        var m = {
          config: e,
          ruleID: r,
          allocatedExperiment: s,
          parameterName: o,
          isExplicitParameter: String(a),
          reason: c.reason,
          time: c.time,
          debugInfo: this.debugInfo
        };
        l && (m.isManualExposure = "true"), u != null && (m.bootstrapMetadata = u);
        var p = new Le.default(sl);
        p.setUser(t), p.setMetadata(m), p.setSecondaryExposures(i), this.log(p);
      }
    }, n.prototype.logConfigDefaultValueFallback = function(t, e, r) {
      this.logGenericEvent(pl, t, e, r), this.loggedErrors.add(e), Ni.default.error(e);
    }, n.prototype.logAppError = function(t, e, r) {
      var i = e.substring(0, 128);
      this.loggedErrors.has(i) || this.loggedErrors.size > _l || (this.logGenericEvent(ll, t, i, r), this.loggedErrors.add(i));
    }, n.prototype.logDiagnostics = function(t, e) {
      var r = We.default.getMarkers(e);
      if (!(r.length <= 0)) {
        We.default.clearContext(e);
        var i = this.makeDiagnosticsEvent(t, {
          markers: r,
          context: e,
          statsigOptions: this.sdkInternal.getOptions().getLoggingCopy()
        });
        this.log(i);
      }
    }, n.prototype.logAppMetrics = function(t) {
      var e = this, r;
      if (typeof ((r = window == null ? void 0 : window.performance) === null || r === void 0 ? void 0 : r.getEntriesByType) == "function") {
        var i = window.performance.getEntriesByType("navigation");
        if (!(!i || i.length < 1)) {
          var s = i[0], o = {
            url: s.name
          };
          if (s instanceof PerformanceNavigationTiming && (this.logGenericEvent(cl, t, s.duration, o), this.logGenericEvent(ul, t, s.domInteractive - s.startTime, o)), typeof (window == null ? void 0 : window.addEventListener) == "function" && (document != null && document.body)) {
            var a = 0, c = false;
            window.addEventListener("scroll", function() {
              if ((document == null ? void 0 : document.body) != null)
                try {
                  var l = document.body.scrollHeight || 1, u = Math.min(100, Math.round((window.scrollY + window.innerHeight) / l * 100));
                  u > a && (a = u), c = true;
                } catch {
                }
            }), window.addEventListener("beforeunload", function() {
              c && e.logGenericEvent(hl, t, a, o), e.logGenericEvent(dl, t, window.performance.now(), o);
            });
          }
        }
      }
    }, n.prototype.logGenericEvent = function(t, e, r, i) {
      var s = new Le.default(t);
      return s.setUser(e), s.setValue(r), s.setMetadata(i), this.log(s), s;
    }, n.prototype.shutdown = function() {
      this.flushInterval && (clearInterval(this.flushInterval), this.flushInterval = null), this.flush(true);
    }, n.prototype.flush = function(t) {
      var e = this;
      if (t === void 0 && (t = false), this.addErrorBoundaryDiagnostics(), this.addNonExposedChecksEvent(), this.queue.length === 0) {
        t && this.saveFailedRequests();
        return;
      }
      var r = this.sdkInternal.getStatsigMetadata();
      r.sessionID == null && (r.sessionID = (0, nl.v4)());
      var i = this.queue;
      if (this.queue = [], t && !this.sdkInternal.getNetwork().supportsKeepalive() && typeof navigator < "u" && (navigator == null ? void 0 : navigator.sendBeacon) != null) {
        var s = this.sdkInternal.getNetwork().sendLogBeacon({
          events: i,
          statsigMetadata: this.sdkInternal.getStatsigMetadata()
        });
        s || (this.queue = i.concat(this.queue), this.queue.length > 0 && (this.addFailedRequest({
          events: this.queue,
          statsigMetadata: this.sdkInternal.getStatsigMetadata(),
          time: Date.now()
        }), this.queue = [])), this.saveFailedRequests();
        return;
      }
      this.sdkInternal.getNetwork().postToEndpoint(zi.StatsigEndpoint.Rgstr, {
        events: i,
        statsigMetadata: this.sdkInternal.getStatsigMetadata()
      }, {
        retryOptions: {
          retryLimit: 3,
          backoff: 1e3
        },
        useKeepalive: t,
        additionalHeaders: { "STATSIG-EVENT-COUNT": String(i.length) }
      }).then(function(o) {
        if (!o.ok)
          throw o;
      }).catch(function(o) {
        e.addFailedRequest({
          events: i,
          statsigMetadata: e.sdkInternal.getStatsigMetadata(),
          time: Date.now()
        });
      }).finally(function() {
        t && e.saveFailedRequests();
      });
    }, n.prototype.saveFailedRequests = function() {
      var t = this;
      if (this.failedLogEvents.length > 0) {
        var e = JSON.stringify(this.failedLogEvents);
        if (e.length > Yi) {
          this.logDroppedLogEventsException(this.failedLogEventCount, "Exceeds local storage size");
          return;
        }
        if (Ae.default.asyncStorage) {
          Ae.default.setItemAsync(De.STATSIG_LOCAL_STORAGE_LOGGING_REQUEST_KEY, e).catch(function(r) {
            return t.sdkInternal.getErrorBoundary().logError("saveFailedRequests", r);
          });
          return;
        }
        Sn.default.setItem(De.STATSIG_LOCAL_STORAGE_LOGGING_REQUEST_KEY, e);
      }
    }, n.prototype.sendSavedRequests = function() {
      return el(this, void 0, void 0, function() {
        var t, e, r, i, s, o, a, c, l = this;
        return rl(this, function(u) {
          switch (u.label) {
            case 0:
              return e = false, Ae.default.asyncStorage ? [4, Ae.default.getItemAsync(De.STATSIG_LOCAL_STORAGE_LOGGING_REQUEST_KEY)] : [3, 2];
            case 1:
              return t = u.sent(), [3, 3];
            case 2:
              t = Sn.default.getItem(De.STATSIG_LOCAL_STORAGE_LOGGING_REQUEST_KEY), u.label = 3;
            case 3:
              if (t == null)
                return [
                  2
                  /*return*/
                ];
              t.length > Yi && (e = true), r = [];
              try {
                for (r = JSON.parse(t), i = function(v) {
                  v != null && v.events && Array.isArray(v.events) && s.sdkInternal.getNetwork().postToEndpoint(zi.StatsigEndpoint.Rgstr, v, {
                    additionalHeaders: {
                      "STATSIG-EVENT-COUNT": String(v.events.length)
                    }
                  }).then(function(m) {
                    if (!m.ok)
                      throw Error(m.status + "");
                  }).catch(function() {
                    if (e) {
                      l.logDroppedLogEventsException(v.events.length, "Flush while shutting down");
                      return;
                    }
                    l.addFailedRequest(v);
                  });
                }, s = this, o = 0, a = r; o < a.length; o++)
                  c = a[o], i(c);
              } catch (v) {
                Ni.default.error("sendSavedRequests ", v), this.sdkInternal.getErrorBoundary().logError("sendSavedRequests", v);
              } finally {
                this.clearLocalStorageRequests();
              }
              return [
                2
                /*return*/
              ];
          }
        });
      });
    }, n.prototype.addFailedRequest = function(t) {
      var e = t.events.length;
      if (t.time < Date.now() - vl) {
        this.logDroppedLogEventsException(e, "Events too old");
        return;
      }
      if (this.failedLogEvents.length > ml) {
        this.logDroppedLogEventsException(e, "Exceed max batches to retry");
        return;
      }
      var r = t.events.length;
      if (this.failedLogEventCount + r > ro) {
        this.logDroppedLogEventsException(e, "Exceeds max failed events");
        return;
      }
      this.failedLogEvents.push(t), this.failedLogEventCount += r;
    }, n.prototype.clearLocalStorageRequests = function() {
      var t = this;
      Ae.default.asyncStorage ? Ae.default.removeItemAsync(De.STATSIG_LOCAL_STORAGE_LOGGING_REQUEST_KEY).catch(function(e) {
        return t.sdkInternal.getErrorBoundary().logError("clearLocalStorageRequests", e);
      }) : Sn.default.removeItem(De.STATSIG_LOCAL_STORAGE_LOGGING_REQUEST_KEY);
    }, n.prototype.makeDiagnosticsEvent = function(t, e) {
      var r = new Le.default(fl);
      return r.setUser(t), r.setMetadata(e), r;
    }, n.prototype.addErrorBoundaryDiagnostics = function() {
      if (We.default.getMarkerCount("api_call") !== 0) {
        var t = this.makeDiagnosticsEvent(this.sdkInternal.getCurrentUser(), {
          context: "api_call",
          markers: We.default.getMarkers("api_call")
        });
        this.queue.push(t), We.default.clearContext("api_call");
      }
    }, n.prototype.addNonExposedChecksEvent = function() {
      if (Object.keys(this.nonExposedChecks).length !== 0) {
        var t = new Le.default(gl);
        t.setMetadata({
          checks: Gn({}, this.nonExposedChecks)
        }), this.queue.push(t), this.nonExposedChecks = {};
      }
    }, n.prototype.logDroppedLogEventsException = function(t, e) {
      this.sdkInternal.getErrorBoundary().logError(al, new Error(e), {
        getExtraData: function() {
          return {
            eventCount: t
          };
        }
      });
    }, n;
  }()
);
si.default = yl;
var ai = {};
var li = {};
var on = {};
var vt = {};
var no = { exports: {} };
var El = {};
var Sl = Object.freeze(Object.defineProperty({
  __proto__: null,
  default: El
}, Symbol.toStringTag, { value: "Module" }));
var Bi = Ks(Sl);
(function(n) {
  (function() {
    var t = "input is invalid type", e = typeof window == "object", r = e ? window : {};
    r.JS_SHA256_NO_WINDOW && (e = false);
    var i = !e && typeof self == "object", s = !r.JS_SHA256_NO_NODE_JS && typeof process == "object" && process.versions && process.versions.node;
    s ? r = N : i && (r = self);
    var o = !r.JS_SHA256_NO_COMMON_JS && true && n.exports, a = !r.JS_SHA256_NO_ARRAY_BUFFER && typeof ArrayBuffer < "u", c = "0123456789abcdef".split(""), l = [-2147483648, 8388608, 32768, 128], u = [24, 16, 8, 0], v = [
      1116352408,
      1899447441,
      3049323471,
      3921009573,
      961987163,
      1508970993,
      2453635748,
      2870763221,
      3624381080,
      310598401,
      607225278,
      1426881987,
      1925078388,
      2162078206,
      2614888103,
      3248222580,
      3835390401,
      4022224774,
      264347078,
      604807628,
      770255983,
      1249150122,
      1555081692,
      1996064986,
      2554220882,
      2821834349,
      2952996808,
      3210313671,
      3336571891,
      3584528711,
      113926993,
      338241895,
      666307205,
      773529912,
      1294757372,
      1396182291,
      1695183700,
      1986661051,
      2177026350,
      2456956037,
      2730485921,
      2820302411,
      3259730800,
      3345764771,
      3516065817,
      3600352804,
      4094571909,
      275423344,
      430227734,
      506948616,
      659060556,
      883997877,
      958139571,
      1322822218,
      1537002063,
      1747873779,
      1955562222,
      2024104815,
      2227730452,
      2361852424,
      2428436474,
      2756734187,
      3204031479,
      3329325298
    ], m = ["hex", "array", "digest", "arrayBuffer"], p = [];
    (r.JS_SHA256_NO_NODE_JS || !Array.isArray) && (Array.isArray = function(h) {
      return Object.prototype.toString.call(h) === "[object Array]";
    }), a && (r.JS_SHA256_NO_ARRAY_BUFFER_IS_VIEW || !ArrayBuffer.isView) && (ArrayBuffer.isView = function(h) {
      return typeof h == "object" && h.buffer && h.buffer.constructor === ArrayBuffer;
    });
    var b = function(h, _) {
      return function(T) {
        return new E(_, true).update(T)[h]();
      };
    }, S = function(h) {
      var _ = b("hex", h);
      s && (_ = x(_, h)), _.create = function() {
        return new E(h);
      }, _.update = function(M) {
        return _.create().update(M);
      };
      for (var T = 0; T < m.length; ++T) {
        var L = m[T];
        _[L] = b(L, h);
      }
      return _;
    }, x = function(h, _) {
      var T = Bi, L = Bi.Buffer, M = _ ? "sha224" : "sha256", I;
      L.from && !r.JS_SHA256_NO_BUFFER_FROM ? I = L.from : I = function(O) {
        return new L(O);
      };
      var D = function(O) {
        if (typeof O == "string")
          return T.createHash(M).update(O, "utf8").digest("hex");
        if (O == null)
          throw new Error(t);
        return O.constructor === ArrayBuffer && (O = new Uint8Array(O)), Array.isArray(O) || ArrayBuffer.isView(O) || O.constructor === L ? T.createHash(M).update(I(O)).digest("hex") : h(O);
      };
      return D;
    }, d = function(h, _) {
      return function(T, L) {
        return new f(T, _, true).update(L)[h]();
      };
    }, g = function(h) {
      var _ = d("hex", h);
      _.create = function(M) {
        return new f(M, h);
      }, _.update = function(M, I) {
        return _.create(M).update(I);
      };
      for (var T = 0; T < m.length; ++T) {
        var L = m[T];
        _[L] = d(L, h);
      }
      return _;
    };
    function E(h, _) {
      _ ? (p[0] = p[16] = p[1] = p[2] = p[3] = p[4] = p[5] = p[6] = p[7] = p[8] = p[9] = p[10] = p[11] = p[12] = p[13] = p[14] = p[15] = 0, this.blocks = p) : this.blocks = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], h ? (this.h0 = 3238371032, this.h1 = 914150663, this.h2 = 812702999, this.h3 = 4144912697, this.h4 = 4290775857, this.h5 = 1750603025, this.h6 = 1694076839, this.h7 = 3204075428) : (this.h0 = 1779033703, this.h1 = 3144134277, this.h2 = 1013904242, this.h3 = 2773480762, this.h4 = 1359893119, this.h5 = 2600822924, this.h6 = 528734635, this.h7 = 1541459225), this.block = this.start = this.bytes = this.hBytes = 0, this.finalized = this.hashed = false, this.first = true, this.is224 = h;
    }
    E.prototype.update = function(h) {
      if (!this.finalized) {
        var _, T = typeof h;
        if (T !== "string") {
          if (T === "object") {
            if (h === null)
              throw new Error(t);
            if (a && h.constructor === ArrayBuffer)
              h = new Uint8Array(h);
            else if (!Array.isArray(h) && (!a || !ArrayBuffer.isView(h)))
              throw new Error(t);
          } else
            throw new Error(t);
          _ = true;
        }
        for (var L, M = 0, I, D = h.length, O = this.blocks; M < D; ) {
          if (this.hashed && (this.hashed = false, O[0] = this.block, this.block = O[16] = O[1] = O[2] = O[3] = O[4] = O[5] = O[6] = O[7] = O[8] = O[9] = O[10] = O[11] = O[12] = O[13] = O[14] = O[15] = 0), _)
            for (I = this.start; M < D && I < 64; ++M)
              O[I >>> 2] |= h[M] << u[I++ & 3];
          else
            for (I = this.start; M < D && I < 64; ++M)
              L = h.charCodeAt(M), L < 128 ? O[I >>> 2] |= L << u[I++ & 3] : L < 2048 ? (O[I >>> 2] |= (192 | L >>> 6) << u[I++ & 3], O[I >>> 2] |= (128 | L & 63) << u[I++ & 3]) : L < 55296 || L >= 57344 ? (O[I >>> 2] |= (224 | L >>> 12) << u[I++ & 3], O[I >>> 2] |= (128 | L >>> 6 & 63) << u[I++ & 3], O[I >>> 2] |= (128 | L & 63) << u[I++ & 3]) : (L = 65536 + ((L & 1023) << 10 | h.charCodeAt(++M) & 1023), O[I >>> 2] |= (240 | L >>> 18) << u[I++ & 3], O[I >>> 2] |= (128 | L >>> 12 & 63) << u[I++ & 3], O[I >>> 2] |= (128 | L >>> 6 & 63) << u[I++ & 3], O[I >>> 2] |= (128 | L & 63) << u[I++ & 3]);
          this.lastByteIndex = I, this.bytes += I - this.start, I >= 64 ? (this.block = O[16], this.start = I - 64, this.hash(), this.hashed = true) : this.start = I;
        }
        return this.bytes > 4294967295 && (this.hBytes += this.bytes / 4294967296 << 0, this.bytes = this.bytes % 4294967296), this;
      }
    }, E.prototype.finalize = function() {
      if (!this.finalized) {
        this.finalized = true;
        var h = this.blocks, _ = this.lastByteIndex;
        h[16] = this.block, h[_ >>> 2] |= l[_ & 3], this.block = h[16], _ >= 56 && (this.hashed || this.hash(), h[0] = this.block, h[16] = h[1] = h[2] = h[3] = h[4] = h[5] = h[6] = h[7] = h[8] = h[9] = h[10] = h[11] = h[12] = h[13] = h[14] = h[15] = 0), h[14] = this.hBytes << 3 | this.bytes >>> 29, h[15] = this.bytes << 3, this.hash();
      }
    }, E.prototype.hash = function() {
      var h = this.h0, _ = this.h1, T = this.h2, L = this.h3, M = this.h4, I = this.h5, D = this.h6, O = this.h7, F = this.blocks, U, X, $, rt, Y, B, V, q, nt, C, st;
      for (U = 16; U < 64; ++U)
        Y = F[U - 15], X = (Y >>> 7 | Y << 25) ^ (Y >>> 18 | Y << 14) ^ Y >>> 3, Y = F[U - 2], $ = (Y >>> 17 | Y << 15) ^ (Y >>> 19 | Y << 13) ^ Y >>> 10, F[U] = F[U - 16] + X + F[U - 7] + $ << 0;
      for (st = _ & T, U = 0; U < 64; U += 4)
        this.first ? (this.is224 ? (q = 300032, Y = F[0] - 1413257819, O = Y - 150054599 << 0, L = Y + 24177077 << 0) : (q = 704751109, Y = F[0] - 210244248, O = Y - 1521486534 << 0, L = Y + 143694565 << 0), this.first = false) : (X = (h >>> 2 | h << 30) ^ (h >>> 13 | h << 19) ^ (h >>> 22 | h << 10), $ = (M >>> 6 | M << 26) ^ (M >>> 11 | M << 21) ^ (M >>> 25 | M << 7), q = h & _, rt = q ^ h & T ^ st, V = M & I ^ ~M & D, Y = O + $ + V + v[U] + F[U], B = X + rt, O = L + Y << 0, L = Y + B << 0), X = (L >>> 2 | L << 30) ^ (L >>> 13 | L << 19) ^ (L >>> 22 | L << 10), $ = (O >>> 6 | O << 26) ^ (O >>> 11 | O << 21) ^ (O >>> 25 | O << 7), nt = L & h, rt = nt ^ L & _ ^ q, V = O & M ^ ~O & I, Y = D + $ + V + v[U + 1] + F[U + 1], B = X + rt, D = T + Y << 0, T = Y + B << 0, X = (T >>> 2 | T << 30) ^ (T >>> 13 | T << 19) ^ (T >>> 22 | T << 10), $ = (D >>> 6 | D << 26) ^ (D >>> 11 | D << 21) ^ (D >>> 25 | D << 7), C = T & L, rt = C ^ T & h ^ nt, V = D & O ^ ~D & M, Y = I + $ + V + v[U + 2] + F[U + 2], B = X + rt, I = _ + Y << 0, _ = Y + B << 0, X = (_ >>> 2 | _ << 30) ^ (_ >>> 13 | _ << 19) ^ (_ >>> 22 | _ << 10), $ = (I >>> 6 | I << 26) ^ (I >>> 11 | I << 21) ^ (I >>> 25 | I << 7), st = _ & T, rt = st ^ _ & L ^ C, V = I & D ^ ~I & O, Y = M + $ + V + v[U + 3] + F[U + 3], B = X + rt, M = h + Y << 0, h = Y + B << 0, this.chromeBugWorkAround = true;
      this.h0 = this.h0 + h << 0, this.h1 = this.h1 + _ << 0, this.h2 = this.h2 + T << 0, this.h3 = this.h3 + L << 0, this.h4 = this.h4 + M << 0, this.h5 = this.h5 + I << 0, this.h6 = this.h6 + D << 0, this.h7 = this.h7 + O << 0;
    }, E.prototype.hex = function() {
      this.finalize();
      var h = this.h0, _ = this.h1, T = this.h2, L = this.h3, M = this.h4, I = this.h5, D = this.h6, O = this.h7, F = c[h >>> 28 & 15] + c[h >>> 24 & 15] + c[h >>> 20 & 15] + c[h >>> 16 & 15] + c[h >>> 12 & 15] + c[h >>> 8 & 15] + c[h >>> 4 & 15] + c[h & 15] + c[_ >>> 28 & 15] + c[_ >>> 24 & 15] + c[_ >>> 20 & 15] + c[_ >>> 16 & 15] + c[_ >>> 12 & 15] + c[_ >>> 8 & 15] + c[_ >>> 4 & 15] + c[_ & 15] + c[T >>> 28 & 15] + c[T >>> 24 & 15] + c[T >>> 20 & 15] + c[T >>> 16 & 15] + c[T >>> 12 & 15] + c[T >>> 8 & 15] + c[T >>> 4 & 15] + c[T & 15] + c[L >>> 28 & 15] + c[L >>> 24 & 15] + c[L >>> 20 & 15] + c[L >>> 16 & 15] + c[L >>> 12 & 15] + c[L >>> 8 & 15] + c[L >>> 4 & 15] + c[L & 15] + c[M >>> 28 & 15] + c[M >>> 24 & 15] + c[M >>> 20 & 15] + c[M >>> 16 & 15] + c[M >>> 12 & 15] + c[M >>> 8 & 15] + c[M >>> 4 & 15] + c[M & 15] + c[I >>> 28 & 15] + c[I >>> 24 & 15] + c[I >>> 20 & 15] + c[I >>> 16 & 15] + c[I >>> 12 & 15] + c[I >>> 8 & 15] + c[I >>> 4 & 15] + c[I & 15] + c[D >>> 28 & 15] + c[D >>> 24 & 15] + c[D >>> 20 & 15] + c[D >>> 16 & 15] + c[D >>> 12 & 15] + c[D >>> 8 & 15] + c[D >>> 4 & 15] + c[D & 15];
      return this.is224 || (F += c[O >>> 28 & 15] + c[O >>> 24 & 15] + c[O >>> 20 & 15] + c[O >>> 16 & 15] + c[O >>> 12 & 15] + c[O >>> 8 & 15] + c[O >>> 4 & 15] + c[O & 15]), F;
    }, E.prototype.toString = E.prototype.hex, E.prototype.digest = function() {
      this.finalize();
      var h = this.h0, _ = this.h1, T = this.h2, L = this.h3, M = this.h4, I = this.h5, D = this.h6, O = this.h7, F = [
        h >>> 24 & 255,
        h >>> 16 & 255,
        h >>> 8 & 255,
        h & 255,
        _ >>> 24 & 255,
        _ >>> 16 & 255,
        _ >>> 8 & 255,
        _ & 255,
        T >>> 24 & 255,
        T >>> 16 & 255,
        T >>> 8 & 255,
        T & 255,
        L >>> 24 & 255,
        L >>> 16 & 255,
        L >>> 8 & 255,
        L & 255,
        M >>> 24 & 255,
        M >>> 16 & 255,
        M >>> 8 & 255,
        M & 255,
        I >>> 24 & 255,
        I >>> 16 & 255,
        I >>> 8 & 255,
        I & 255,
        D >>> 24 & 255,
        D >>> 16 & 255,
        D >>> 8 & 255,
        D & 255
      ];
      return this.is224 || F.push(O >>> 24 & 255, O >>> 16 & 255, O >>> 8 & 255, O & 255), F;
    }, E.prototype.array = E.prototype.digest, E.prototype.arrayBuffer = function() {
      this.finalize();
      var h = new ArrayBuffer(this.is224 ? 28 : 32), _ = new DataView(h);
      return _.setUint32(0, this.h0), _.setUint32(4, this.h1), _.setUint32(8, this.h2), _.setUint32(12, this.h3), _.setUint32(16, this.h4), _.setUint32(20, this.h5), _.setUint32(24, this.h6), this.is224 || _.setUint32(28, this.h7), h;
    };
    function f(h, _, T) {
      var L, M = typeof h;
      if (M === "string") {
        var I = [], D = h.length, O = 0, F;
        for (L = 0; L < D; ++L)
          F = h.charCodeAt(L), F < 128 ? I[O++] = F : F < 2048 ? (I[O++] = 192 | F >>> 6, I[O++] = 128 | F & 63) : F < 55296 || F >= 57344 ? (I[O++] = 224 | F >>> 12, I[O++] = 128 | F >>> 6 & 63, I[O++] = 128 | F & 63) : (F = 65536 + ((F & 1023) << 10 | h.charCodeAt(++L) & 1023), I[O++] = 240 | F >>> 18, I[O++] = 128 | F >>> 12 & 63, I[O++] = 128 | F >>> 6 & 63, I[O++] = 128 | F & 63);
        h = I;
      } else if (M === "object") {
        if (h === null)
          throw new Error(t);
        if (a && h.constructor === ArrayBuffer)
          h = new Uint8Array(h);
        else if (!Array.isArray(h) && (!a || !ArrayBuffer.isView(h)))
          throw new Error(t);
      } else
        throw new Error(t);
      h.length > 64 && (h = new E(_, true).update(h).array());
      var U = [], X = [];
      for (L = 0; L < 64; ++L) {
        var $ = h[L] || 0;
        U[L] = 92 ^ $, X[L] = 54 ^ $;
      }
      E.call(this, _, T), this.update(X), this.oKeyPad = U, this.inner = true, this.sharedMemory = T;
    }
    f.prototype = new E(), f.prototype.finalize = function() {
      if (E.prototype.finalize.call(this), this.inner) {
        this.inner = false;
        var h = this.array();
        E.call(this, this.is224, this.sharedMemory), this.update(this.oKeyPad), this.update(h), E.prototype.finalize.call(this);
      }
    };
    var y = S();
    y.sha256 = y, y.sha224 = S(true), y.sha256.hmac = g(), y.sha224.hmac = g(true), o ? n.exports = y : (r.sha256 = y.sha256, r.sha224 = y.sha224);
  })();
})(no);
var bl = no.exports;
var io = {};
(function(n) {
  Object.defineProperty(n, "__esModule", { value: true }), n.Base64 = void 0, n.Base64 = {
    _keyStr: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
    _encodeBinary: function(t) {
      for (var e = "", r, i, s, o, a, c, l, u = 0; u < t.length; )
        r = t.charCodeAt(u++), i = t.charCodeAt(u++), s = t.charCodeAt(u++), o = r >> 2, a = (r & 3) << 4 | i >> 4, c = (i & 15) << 2 | s >> 6, l = s & 63, isNaN(i) ? c = l = 64 : isNaN(s) && (l = 64), e = e + this._keyStr.charAt(o) + this._keyStr.charAt(a) + this._keyStr.charAt(c) + this._keyStr.charAt(l);
      return e;
    },
    encodeArrayBuffer: function(t) {
      for (var e = "", r = new Uint8Array(t), i = r.byteLength, s = 0; s < i; s++)
        e += String.fromCharCode(r[s]);
      return n.Base64._encodeBinary(e);
    }
  };
})(io);
Object.defineProperty(vt, "__esModule", { value: true });
vt.getUserCacheKey = vt.getSortedObject = vt.djb2HashForObject = vt.sha256Hash = vt.djb2Hash = vt.memoizedUserCacheKeyHash = vt.fasthash = void 0;
var wl = bl;
var xl = io;
var Gr = {};
function ci(n) {
  for (var t = 0, e = 0; e < n.length; e++) {
    var r = n.charCodeAt(e);
    t = (t << 5) - t + r, t = t & t;
  }
  return t;
}
vt.fasthash = ci;
function jr(n) {
  var t = Gr[n];
  if (t)
    return t;
  var e = String(ci(n));
  return Gr[n] = e, e;
}
vt.memoizedUserCacheKeyHash = jr;
function so(n) {
  return String(ci(n) >>> 0);
}
vt.djb2Hash = so;
function Ol(n) {
  var t = Gr[n];
  if (t)
    return t;
  var e = wl.sha256.create().update(n).arrayBuffer(), r = xl.Base64.encodeArrayBuffer(e);
  return Gr[n] = r, r;
}
vt.sha256Hash = Ol;
function Tl(n) {
  return so(JSON.stringify(ui(n)));
}
vt.djb2HashForObject = Tl;
function ui(n) {
  if (n == null)
    return null;
  var t = Object.keys(n).sort(), e = {};
  return t.forEach(function(r) {
    var i = n[r];
    i instanceof Object && (i = ui(i)), e[r] = i;
  }), e;
}
vt.getSortedObject = ui;
function Cl(n, t, e) {
  var r, i = ["userID:".concat(String((r = t == null ? void 0 : t.userID) !== null && r !== void 0 ? r : ""))], s = t == null ? void 0 : t.customIDs;
  if (s != null)
    for (var o = 0, a = Object.entries(s); o < a.length; o++) {
      var c = a[o], l = c[0], u = c[1];
      i.push("".concat(l, ":").concat(u));
    }
  var v = jr(i.join(";")), m = jr(i.join(";") + ";sdkKey:".concat(e));
  i.splice(1, 0, "stableID:".concat(n));
  var p = jr(i.join(";"));
  return {
    v1: p,
    v2: v,
    v3: m
  };
}
vt.getUserCacheKey = Cl;
var or = N && N.__assign || function() {
  return or = Object.assign || function(n) {
    for (var t, e = 1, r = arguments.length; e < r; e++) {
      t = arguments[e];
      for (var i in t) Object.prototype.hasOwnProperty.call(t, i) && (n[i] = t[i]);
    }
    return n;
  }, or.apply(this, arguments);
};
var Il = N && N.__rest || function(n, t) {
  var e = {};
  for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && t.indexOf(r) < 0 && (e[r] = n[r]);
  if (n != null && typeof Object.getOwnPropertySymbols == "function")
    for (var i = 0, r = Object.getOwnPropertySymbols(n); i < r.length; i++)
      t.indexOf(r[i]) < 0 && Object.prototype.propertyIsEnumerable.call(n, r[i]) && (e[r[i]] = n[r[i]]);
  return e;
};
Object.defineProperty(on, "__esModule", { value: true });
on.getUserHashWithoutStableID = void 0;
var Ll = vt;
function Dl(n) {
  var t = n.customIDs, e = Il(n, ["customIDs"]), r = or({}, t);
  return delete r.stableID, (0, Ll.djb2HashForObject)(or(or({}, e), { customIDs: r }));
}
on.getUserHashWithoutStableID = Dl;
var Ne = {};
(function(n) {
  Object.defineProperty(n, "__esModule", { value: true }), n.EvaluationReason = void 0, function(t) {
    t.Network = "Network", t.Bootstrap = "Bootstrap", t.InvalidBootstrap = "InvalidBootstrap", t.Cache = "Cache", t.Prefetch = "Prefetch", t.Sticky = "Sticky", t.LocalOverride = "LocalOverride", t.Unrecognized = "Unrecognized", t.Uninitialized = "Uninitialized", t.Error = "Error", t.NetworkNotModified = "NetworkNotModified", t.BootstrapStableIDMismatch = "BootstrapStableIDMismatch";
  }(n.EvaluationReason || (n.EvaluationReason = {}));
})(Ne);
var ar = N && N.__assign || function() {
  return ar = Object.assign || function(n) {
    for (var t, e = 1, r = arguments.length; e < r; e++) {
      t = arguments[e];
      for (var i in t) Object.prototype.hasOwnProperty.call(t, i) && (n[i] = t[i]);
    }
    return n;
  }, ar.apply(this, arguments);
};
Object.defineProperty(li, "__esModule", { value: true });
var Al = on;
var bn = Ne;
var Rl = vt;
var Pl = (
  /** @class */
  function() {
    function n() {
    }
    return n.getEvaluationReasonForBootstrap = function(t, e, r) {
      var i = true, s = false;
      try {
        var o = e.evaluated_keys;
        if (o && typeof o == "object") {
          var a = this.copyObject(o), c = t == null ? null : this.copyObject(t);
          i = i && n.validate(a, c) && n.validate(c, a);
          var l = o.customIDs;
          r != (l == null ? void 0 : l.stableID) && (s = true);
        }
        var u = e.user_hash;
        if (u && typeof u == "string" && t != null) {
          var v = u === (0, Al.getUserHashWithoutStableID)(t) || u === (0, Rl.djb2HashForObject)(ar(ar({}, t), { stableID: r }));
          i = i && v;
        }
        var m = e.user;
        m && typeof m == "object" && t != null && (i = i && n.validate(this.copyObject(m), this.copyObject(t)) && n.validate(this.copyObject(t), this.copyObject(m)));
      } catch {
      }
      return i ? s ? bn.EvaluationReason.BootstrapStableIDMismatch : bn.EvaluationReason.Bootstrap : bn.EvaluationReason.InvalidBootstrap;
    }, n.validate = function(t, e) {
      if (t == null)
        return e == null;
      if (e == null)
        return false;
      for (var r = 0, i = Object.entries(t); r < i.length; r++) {
        var s = i[r], o = s[0], a = s[1];
        if (o !== "stableID") {
          if (typeof a != typeof e[o])
            return false;
          if (typeof a == "string") {
            if (a !== e[o])
              return false;
          } else return typeof a == "object" ? this.validate(a, e[o]) : false;
        }
      }
      return true;
    }, n.copyObject = function(t) {
      if (t == null)
        return null;
      var e = {};
      if (t != null && t.userID && (e.userID = t == null ? void 0 : t.userID), t != null && t.customIDs) {
        var r = ar({}, t.customIDs);
        delete r.stableID, Object.keys(r).length !== 0 && (e.customIDs = r);
      }
      return e;
    }, n;
  }()
);
li.default = Pl;
var vr = {};
Object.defineProperty(vr, "__esModule", { value: true });
vr.verifySDKKeyUsed = void 0;
var Ml = Ut;
var kl = vt;
function Ul(n, t, e) {
  var r = n == null ? void 0 : n.hashed_sdk_key_used;
  return r != null && r !== (0, kl.djb2Hash)(t ?? "") ? (e.logError("verifySDKKeyUsed", new Ml.StatsigSDKKeyMismatchError("The SDK key provided does not match the one used to generate values.")), false) : true;
}
vr.verifySDKKeyUsed = Ul;
var Ct = N && N.__assign || function() {
  return Ct = Object.assign || function(n) {
    for (var t, e = 1, r = arguments.length; e < r; e++) {
      t = arguments[e];
      for (var i in t) Object.prototype.hasOwnProperty.call(t, i) && (n[i] = t[i]);
    }
    return n;
  }, Ct.apply(this, arguments);
};
var fe = N && N.__awaiter || function(n, t, e, r) {
  function i(s) {
    return s instanceof e ? s : new e(function(o) {
      o(s);
    });
  }
  return new (e || (e = Promise))(function(s, o) {
    function a(u) {
      try {
        l(r.next(u));
      } catch (v) {
        o(v);
      }
    }
    function c(u) {
      try {
        l(r.throw(u));
      } catch (v) {
        o(v);
      }
    }
    function l(u) {
      u.done ? s(u.value) : i(u.value).then(a, c);
    }
    l((r = r.apply(n, t || [])).next());
  });
};
var pe = N && N.__generator || function(n, t) {
  var e = { label: 0, sent: function() {
    if (s[0] & 1) throw s[1];
    return s[1];
  }, trys: [], ops: [] }, r, i, s, o;
  return o = { next: a(0), throw: a(1), return: a(2) }, typeof Symbol == "function" && (o[Symbol.iterator] = function() {
    return this;
  }), o;
  function a(l) {
    return function(u) {
      return c([l, u]);
    };
  }
  function c(l) {
    if (r) throw new TypeError("Generator is already executing.");
    for (; o && (o = 0, l[0] && (e = 0)), e; ) try {
      if (r = 1, i && (s = l[0] & 2 ? i.return : l[0] ? i.throw || ((s = i.return) && s.call(i), 0) : i.next) && !(s = s.call(i, l[1])).done) return s;
      switch (i = 0, s && (l = [l[0] & 2, s.value]), l[0]) {
        case 0:
        case 1:
          s = l;
          break;
        case 4:
          return e.label++, { value: l[1], done: false };
        case 5:
          e.label++, i = l[1], l = [0];
          continue;
        case 7:
          l = e.ops.pop(), e.trys.pop();
          continue;
        default:
          if (s = e.trys, !(s = s.length > 0 && s[s.length - 1]) && (l[0] === 6 || l[0] === 2)) {
            e = 0;
            continue;
          }
          if (l[0] === 3 && (!s || l[1] > s[0] && l[1] < s[3])) {
            e.label = l[1];
            break;
          }
          if (l[0] === 6 && e.label < s[1]) {
            e.label = s[1], s = l;
            break;
          }
          if (s && e.label < s[2]) {
            e.label = s[2], e.ops.push(l);
            break;
          }
          s[2] && e.ops.pop(), e.trys.pop();
          continue;
      }
      l = t.call(n, e);
    } catch (u) {
      l = [6, u], i = 0;
    } finally {
      r = s = 0;
    }
    if (l[0] & 5) throw l[1];
    return { value: l[0] ? l[1] : void 0, done: true };
  }
};
var Ge = N && N.__importDefault || function(n) {
  return n && n.__esModule ? n : { default: n };
};
Object.defineProperty(ai, "__esModule", { value: true });
var Or = Ge(fr);
var Gi = Ge(pr);
var Fl = Ge(li);
var jt = yt;
var Lt = Ne;
var Pt = vt;
var qe = Ge(xe);
var jl = vr;
var ne = Ge(Oe);
var ie = Ge(Be);
var Vl = 10;
var zl = (
  /** @class */
  function() {
    function n(t, e) {
      this.overrides = {
        gates: {},
        configs: {},
        layers: {}
      }, this.sdkInternal = t, this.userCacheKey = this.sdkInternal.getCurrentUserCacheKey(), this.values = {}, this.userValues = {
        feature_gates: {},
        dynamic_configs: {},
        sticky_experiments: {},
        layer_configs: {},
        has_updates: false,
        time: 0,
        evaluation_time: 0,
        derived_fields: {}
      }, this.stickyDeviceExperiments = {}, this.loaded = false, this.reason = Lt.EvaluationReason.Uninitialized, this.userPersistentStorageAdapter = this.sdkInternal.getOptions().getUserPersistentStorage(), this.userPersistentStorageData = { experiments: {} }, e ? this.bootstrap(e) : this.load();
    }
    return n.prototype.load = function() {
      this.loadFromLocalStorage(), this.partialLoadFromPersistentStorageAdapter();
    }, n.prototype.loadAsync = function() {
      return fe(this, void 0, void 0, function() {
        return pe(this, function(t) {
          switch (t.label) {
            case 0:
              return [4, this.loadFromAsyncStorage()];
            case 1:
              return t.sent(), this.partialLoadFromPersistentStorageAdapter(), [
                2
                /*return*/
              ];
          }
        });
      });
    }, n.prototype.updateUser = function(t) {
      this.userCacheKey = this.sdkInternal.getCurrentUserCacheKey();
      var e = this.setUserValueFromCache(t);
      return this.partialLoadFromPersistentStorageAdapter(), e;
    }, n.prototype.getInitializeResponseJson = function() {
      return JSON.stringify(this.userValues);
    }, n.prototype.loadFromAsyncStorage = function() {
      return fe(this, void 0, void 0, function() {
        var t, e;
        return pe(this, function(r) {
          switch (r.label) {
            case 0:
              return t = this.parseCachedValues, [4, ne.default.getItemAsync(jt.INTERNAL_STORE_KEY)];
            case 1:
              return e = [r.sent()], [4, ne.default.getItemAsync(jt.STICKY_DEVICE_EXPERIMENTS_KEY)];
            case 2:
              return t.apply(this, e.concat([r.sent()])), this.userCacheKey = this.sdkInternal.getCurrentUserCacheKey(), this.loaded = true, [
                2
                /*return*/
              ];
          }
        });
      });
    }, n.prototype.bootstrap = function(t) {
      var e, r, i, s, o, a, c, l = this.sdkInternal.getCurrentUserCacheKey(), u = this.sdkInternal.getCurrentUser(), v = (i = (e = this.sdkInternal.getStatsigMetadata().stableID) !== null && e !== void 0 ? e : (r = u == null ? void 0 : u.customIDs) === null || r === void 0 ? void 0 : r.stableID) !== null && i !== void 0 ? i : null, m = Fl.default.getEvaluationReasonForBootstrap(u, t, v);
      this.loaded = true;
      try {
        var p = t;
        this.userValues.feature_gates = (s = p.feature_gates) !== null && s !== void 0 ? s : {}, this.userValues.dynamic_configs = (o = p.dynamic_configs) !== null && o !== void 0 ? o : {}, this.userValues.layer_configs = (a = p.layer_configs) !== null && a !== void 0 ? a : {}, this.userValues.evaluation_time = Date.now(), this.userValues.time = (c = p.time) !== null && c !== void 0 ? c : Date.now(), this.userValues.hash_used = p.hash_used, this.values[l.v3] = this.userValues, this.reason = m;
        var b = p.sdkInfo;
        this.userValues.bootstrapMetadata = {}, b != null && (this.userValues.bootstrapMetadata.generatorSDKInfo = b), p.user != null && (this.userValues.bootstrapMetadata.user = p.user), p.time != null && (this.userValues.bootstrapMetadata.lcut = p.time), this.loadOverrides();
      } catch {
        return;
      }
    }, n.prototype.loadFromLocalStorage = function() {
      ne.default.asyncStorage || (this.parseCachedValues(ie.default.getItem(jt.INTERNAL_STORE_KEY), ie.default.getItem(jt.STICKY_DEVICE_EXPERIMENTS_KEY)), this.loaded = true);
    }, n.prototype.partialLoadFromPersistentStorageAdapter = function() {
      var t;
      if (this.userPersistentStorageAdapter) {
        var e = (t = this.userPersistentStorageAdapter.userIDType) !== null && t !== void 0 ? t : "userID", r = this.sdkInternal.getCurrentUserUnitID(e);
        if (r) {
          try {
            this.userPersistentStorageData = JSON.parse(this.userPersistentStorageAdapter.load("".concat(r, ":").concat(e)));
          } catch (i) {
            qe.default.warn("Failed to load from user persistent storage.", i);
          }
          this.userValues.sticky_experiments = this.userPersistentStorageData.experiments;
        }
      }
    }, n.prototype.saveStickyExperimentsToPersistentStorageAdapter = function() {
      var t;
      if (this.userPersistentStorageAdapter) {
        var e = (t = this.userPersistentStorageAdapter.userIDType) !== null && t !== void 0 ? t : "userID", r = this.sdkInternal.getCurrentUserUnitID(e);
        if (r) {
          var i = Ct(Ct({}, this.userPersistentStorageData), { experiments: this.userValues.sticky_experiments });
          try {
            this.userPersistentStorageAdapter.save("".concat(r, ":").concat(e), JSON.stringify(i));
          } catch (s) {
            qe.default.warn("Failed to save user experiment values to persistent storage.", s);
          }
        }
      }
    }, n.prototype.isLoaded = function() {
      return this.loaded;
    }, n.prototype.getLastUpdateTime = function(t, e) {
      var r = (0, Pt.getUserCacheKey)(e, t, this.sdkInternal.getSDKKey()), i = this.getUserValues(r), s = (0, Pt.djb2HashForObject)(Ct(Ct({}, t), { stableID: e }));
      return (i == null ? void 0 : i.user_hash) == s ? this.userValues.time : null;
    }, n.prototype.getPreviousDerivedFields = function(t, e) {
      var r = (0, Pt.getUserCacheKey)(e, t, this.sdkInternal.getSDKKey()), i = this.getUserValues(r), s = (0, Pt.djb2HashForObject)(Ct(Ct({}, t), { stableID: e }));
      if ((i == null ? void 0 : i.user_hash) == s)
        return this.userValues.derived_fields;
    }, n.prototype.getPreviousHashUsed = function(t, e) {
      var r = (0, Pt.getUserCacheKey)(e, t, this.sdkInternal.getSDKKey()), i = this.getUserValues(r);
      return i == null ? void 0 : i.hash_used;
    }, n.prototype.parseCachedValues = function(t, e) {
      try {
        this.values = t ? JSON.parse(t) : this.values, this.setUserValueFromCache();
      } catch {
        this.removeFromStorage(jt.INTERNAL_STORE_KEY);
      }
      try {
        var r = e ? JSON.parse(e) : null;
        r && (this.stickyDeviceExperiments = r);
      } catch {
        this.removeFromStorage(jt.STICKY_DEVICE_EXPERIMENTS_KEY);
      }
      this.loadOverrides();
    }, n.prototype.getUserValues = function(t) {
      var e, r;
      return (r = (e = this.values[t.v3]) !== null && e !== void 0 ? e : this.values[t.v2]) !== null && r !== void 0 ? r : this.values[t.v1];
    }, n.prototype.setUserValueFromCache = function(t) {
      var e;
      t === void 0 && (t = false);
      var r = this.getUserValues(this.userCacheKey);
      return r == null ? (this.resetUserValues(), this.reason = Lt.EvaluationReason.Uninitialized, null) : (this.userValues = r, this.reason = t ? Lt.EvaluationReason.Prefetch : Lt.EvaluationReason.Cache, (e = r.evaluation_time) !== null && e !== void 0 ? e : 0);
    }, n.prototype.removeFromStorage = function(t) {
      var e = this;
      ne.default.removeItemAsync(t).catch(function(r) {
        return e.sdkInternal.getErrorBoundary().logError("removeFromStorage", r);
      }), ie.default.removeItem(t);
    }, n.prototype.loadOverrides = function() {
      if (!this.sdkInternal.getOptions().getDisableLocalOverrides()) {
        var t = ie.default.getItem(jt.OVERRIDES_STORE_KEY);
        if (t != null)
          try {
            this.overrides = JSON.parse(t);
          } catch {
            ie.default.removeItem(jt.OVERRIDES_STORE_KEY);
          }
      }
    }, n.prototype.setEvaluationReason = function(t) {
      this.reason = t;
    }, n.prototype.getBootstrapMetadata = function() {
      var t;
      return (t = this.userValues.bootstrapMetadata) !== null && t !== void 0 ? t : null;
    }, n.prototype.save = function(t, e, r, i) {
      return fe(this, void 0, void 0, function() {
        var s, o, a, c;
        return pe(this, function(l) {
          switch (l.label) {
            case 0:
              return s = (0, Pt.getUserCacheKey)(r, t, this.sdkInternal.getSDKKey()), o = e, o.is_delta ? [2, this.saveInitDeltas(t, e, true, r, i)] : (this.mergeInitializeResponseIntoUserMap(o, this.values, s, t, function(u) {
                return u;
              }, r, i), a = this.getUserValues(s), a && s && s.v3 === this.userCacheKey.v3 && (this.userValues = a, this.reason = Lt.EvaluationReason.Network), c = this, [4, this.writeValuesToStorage(this.values)]);
            case 1:
              return c.values = l.sent(), [
                2
                /*return*/
              ];
          }
        });
      });
    }, n.prototype.saveWithoutUpdatingClientState = function(t, e, r, i) {
      return fe(this, void 0, void 0, function() {
        var s, o, a;
        return pe(this, function(c) {
          switch (c.label) {
            case 0:
              return s = (0, Pt.getUserCacheKey)(r, t, this.sdkInternal.getSDKKey()), o = e, o.is_delta ? [2, this.saveInitDeltas(t, e, false, r, i)] : (a = JSON.parse(JSON.stringify(this.values)), this.mergeInitializeResponseIntoUserMap(o, a, s, t, function(l) {
                return l;
              }, r, i), [4, this.writeValuesToStorage(a)]);
            case 1:
              return c.sent(), [
                2
                /*return*/
              ];
          }
        });
      });
    }, n.prototype.getDeltasMergeFunction = function(t) {
      var e = this;
      return function(r, i) {
        var s, o, a, c = (a = (o = (s = t[i.v3]) !== null && s !== void 0 ? s : t[i.v2]) !== null && o !== void 0 ? o : t[i.v1]) !== null && a !== void 0 ? a : e.getDefaultUserCacheValues();
        return e.mergeUserCacheValues(c, r);
      };
    }, n.prototype.saveInitDeltas = function(t, e, r, i, s) {
      var o, a, c;
      return fe(this, void 0, void 0, function() {
        var l, u, v, m, p, b, S, x, d, g, E, f, y = this;
        return pe(this, function(h) {
          switch (h.label) {
            case 0:
              return l = (0, Pt.getUserCacheKey)(i, t, this.sdkInternal.getSDKKey()), u = e, v = JSON.parse(JSON.stringify(this.values)), this.mergeInitializeResponseIntoUserMap(u, v, l, t, this.getDeltasMergeFunction(v), i, s), m = false, p = void 0, b = false, S = Object.keys((o = u.prefetched_user_values) !== null && o !== void 0 ? o : {}), S.forEach(function(_) {
                var T, L = v[_], M = (T = u.prefetched_user_values) === null || T === void 0 ? void 0 : T[_];
                if (L && M) {
                  Hi(M, L);
                  var I = M.checksum, D = (0, Pt.djb2HashForObject)({
                    feature_gates: v[_].feature_gates,
                    dynamic_configs: v[_].dynamic_configs,
                    layer_configs: v[_].layer_configs
                  });
                  I && I !== D && (m = true, p = D), x.hash_used !== u.hash_used && (b = true);
                }
              }), x = (c = (a = v[l.v3]) !== null && a !== void 0 ? a : v[l.v2]) !== null && c !== void 0 ? c : v[l.v1], Hi(u, x), d = u.checksum, g = {
                feature_gates: x.feature_gates,
                dynamic_configs: x.dynamic_configs,
                layer_configs: x.layer_configs
              }, E = (0, Pt.djb2HashForObject)(g), d && d !== E && (m = true, p = E), x.hash_used !== u.hash_used && (b = true), m || b ? u.deltas_full_response != null ? (this.refetchAndSaveValues(t, i, s, void 0, p, m, g, u.deltas_full_response).catch(function(_) {
                return y.sdkInternal.getErrorBoundary().logError("refetchAndSaveValues", _);
              }), [
                2
                /*return*/
              ]) : (this.refetchAndSaveValues(t, i, s, void 0, p, m).catch(function(_) {
                return y.sdkInternal.getErrorBoundary().logError("refetchAndSaveValues", _);
              }), [
                2
                /*return*/
              ]) : r ? (x && l.v3 === this.userCacheKey.v3 && (this.userValues = x, this.reason = Lt.EvaluationReason.Network), f = this, [4, this.writeValuesToStorage(v)]) : [3, 2];
            case 1:
              return f.values = h.sent(), [3, 4];
            case 2:
              return [4, this.writeValuesToStorage(v)];
            case 3:
              h.sent(), h.label = 4;
            case 4:
              return [
                2
                /*return*/
              ];
          }
        });
      });
    }, n.prototype.refetchAndSaveValues = function(t, e, r, i, s, o, a, c) {
      return i === void 0 && (i = this.sdkInternal.getOptions().getInitTimeoutMs()), fe(this, void 0, void 0, function() {
        var l, u, v = this;
        return pe(this, function(m) {
          return l = this.getLastUpdateTime(t, e), u = this.getPreviousDerivedFields(t, e), [2, this.sdkInternal.getNetwork().fetchValues({
            user: t,
            sinceTime: l,
            timeout: i,
            useDeltas: false,
            prefetchUsers: r,
            previousDerivedFields: u,
            hadBadDeltaChecksum: o,
            badChecksum: s,
            badMergedConfigs: a,
            badFullResponse: c
          }).then(function(p) {
            (0, jl.verifySDKKeyUsed)(p, v.sdkInternal.getSDKKey(), v.sdkInternal.getErrorBoundary()) && p != null && p.has_updates && v.saveWithoutUpdatingClientState(t, p, e, r).catch(function(b) {
              return v.sdkInternal.getErrorBoundary().logError("refetchAndSaveValues:then", b);
            });
          }).catch(function(p) {
            return v.sdkInternal.getErrorBoundary().logError("refetchAndSaveValues", p);
          })];
        });
      });
    }, n.prototype.getStableID = function() {
      return this.sdkInternal.getStableID();
    }, n.prototype.mergeInitializeResponseIntoUserMap = function(t, e, r, i, s, o, a) {
      if (t.prefetched_user_values)
        for (var c = Object.keys(t.prefetched_user_values), l = 0, u = c; l < u.length; l++) {
          var v = u[l], m = t.prefetched_user_values[v], p = s(this.convertAPIDataToCacheValues(m, v), { v1: v, v2: v, v3: v });
          if (a) {
            var b = (0, Pt.djb2HashForObject)(a[v]);
            p.user_hash = b, p.stableIDUsed = o;
          }
          e[v] = p;
        }
      if (r) {
        var S = this.convertAPIDataToCacheValues(t, r.v3), b = (0, Pt.djb2HashForObject)(Ct(Ct({}, i), { stableID: o }));
        S.user_hash = b, S.stableIDUsed = o, e[r.v3] = s(S, r);
      }
    }, n.prototype.getDefaultUserCacheValues = function() {
      return {
        feature_gates: {},
        layer_configs: {},
        dynamic_configs: {},
        sticky_experiments: {},
        time: 0,
        evaluation_time: 0,
        derived_fields: {}
      };
    }, n.prototype.mergeUserCacheValues = function(t, e) {
      return {
        feature_gates: Ct(Ct({}, t.feature_gates), e.feature_gates),
        layer_configs: Ct(Ct({}, t.layer_configs), e.layer_configs),
        dynamic_configs: Ct(Ct({}, t.dynamic_configs), e.dynamic_configs),
        sticky_experiments: t.sticky_experiments,
        time: e.time,
        evaluation_time: e.evaluation_time,
        derived_fields: e.derived_fields,
        hash_used: e.hash_used,
        user_hash: e.user_hash,
        stableIDUsed: e.stableIDUsed
      };
    }, n.prototype.writeValuesToStorage = function(t) {
      return fe(this, void 0, void 0, function() {
        var e;
        return pe(this, function(r) {
          switch (r.label) {
            case 0:
              return t[this.userCacheKey.v3] ? (delete t[this.userCacheKey.v2], delete t[this.userCacheKey.v1]) : t[this.userCacheKey.v2] && delete t[this.userCacheKey.v1], e = Object.entries(t).sort(function(i, s) {
                var o, a, c = i[1], l = s[1];
                return c == null ? 1 : l == null ? -1 : ((o = l == null ? void 0 : l.evaluation_time) !== null && o !== void 0 ? o : l == null ? void 0 : l.time) - ((a = c == null ? void 0 : c.evaluation_time) !== null && a !== void 0 ? a : c == null ? void 0 : c.time);
              }).slice(0, Vl), t = Object.fromEntries(e), ne.default.asyncStorage ? [4, ne.default.setItemAsync(jt.INTERNAL_STORE_KEY, JSON.stringify(t))] : [3, 2];
            case 1:
              return r.sent(), [3, 3];
            case 2:
              ie.default.setItem(jt.INTERNAL_STORE_KEY, JSON.stringify(t)), r.label = 3;
            case 3:
              return [2, t];
          }
        });
      });
    }, n.prototype.checkGate = function(t, e) {
      var r, i, s;
      e === void 0 && (e = false);
      var o = {
        name: t,
        value: false,
        rule_id: "",
        secondary_exposures: []
      }, a, c = this.overrides.gates[t];
      if (!e && c != null)
        o = {
          name: t,
          value: c,
          rule_id: "override",
          secondary_exposures: []
        }, a = this.getEvaluationDetails(false, Lt.EvaluationReason.LocalOverride);
      else {
        var l = (i = (r = this.userValues) === null || r === void 0 ? void 0 : r.feature_gates[t]) !== null && i !== void 0 ? i : (s = this.userValues) === null || s === void 0 ? void 0 : s.feature_gates[this.getHashedSpecName(t)];
        l && (o = l), a = this.getEvaluationDetails(l != null);
      }
      return { evaluationDetails: a, gate: o };
    }, n.prototype.getConfig = function(t, e) {
      var r, i, s;
      e === void 0 && (e = false);
      var o, a, c = this.overrides.configs[t];
      if (!e && c != null)
        a = this.getEvaluationDetails(false, Lt.EvaluationReason.LocalOverride), o = new Or.default(t, c, "override", a, [], "", this.makeOnConfigDefaultValueFallback(this.sdkInternal.getCurrentUser()));
      else {
        var l = (i = (r = this.userValues) === null || r === void 0 ? void 0 : r.dynamic_configs[t]) !== null && i !== void 0 ? i : (s = this.userValues) === null || s === void 0 ? void 0 : s.dynamic_configs[this.getHashedSpecName(t)];
        l != null ? (a = this.getEvaluationDetails(true), o = this.createDynamicConfig(t, l, a)) : (a = this.getEvaluationDetails(false), o = new Or.default(t, {}, "", a));
      }
      return o;
    }, n.prototype.getExperiment = function(t, e, r) {
      e === void 0 && (e = false), r === void 0 && (r = false);
      var i, s, o = this.overrides.configs[t];
      if (!r && o != null)
        s = this.getEvaluationDetails(false, Lt.EvaluationReason.LocalOverride), i = new Or.default(t, o, "override", s);
      else {
        var a = this.getLatestValue(t, "dynamic_configs");
        s = this.getEvaluationDetails(a != null);
        var c = this.getPossiblyStickyValue(t, a, e, false, s);
        i = this.createDynamicConfig(t, c, s);
      }
      return i;
    }, n.prototype.getLayer = function(t, e, r) {
      var i, s, o, a = this.overrides.layers[e];
      if (a != null) {
        var c = this.getEvaluationDetails(false, Lt.EvaluationReason.LocalOverride);
        return Gi.default._create(e, a ?? {}, "override", c, t);
      }
      var l = this.getLatestValue(e, "layer_configs"), u = this.getEvaluationDetails(l != null), v = this.getPossiblyStickyValue(e, l, r, true, u);
      return Gi.default._create(e, (i = v == null ? void 0 : v.value) !== null && i !== void 0 ? i : {}, (s = v == null ? void 0 : v.rule_id) !== null && s !== void 0 ? s : "", u, t, v == null ? void 0 : v.secondary_exposures, v == null ? void 0 : v.undelegated_secondary_exposures, (o = v == null ? void 0 : v.allocated_experiment_name) !== null && o !== void 0 ? o : "", v == null ? void 0 : v.explicit_parameters, v == null ? void 0 : v.group_name);
    }, n.prototype.overrideConfig = function(t, e) {
      try {
        JSON.stringify(e);
      } catch (r) {
        qe.default.warn("Failed to stringify given config override.  Dropping", r);
        return;
      }
      this.overrides.configs[t] = e, this.saveOverrides();
    }, n.prototype.overrideLayer = function(t, e) {
      try {
        JSON.stringify(e);
      } catch (r) {
        qe.default.warn("Failed to stringify given layer override.  Dropping", r);
        return;
      }
      this.overrides.layers[t] = e, this.saveOverrides();
    }, n.prototype.overrideGate = function(t, e) {
      this.overrides.gates[t] = e, this.saveOverrides();
    }, n.prototype.removeGateOverride = function(t) {
      t == null ? this.overrides.gates = {} : delete this.overrides.gates[t], this.saveOverrides();
    }, n.prototype.removeConfigOverride = function(t) {
      t == null ? this.overrides.configs = {} : delete this.overrides.configs[t], this.saveOverrides();
    }, n.prototype.removeLayerOverride = function(t) {
      t == null ? this.overrides.layers = {} : delete this.overrides.layers[t], this.saveOverrides();
    }, n.prototype.getAllOverrides = function() {
      return this.overrides;
    }, n.prototype.saveOverrides = function() {
      try {
        ie.default.setItem(jt.OVERRIDES_STORE_KEY, JSON.stringify(this.overrides));
      } catch {
        qe.default.warn("Failed to persist gate/config overrides");
      }
    }, n.prototype.getLatestValue = function(t, e) {
      var r, i, s, o, a;
      return (s = (i = (r = this.userValues) === null || r === void 0 ? void 0 : r[e]) === null || i === void 0 ? void 0 : i[t]) !== null && s !== void 0 ? s : (a = (o = this.userValues) === null || o === void 0 ? void 0 : o[e]) === null || a === void 0 ? void 0 : a[this.getHashedSpecName(t)];
    }, n.prototype.getPossiblyStickyValue = function(t, e, r, i, s) {
      var o, a = this.getHashedSpecName(t);
      if (!r)
        return this.removeStickyValue(a), e;
      var c = this.getStickyValue(a);
      if (!c)
        return this.attemptToSaveStickyValue(a, e), e;
      var l = null;
      return i ? l = this.getLatestValue((o = c == null ? void 0 : c.allocated_experiment_name) !== null && o !== void 0 ? o : "", "dynamic_configs") : l = e, (l == null ? void 0 : l.is_experiment_active) == true ? (s.reason = Lt.EvaluationReason.Sticky, c) : ((e == null ? void 0 : e.is_experiment_active) == true ? this.attemptToSaveStickyValue(a, e) : this.removeStickyValue(a), e);
    }, n.prototype.createDynamicConfig = function(t, e, r) {
      var i, s, o;
      return new Or.default(t, (i = e == null ? void 0 : e.value) !== null && i !== void 0 ? i : {}, (s = e == null ? void 0 : e.rule_id) !== null && s !== void 0 ? s : "", r, e == null ? void 0 : e.secondary_exposures, (o = e == null ? void 0 : e.allocated_experiment_name) !== null && o !== void 0 ? o : "", this.makeOnConfigDefaultValueFallback(this.sdkInternal.getCurrentUser()), e == null ? void 0 : e.group_name, e == null ? void 0 : e.id_type, e == null ? void 0 : e.is_experiment_active);
    }, n.prototype.getStickyValue = function(t) {
      var e, r;
      return (r = (e = this.userValues) === null || e === void 0 ? void 0 : e.sticky_experiments[t]) !== null && r !== void 0 ? r : this.stickyDeviceExperiments[t];
    }, n.prototype.attemptToSaveStickyValue = function(t, e) {
      var r;
      !e || !e.is_user_in_experiment || !e.is_experiment_active || (e.is_device_based === true ? this.stickyDeviceExperiments[t] = e : !((r = this.userValues) === null || r === void 0) && r.sticky_experiments && (this.userValues.sticky_experiments[t] = e), this.saveStickyValuesToStorage());
    }, n.prototype.removeStickyValue = function(t) {
      var e, r, i, s;
      Object.keys((r = (e = this.userValues) === null || e === void 0 ? void 0 : e.sticky_experiments) !== null && r !== void 0 ? r : {}).length === 0 && Object.keys((i = this.stickyDeviceExperiments) !== null && i !== void 0 ? i : {}).length === 0 || ((s = this.userValues) === null || s === void 0 || delete s.sticky_experiments[t], delete this.stickyDeviceExperiments[t], this.saveStickyValuesToStorage());
    }, n.prototype.saveStickyValuesToStorage = function() {
      this.userPersistentStorageAdapter ? this.saveStickyExperimentsToPersistentStorageAdapter() : (this.values[this.userCacheKey.v3] = this.userValues, this.setItemToStorage(jt.INTERNAL_STORE_KEY, JSON.stringify(this.values)), this.setItemToStorage(jt.STICKY_DEVICE_EXPERIMENTS_KEY, JSON.stringify(this.stickyDeviceExperiments)));
    }, n.prototype.getGlobalEvaluationDetails = function() {
      var t, e;
      return {
        reason: (t = this.reason) !== null && t !== void 0 ? t : Lt.EvaluationReason.Uninitialized,
        time: (e = this.userValues.evaluation_time) !== null && e !== void 0 ? e : 0
      };
    }, n.prototype.getEvaluationDetails = function(t, e) {
      var r;
      return t ? {
        reason: this.reason,
        time: (r = this.userValues.evaluation_time) !== null && r !== void 0 ? r : Date.now()
      } : {
        reason: e ?? (this.reason == Lt.EvaluationReason.Uninitialized ? Lt.EvaluationReason.Uninitialized : Lt.EvaluationReason.Unrecognized),
        time: Date.now()
      };
    }, n.prototype.resetUserValues = function() {
      this.userValues = {
        feature_gates: {},
        dynamic_configs: {},
        sticky_experiments: {},
        layer_configs: {},
        time: 0,
        evaluation_time: 0,
        derived_fields: {}
      };
    }, n.prototype.getHashedSpecName = function(t) {
      switch (this.userValues.hash_used) {
        case "djb2":
          return (0, Pt.djb2Hash)(t);
        case "none":
          return t;
        default:
          return (0, Pt.sha256Hash)(t);
      }
    }, n.prototype.convertAPIDataToCacheValues = function(t, e) {
      var r, i;
      return {
        feature_gates: t.feature_gates,
        layer_configs: t.layer_configs,
        dynamic_configs: t.dynamic_configs,
        sticky_experiments: (i = (r = this.values[e]) === null || r === void 0 ? void 0 : r.sticky_experiments) !== null && i !== void 0 ? i : {},
        time: t.time == null || isNaN(t.time) ? 0 : t.time,
        evaluation_time: Date.now(),
        hash_used: t.hash_used,
        derived_fields: t.derived_fields
      };
    }, n.prototype.setItemToStorage = function(t, e) {
      var r = this;
      ne.default.asyncStorage ? ne.default.setItemAsync(t, e).catch(function(i) {
        r.sdkInternal.getErrorBoundary().logError("setItemToStorage", i);
      }) : ie.default.setItem(t, e);
    }, n.prototype.makeOnConfigDefaultValueFallback = function(t) {
      var e = this;
      return function(r, i, s, o) {
        e.isLoaded() && e.sdkInternal.getLogger().logConfigDefaultValueFallback(t, "Parameter ".concat(i, " is a value of type ").concat(o, `.
          Returning requested defaultValue type `).concat(s), {
          name: r.getName(),
          ruleID: r.getRuleID(),
          parameter: i,
          defaultValueType: s,
          valueType: o
        });
      };
    }, n;
  }()
);
ai.default = zl;
function Hi(n, t) {
  var e, r, i;
  ((e = n.deleted_configs) !== null && e !== void 0 ? e : []).forEach(function(s) {
    delete t.dynamic_configs[s];
  }), ((r = n.deleted_gates) !== null && r !== void 0 ? r : []).forEach(function(s) {
    delete t.feature_gates[s];
  }), ((i = n.deleted_layers) !== null && i !== void 0 ? i : []).forEach(function(s) {
    delete t.layer_configs[s];
  });
}
var Hr = N && N.__assign || function() {
  return Hr = Object.assign || function(n) {
    for (var t, e = 1, r = arguments.length; e < r; e++) {
      t = arguments[e];
      for (var i in t) Object.prototype.hasOwnProperty.call(t, i) && (n[i] = t[i]);
    }
    return n;
  }, Hr.apply(this, arguments);
};
var ge = N && N.__awaiter || function(n, t, e, r) {
  function i(s) {
    return s instanceof e ? s : new e(function(o) {
      o(s);
    });
  }
  return new (e || (e = Promise))(function(s, o) {
    function a(u) {
      try {
        l(r.next(u));
      } catch (v) {
        o(v);
      }
    }
    function c(u) {
      try {
        l(r.throw(u));
      } catch (v) {
        o(v);
      }
    }
    function l(u) {
      u.done ? s(u.value) : i(u.value).then(a, c);
    }
    l((r = r.apply(n, t || [])).next());
  });
};
var ve = N && N.__generator || function(n, t) {
  var e = { label: 0, sent: function() {
    if (s[0] & 1) throw s[1];
    return s[1];
  }, trys: [], ops: [] }, r, i, s, o;
  return o = { next: a(0), throw: a(1), return: a(2) }, typeof Symbol == "function" && (o[Symbol.iterator] = function() {
    return this;
  }), o;
  function a(l) {
    return function(u) {
      return c([l, u]);
    };
  }
  function c(l) {
    if (r) throw new TypeError("Generator is already executing.");
    for (; o && (o = 0, l[0] && (e = 0)), e; ) try {
      if (r = 1, i && (s = l[0] & 2 ? i.return : l[0] ? i.throw || ((s = i.return) && s.call(i), 0) : i.next) && !(s = s.call(i, l[1])).done) return s;
      switch (i = 0, s && (l = [l[0] & 2, s.value]), l[0]) {
        case 0:
        case 1:
          s = l;
          break;
        case 4:
          return e.label++, { value: l[1], done: false };
        case 5:
          e.label++, i = l[1], l = [0];
          continue;
        case 7:
          l = e.ops.pop(), e.trys.pop();
          continue;
        default:
          if (s = e.trys, !(s = s.length > 0 && s[s.length - 1]) && (l[0] === 6 || l[0] === 2)) {
            e = 0;
            continue;
          }
          if (l[0] === 3 && (!s || l[1] > s[0] && l[1] < s[3])) {
            e.label = l[1];
            break;
          }
          if (l[0] === 6 && e.label < s[1]) {
            e.label = s[1], s = l;
            break;
          }
          if (s && e.label < s[2]) {
            e.label = s[2], e.ops.push(l);
            break;
          }
          s[2] && e.ops.pop(), e.trys.pop();
          continue;
      }
      l = t.call(n, e);
    } catch (u) {
      l = [6, u], i = 0;
    } finally {
      r = s = 0;
    }
    if (l[0] & 5) throw l[1];
    return { value: l[0] ? l[1] : void 0, done: true };
  }
};
var Ft = N && N.__importDefault || function(n) {
  return n && n.__esModule ? n : { default: n };
};
Object.defineProperty(Yr, "__esModule", { value: true });
var Nl = Ft(fr);
var Yl = Ft(Zs);
var Wt = Ut;
var Tr = Ft(en);
var Ki = Ft(pr);
var Bl = Ft(rn);
var Gl = Ft(ii);
var Hl = Ft(si);
var Kl = Ft(oi);
var Xl = Ft(ri);
var Zl = Ft(ai);
var ee = Ft(ce);
var Re = Ne;
var Xi = vt;
var $t = Ft(xe);
var Zi = vr;
var wn = Ft(Oe);
var Wi = Ft(Be);
var Qe = be;
var re = 64;
var xn = 2048;
var Wl = (
  /** @class */
  function() {
    function n(t, e, r) {
      var i = this;
      if (this.appState = null, this.currentAppState = null, this.appStateChangeSubscription = null, this.onCacheLoadedForReact = null, this.initCalled = false, this.pendingInitPromise = null, this.optionalLoggingSetup = false, this.prefetchedUsersByCacheKey = {}, this.logLayerParameterExposureForLayer = function(o, a, c) {
        c === void 0 && (c = false);
        var l = "", u = o._getUndelegatedSecondaryExposures(), v = o._getExplicitParameters().includes(a);
        v && (l = o._getAllocatedExperimentName(), u = o._getSecondaryExposures()), i.logger.logLayerExposure(i.getCurrentUser(), o.getName(), o.getRuleID(), u, l, a, v, o._getEvaluationDetails(), c, i.store.getBootstrapMetadata());
      }, (r == null ? void 0 : r.localMode) !== true && (typeof t != "string" || !t.startsWith("client-")))
        throw new Wt.StatsigInvalidArgumentError("Invalid key provided.  You must use a Client SDK Key from the Statsig console to initialize the sdk");
      if (this.startTime = (0, Qe.now)(), this.options = new Xl.default(r), this.logger = new Hl.default(this), ee.default.initialize({
        options: this.options
      }), this.errorBoundary = new Yl.default(t, this.options), this.ready = false, this.sdkKey = t, $t.default.setLogger(this.options.getOutputLogger()), $t.default.setLogLevel(this.options.getLogLevel()), Wi.default.disabled = this.options.getDisableLocalStorage(), this.identity = new Gl.default(this.normalizeUser(e ?? null), this.options.getOverrideStableID(), n.reactNativeUUID), this.errorBoundary.setStatsigMetadata(this.getStatsigMetadata()), this.network = new Kl.default(this), this.store = new Zl.default(this, this.options.getInitializeValues()), this.options.getInitializeValues() != null) {
        var s = this.options.getInitCompletionCallback();
        this.ready = true, this.initCalled = true, setTimeout(function() {
          return i.delayedSetup();
        }, 20), this.handleOptionalLogging(), s && s((0, Qe.now)() - this.startTime, true, null);
      }
    }
    return n.prototype.getErrorBoundary = function() {
      return this.errorBoundary;
    }, n.prototype.getNetwork = function() {
      return this.network;
    }, n.prototype.getStore = function() {
      return this.store;
    }, n.prototype.getLogger = function() {
      return this.logger;
    }, n.prototype.getOptions = function() {
      return this.options;
    }, n.prototype.getSDKKey = function() {
      var t = this;
      return this.errorBoundary.capture("getSDKKey", function() {
        var e;
        return (e = t.sdkKey) !== null && e !== void 0 ? e : "";
      }, function() {
        return "";
      });
    }, n.prototype.getCurrentUser = function() {
      var t = this;
      return this.errorBoundary.capture("getCurrentUser", function() {
        return t.identity.getUser();
      }, function() {
        return null;
      });
    }, n.prototype.getCurrentUserCacheKey = function() {
      var t = this;
      return this.errorBoundary.capture("getCurrentUserCacheKey", function() {
        return (0, Xi.getUserCacheKey)(t.getStableID(), t.getCurrentUser(), t.getSDKKey());
      }, function() {
        return { v1: "", v2: "", v3: "" };
      });
    }, n.prototype.getCurrentUserUnitID = function(t) {
      var e = this;
      return this.errorBoundary.capture("getCurrentUserUnitID", function() {
        return e.getUnitID(e.getCurrentUser(), t);
      }, function() {
        return "";
      });
    }, n.prototype.getCurrentUserID = function() {
      var t = this;
      return this.errorBoundary.capture("getCurrentUserID", function() {
        return t.getUnitID(t.getCurrentUser(), "userid");
      }, function() {
        return "";
      });
    }, n.prototype.getUnitID = function(t, e) {
      var r, i, s;
      return t ? e.toLowerCase() === "userid" ? (i = (r = t.userID) === null || r === void 0 ? void 0 : r.toString()) !== null && i !== void 0 ? i : null : t.customIDs ? (s = t.customIDs[e]) !== null && s !== void 0 ? s : t.customIDs[e.toLowerCase()] : null : null;
    }, n.prototype.getStatsigMetadata = function() {
      var t = this;
      return this.errorBoundary.capture("getStatsigMetadata", function() {
        return t.identity.getStatsigMetadata();
      }, function() {
        return {};
      });
    }, n.prototype.getSDKType = function() {
      var t = this;
      return this.errorBoundary.capture("getSDKType", function() {
        return t.identity.getSDKType();
      }, function() {
        return "";
      });
    }, n.prototype.getSDKVersion = function() {
      var t = this;
      return this.errorBoundary.capture("getSDKVersion", function() {
        return t.identity.getSDKVersion();
      }, function() {
        return "";
      });
    }, n.prototype.delayedSetup = function() {
      var t = this;
      this.errorBoundary.swallow("delayedSetup", function() {
        t.options.getInitializeValues() != null && t.fireAndForgetPrefechUsers(), t.identity.saveStableID(), t.logger.sendSavedRequests().catch(function(e) {
          return t.errorBoundary.logError("sendSavedRequests:delayedSetup", e);
        });
      });
    }, n.prototype.setInitializeValues = function(t) {
      var e = this;
      this.errorBoundary.capture("setInitializeValues", function() {
        e.store.bootstrap(t);
        var r = null;
        e.ready || (e.ready = true, e.initCalled = true, r = e.options.getInitCompletionCallback()), e.handleOptionalLogging(), e.logger.sendSavedRequests().catch(function(i) {
          return e.errorBoundary.logError("sendSavedRequests:setInitializeValues", i);
        }), r && r((0, Qe.now)() - e.startTime, true, null);
      }, function() {
        e.ready = true, e.initCalled = true;
        var r = e.options.getInitCompletionCallback();
        r && r((0, Qe.now)() - e.startTime, false, "Caught an exception during setInitializeValues");
      });
    }, n.prototype.initializeAsync = function() {
      return ge(this, void 0, void 0, function() {
        var t = this;
        return ve(this, function(e) {
          return [2, this.errorBoundary.capture("initializeAsync", function() {
            return ge(t, void 0, void 0, function() {
              var r, i, s, o = this, a;
              return ve(this, function(c) {
                switch (c.label) {
                  case 0:
                    return this.pendingInitPromise != null ? [2, this.pendingInitPromise] : this.ready ? [2, Promise.resolve()] : (ee.default.mark.overall.start({}), this.initCalled = true, wn.default.asyncStorage ? [4, this.identity.initAsync()] : [3, 3]);
                  case 1:
                    return c.sent(), [4, this.store.loadAsync()];
                  case 2:
                    c.sent(), c.label = 3;
                  case 3:
                    return (a = this.onCacheLoadedForReact) === null || a === void 0 || a.call(this), this.appState != null && (r = this.appState, r.addEventListener && typeof r.addEventListener == "function" && (this.currentAppState = r.currentState, i = r.addEventListener("change", this.handleAppStateChange.bind(this)), this.appStateChangeSubscription = i)), this.options.getLocalModeEnabled() ? [2, Promise.resolve()] : (s = this.identity.getUser(), this.pendingInitPromise = this.fetchAndSaveValues({
                      user: s,
                      prefetchUsers: this.options.getPrefetchUsers(),
                      timeout: this.options.getInitTimeoutMs()
                    }).then(function() {
                      return ee.default.mark.overall.end({
                        success: true,
                        evaluationDetails: o.store.getGlobalEvaluationDetails()
                      }), { success: true, message: null };
                    }).catch(function(l) {
                      var u;
                      return ee.default.mark.overall.end({
                        success: false,
                        error: ee.default.formatError(l),
                        evaluationDetails: o.store.getGlobalEvaluationDetails()
                      }), { success: false, message: (u = l.message) !== null && u !== void 0 ? u : null };
                    }).then(function(l) {
                      var u = l.success, v = l.message, m = o.options.getInitCompletionCallback();
                      m && m((0, Qe.now)() - o.startTime, u, v);
                    }).finally(function() {
                      o.pendingInitPromise = null, o.ready = true, o.delayedSetup(), o.logger.logDiagnostics(s, "initialize");
                    }), this.handleOptionalLogging(), [2, this.pendingInitPromise]);
                }
              });
            });
          }, function() {
            return t.ready = true, t.initCalled = true, Promise.resolve();
          })];
        });
      });
    }, n.prototype.prefetchUsers = function(t) {
      return ge(this, void 0, void 0, function() {
        var e = this;
        return ve(this, function(r) {
          return [2, this.errorBoundary.capture("prefetchUsers", function() {
            return !t || t.length == 0 || e.options.getLocalModeEnabled() ? Promise.resolve() : e.fetchAndSaveValues({
              user: null,
              prefetchUsers: t,
              timeout: 0
            });
          }, function() {
            return Promise.resolve();
          })];
        });
      });
    }, n.prototype.getEvaluationDetails = function() {
      var t = this;
      return this.errorBoundary.capture("getEvaluationDetails", function() {
        return t.store.getGlobalEvaluationDetails();
      }, function() {
        return {
          time: Date.now(),
          reason: Re.EvaluationReason.Error
        };
      });
    }, n.prototype.checkGate = function(t, e) {
      var r = this;
      return e === void 0 && (e = false), this.errorBoundary.capture("checkGate", function() {
        var i, s, o, a = r.checkGateImpl(t, e);
        r.logGateExposureImpl(t, a);
        var c = r.options.getGateEvaluationCallback();
        c && c(t, a.gate.value, {
          withExposureLoggingDisabled: false
        });
        var l = r.options.getEvaluationCallback();
        if (l) {
          var u = new Tr.default(t, a.gate.value, a.gate.rule_id, a.evaluationDetails, (i = a.gate.group_name) !== null && i !== void 0 ? i : null, (s = a.gate.id_type) !== null && s !== void 0 ? s : null, (o = a.gate.secondary_exposures) !== null && o !== void 0 ? o : []);
          l({ type: "gate", gate: u });
        }
        return a.gate.value === true;
      }, function() {
        return false;
      }, { configName: t });
    }, n.prototype.getFeatureGate = function(t, e) {
      var r = this;
      return e === void 0 && (e = null), this.errorBoundary.capture("getFeatureGate", function() {
        var i, s, o, a, c, l = r.checkGateImpl(t, (i = e == null ? void 0 : e.ignoreOverrides) !== null && i !== void 0 ? i : false);
        e != null && e.disableExposureLogging ? r.logger.addNonExposedCheck(t) : r.logGateExposureImpl(t, l);
        var u = r.options.getGateEvaluationCallback();
        u && u(t, l.gate.value, {
          withExposureLoggingDisabled: (s = e == null ? void 0 : e.disableExposureLogging) !== null && s !== void 0 ? s : false
        });
        var v = new Tr.default(t, l.gate.value, l.gate.rule_id, l.evaluationDetails, (o = l.gate.group_name) !== null && o !== void 0 ? o : null, (a = l.gate.id_type) !== null && a !== void 0 ? a : null, (c = l.gate.secondary_exposures) !== null && c !== void 0 ? c : []), m = r.options.getEvaluationCallback();
        return m && m({ type: "gate", gate: v }), v;
      }, function() {
        return new Tr.default(t, false, "", {
          reason: Re.EvaluationReason.Error,
          time: Date.now()
        });
      }, { configName: t });
    }, n.prototype.checkGateWithExposureLoggingDisabled = function(t, e) {
      var r = this;
      return e === void 0 && (e = false), this.errorBoundary.capture("checkGateWithExposureLoggingDisabled", function() {
        var i, s, o;
        r.logger.addNonExposedCheck(t);
        var a = r.checkGateImpl(t, e), c = r.options.getGateEvaluationCallback();
        c && c(t, a.gate.value, {
          withExposureLoggingDisabled: true
        });
        var l = r.options.getEvaluationCallback();
        if (l) {
          var u = new Tr.default(t, a.gate.value, a.gate.rule_id, a.evaluationDetails, (i = a.gate.group_name) !== null && i !== void 0 ? i : null, (s = a.gate.id_type) !== null && s !== void 0 ? s : null, (o = a.gate.secondary_exposures) !== null && o !== void 0 ? o : []);
          l({ type: "gate", gate: u });
        }
        return a.gate.value === true;
      }, function() {
        return false;
      });
    }, n.prototype.logGateExposure = function(t) {
      var e = this;
      this.errorBoundary.swallow("logGateExposure", function() {
        e.logGateExposureImpl(t);
      });
    }, n.prototype.getConfig = function(t, e) {
      var r = this;
      return e === void 0 && (e = false), this.errorBoundary.capture("getConfig", function() {
        var i = r.getConfigImpl(t, e);
        r.logConfigExposureImpl(t, i);
        var s = r.options.getEvaluationCallback();
        return s && s({ type: "config", config: i }), i;
      }, function() {
        return r.getEmptyConfig(t);
      }, { configName: t });
    }, n.prototype.getConfigWithExposureLoggingDisabled = function(t, e) {
      var r = this;
      return e === void 0 && (e = false), this.errorBoundary.capture("getConfig", function() {
        r.logger.addNonExposedCheck(t);
        var i = r.getConfigImpl(t, e), s = r.options.getEvaluationCallback();
        return s && s({ type: "config", config: i }), i;
      }, function() {
        return r.getEmptyConfig(t);
      });
    }, n.prototype.logConfigExposure = function(t) {
      var e = this;
      this.errorBoundary.swallow("logConfigExposure", function() {
        e.logConfigExposureImpl(t);
      });
    }, n.prototype.getExperiment = function(t, e, r) {
      var i = this;
      return e === void 0 && (e = false), r === void 0 && (r = false), this.errorBoundary.capture("getExperiment", function() {
        var s = i.getExperimentImpl(t, e, r);
        i.logExperimentExposureImpl(t, e, s);
        var o = i.options.getEvaluationCallback();
        return o && o({ type: "experiment", config: s }), s;
      }, function() {
        return i.getEmptyConfig(t);
      }, { configName: t });
    }, n.prototype.getExperimentWithExposureLoggingDisabled = function(t, e, r) {
      var i = this;
      return e === void 0 && (e = false), r === void 0 && (r = false), this.errorBoundary.capture("getExperimentWithExposureLoggingDisabled", function() {
        i.logger.addNonExposedCheck(t);
        var s = i.getExperimentImpl(t, e, r), o = i.options.getEvaluationCallback();
        return o && o({ type: "experiment", config: s }), s;
      }, function() {
        return i.getEmptyConfig(t);
      });
    }, n.prototype.logExperimentExposure = function(t, e) {
      var r = this;
      this.errorBoundary.swallow("logExperimentExposure", function() {
        r.logExperimentExposureImpl(t, e);
      });
    }, n.prototype.getLayer = function(t, e) {
      var r = this;
      return e === void 0 && (e = false), this.errorBoundary.capture("getLayer", function() {
        var i = r.getLayerImpl(r.logLayerParameterExposureForLayer, t, e), s = r.options.getEvaluationCallback();
        return s && s({ type: "layer", layer: i }), i;
      }, function() {
        return Ki.default._create(t, {}, "", r.getEvalutionDetailsForError());
      }, { configName: t });
    }, n.prototype.getLayerWithExposureLoggingDisabled = function(t, e) {
      var r = this;
      return e === void 0 && (e = false), this.errorBoundary.capture("getLayerWithExposureLoggingDisabled", function() {
        r.logger.addNonExposedCheck(t);
        var i = r.getLayerImpl(null, t, e), s = r.options.getEvaluationCallback();
        return s && s({ type: "layer", layer: i }), i;
      }, function() {
        return Ki.default._create(t, {}, "", r.getEvalutionDetailsForError());
      });
    }, n.prototype.logLayerParameterExposure = function(t, e, r) {
      var i = this;
      r === void 0 && (r = false), this.errorBoundary.swallow("logLayerParameterExposure", function() {
        var s = i.getLayerImpl(null, t, r);
        i.logLayerParameterExposureForLayer(s, e, true);
      });
    }, n.prototype.logEvent = function(t, e, r) {
      var i = this;
      e === void 0 && (e = null), r === void 0 && (r = null), this.errorBoundary.swallow("logEvent", function() {
        if (!i.logger || !i.sdkKey)
          throw new Wt.StatsigUninitializedError("Must initialize() before logging events.");
        if (typeof t != "string" || t.length === 0) {
          $t.default.error("Event not logged. No valid eventName passed.");
          return;
        }
        i.shouldTrimParam(t, re) && ($t.default.info("eventName is too long, trimming to " + re + " characters."), t = t.substring(0, re)), typeof e == "string" && i.shouldTrimParam(e, re) && ($t.default.info("value is too long, trimming to " + re + "."), e = e.substring(0, re)), i.shouldTrimParam(r, xn) && ($t.default.info("metadata is too big. Dropping the metadata."), r = { error: "not logged due to size too large" });
        var s = new Bl.default(t);
        s.setValue(e), s.setMetadata(r), s.setUser(i.getCurrentUser()), i.logger.log(s);
      });
    }, n.prototype.updateUserWithValues = function(t, e) {
      var r = this, i;
      return this.errorBoundary.capture("updateUserWithValues", function() {
        var s = Date.now();
        if (!r.initializeCalled())
          throw new Wt.StatsigUninitializedError("Call initialize() first.");
        return i = function(o, a) {
          var c = r.options.getUpdateUserCompletionCallback();
          c == null || c(Date.now() - s, o, a);
        }, r.identity.updateUser(r.normalizeUser(t)), r.store.bootstrap(e), r.logger.resetDedupeKeys(), i(true, null), true;
      }, function() {
        return i == null || i(false, "Failed to update user. An unexpected error occured."), false;
      });
    }, n.prototype.updateUser = function(t) {
      return ge(this, void 0, void 0, function() {
        var e, r = this;
        return ve(this, function(i) {
          return [2, this.errorBoundary.capture("updateUser", function() {
            return ge(r, void 0, void 0, function() {
              var s, o, a, c, l, u = this, v;
              return ve(this, function(m) {
                switch (m.label) {
                  case 0:
                    if (s = Date.now(), !this.initializeCalled())
                      throw new Wt.StatsigUninitializedError("Call initialize() first.");
                    return e = function(p, b) {
                      var S = u.options.getUpdateUserCompletionCallback();
                      S == null || S(Date.now() - s, p, b);
                    }, wn.default.asyncStorage && ((v = this.identity.getStatsigMetadata().stableID) !== null && v !== void 0 ? v : "") == "" ? [4, this.identity.initAsync()] : [3, 2];
                  case 1:
                    m.sent(), m.label = 2;
                  case 2:
                    return this.identity.updateUser(this.normalizeUser(t)), o = this.getCurrentUserCacheKey(), a = !!this.prefetchedUsersByCacheKey[o.v3], c = this.store.updateUser(a), ee.default.clearContext("api_call"), this.logger.resetDedupeKeys(), c != null && (a || this.isCacheValidForFetchMode(c)) ? (e(true, null), [2, Promise.resolve(true)]) : this.pendingInitPromise == null ? [3, 4] : [4, this.pendingInitPromise];
                  case 3:
                    m.sent(), m.label = 4;
                  case 4:
                    return this.options.getLocalModeEnabled() ? (e(true, null), [2, Promise.resolve(true)]) : (l = this.identity.getUser(), this.pendingInitPromise = this.fetchAndSaveValues({
                      user: l,
                      prefetchUsers: [],
                      timeout: void 0
                    }).finally(function() {
                      u.pendingInitPromise = null;
                    }), [2, this.pendingInitPromise.then(function() {
                      return e(true, null), Promise.resolve(true);
                    }).catch(function(p) {
                      return e(false, "Failed to update user: ".concat(p.message)), Promise.resolve(false);
                    })]);
                }
              });
            });
          }, function() {
            return e == null || e(false, "Failed to update user. An unexpected error occured."), Promise.resolve(false);
          })];
        });
      });
    }, n.prototype.shutdown = function() {
      var t = this;
      this.errorBoundary.swallow("shutdown", function() {
        if (t.logger.shutdown(), t.appStateChangeSubscription != null) {
          var e = t.appStateChangeSubscription;
          typeof e.remove == "function" && e.remove();
        }
        Wi.default.cleanup();
      });
    }, n.prototype.getInitializeResponseJson = function() {
      var t = this;
      return this.errorBoundary.capture("getInitializeResponseJson", function() {
        var e;
        return {
          values: t.store.getInitializeResponseJson(),
          evaluationDetails: (e = t.getEvaluationDetails()) !== null && e !== void 0 ? e : {
            reason: Re.EvaluationReason.Uninitialized,
            time: 0
          }
        };
      }, function() {
        var e;
        return {
          values: "",
          evaluationDetails: (e = t.getEvaluationDetails()) !== null && e !== void 0 ? e : {
            reason: Re.EvaluationReason.Uninitialized,
            time: 0
          }
        };
      });
    }, n.prototype.overrideGate = function(t, e) {
      var r = this;
      this.errorBoundary.swallow("overrideGate", function() {
        r.ensureStoreLoaded(), r.store.overrideGate(t, e);
      });
    }, n.prototype.overrideConfig = function(t, e) {
      var r = this;
      this.errorBoundary.swallow("overrideConfig", function() {
        r.ensureStoreLoaded(), r.store.overrideConfig(t, e);
      });
    }, n.prototype.overrideLayer = function(t, e) {
      var r = this;
      this.errorBoundary.swallow("overrideLayer", function() {
        r.ensureStoreLoaded(), r.store.overrideLayer(t, e);
      });
    }, n.prototype.removeGateOverride = function(t) {
      var e = this;
      this.errorBoundary.swallow("removeGateOverride", function() {
        e.ensureStoreLoaded(), e.store.removeGateOverride(t);
      });
    }, n.prototype.removeConfigOverride = function(t) {
      var e = this;
      this.errorBoundary.swallow("removeConfigOverride", function() {
        e.ensureStoreLoaded(), e.store.removeConfigOverride(t);
      });
    }, n.prototype.removeLayerOverride = function(t) {
      var e = this;
      this.errorBoundary.swallow("removeLayerOverride", function() {
        e.ensureStoreLoaded(), e.store.removeLayerOverride(t);
      });
    }, n.prototype.removeOverride = function(t) {
      var e = this;
      this.errorBoundary.swallow("removeOverride", function() {
        e.ensureStoreLoaded(), e.store.removeGateOverride(t);
      });
    }, n.prototype.getOverrides = function() {
      var t = this;
      return this.errorBoundary.capture("getOverrides", function() {
        return t.ensureStoreLoaded(), t.store.getAllOverrides().gates;
      }, function() {
        return {};
      });
    }, n.prototype.getAllOverrides = function() {
      var t = this;
      return this.errorBoundary.capture("getAllOverrides", function() {
        return t.ensureStoreLoaded(), t.store.getAllOverrides();
      }, function() {
        return { gates: {}, configs: {}, layers: {} };
      });
    }, n.prototype.getStableID = function() {
      var t = this;
      return this.errorBoundary.capture("getStableID", function() {
        return t.identity.getStatsigMetadata().stableID;
      }, function() {
        return "";
      });
    }, n.prototype.initializeCalled = function() {
      return this.initCalled;
    }, n.prototype.setSDKPackageInfo = function(t) {
      t != null && (this.identity.setSDKPackageInfo(t), this.errorBoundary.setStatsigMetadata(this.getStatsigMetadata()));
    }, n.prototype.setDebugInfo = function(t) {
      var e = this;
      this.errorBoundary.capture("setDebuggingInfo", function() {
        if (!e.initializeCalled())
          throw new Wt.StatsigUninitializedError("Call initialize() first.");
        e.logger.setDebugInfo(t);
      }, function() {
      });
    }, n.setAsyncStorage = function(t) {
      t != null && (wn.default.asyncStorage = t);
    }, n.prototype.setOnCacheLoadedReactCallback = function(t) {
      this.onCacheLoadedForReact = t ?? null;
    }, n.setReactNativeUUID = function(t) {
      t != null && (n.reactNativeUUID = t);
    }, n.prototype.setAppState = function(t) {
      t != null && (this.appState = t);
    }, n.prototype.setNativeModules = function(t) {
      t != null && this.identity.setNativeModules(t);
    }, n.prototype.setPlatform = function(t) {
      t != null && this.identity.setPlatform(t);
    }, n.prototype.setRNDeviceInfo = function(t) {
      t != null && this.identity.setRNDeviceInfo(t);
    }, n.prototype.setExpoConstants = function(t) {
      t != null && this.identity.setExpoConstants(t);
    }, n.prototype.setExpoDevice = function(t) {
      t != null && this.identity.setExpoDevice(t);
    }, n.prototype.flushEvents = function() {
      this.logger.flush();
    }, n.prototype.reenableAllLogging = function() {
      this.getOptions().reenableAllLogging();
    }, n.prototype.isCacheValidForFetchMode = function(t) {
      return this.options.getFetchMode() !== "cache-or-network" ? false : t > this.startTime;
    }, n.prototype.handleOptionalLogging = function() {
      var t = this, e = this.options.getDisableErrorLogging(), r = this.options.getDisableAutoMetricsLogging();
      if (!(e && r) && !(this.optionalLoggingSetup || typeof window > "u" || !window || !window.addEventListener)) {
        var i = this.identity.getUser();
        if (e || window.addEventListener("error", function(o) {
          var a, c = o.error;
          if (c != null && typeof c == "object")
            try {
              c = JSON.stringify(c);
            } catch {
              c = "Failed to stringify Error";
            }
          t.logger.logAppError(i, (a = o.message) !== null && a !== void 0 ? a : "", {
            filename: o.filename,
            lineno: o.lineno,
            colno: o.colno,
            error_obj: c
          });
        }), !r) {
          if (typeof document > "u" || !document || typeof setTimeout > "u" || !setTimeout)
            return;
          var s = function() {
            setTimeout(function() {
              t.logger.logAppMetrics(i);
            }, 1e3);
          };
          document.readyState === "complete" ? s() : window.addEventListener("load", function() {
            return s();
          });
        }
        this.optionalLoggingSetup = true;
      }
    }, n.prototype.handleAppStateChange = function(t) {
      var e = this;
      this.currentAppState === "active" && t.match(/inactive|background/) ? this.logger.flush(true) : this.currentAppState != null && this.currentAppState.match(/inactive|background/) && t === "active" && this.logger.sendSavedRequests().catch(function(r) {
        return e.errorBoundary.logError("sendSavedRequests:handleAppStateChange", r);
      }), this.currentAppState = t;
    }, n.prototype.shouldTrimParam = function(t, e) {
      return t == null ? false : typeof t == "string" ? t.length > e : typeof t == "object" ? JSON.stringify(t).length > e : typeof t == "number" ? t.toString().length > e : false;
    }, n.prototype.normalizePrefetchUsers = function(t) {
      var e = this;
      return t == null ? [] : t.map(function(r) {
        return e.normalizeUser(r);
      });
    }, n.prototype.normalizeUser = function(t) {
      var e = {};
      try {
        e = JSON.parse(JSON.stringify(t));
      } catch {
        throw new Wt.StatsigInvalidArgumentError("User object must be convertable to JSON string.");
      }
      return e = this.trimUserObjIfNeeded(e), this.options.getEnvironment() != null && (e.statsigEnvironment = this.options.getEnvironment()), e;
    }, n.prototype.trimUserObjIfNeeded = function(t) {
      var e, r;
      return t == null ? {} : (this.shouldTrimParam((e = t.userID) !== null && e !== void 0 ? e : null, re) && ($t.default.info("User ID is too large, trimming to " + re + "characters"), t.userID = (r = t.userID) === null || r === void 0 ? void 0 : r.toString().substring(0, re)), this.shouldTrimParam(t, xn) && (t.custom = {}, this.shouldTrimParam(t, xn) ? ($t.default.info("User object is too large, only keeping the user ID."), t = { userID: t.userID }) : $t.default.info("User object is too large, dropping the custom property.")), t);
    }, n.prototype.ensureStoreLoaded = function() {
      if (!this.store.isLoaded())
        throw new Wt.StatsigUninitializedError("Call and wait for initialize() to finish first.");
    }, n.prototype.getEvalutionDetailsForError = function() {
      return {
        time: Date.now(),
        reason: Re.EvaluationReason.Error
      };
    }, n.prototype.fetchAndSaveValues = function(t) {
      var e, r, i, s;
      return ge(this, void 0, void 0, function() {
        var o, a, c, l, u, v, m, p, b = this;
        return ve(this, function(S) {
          return o = t.user, a = (e = t.prefetchUsers) !== null && e !== void 0 ? e : [], c = (r = t.timeout) !== null && r !== void 0 ? r : this.options.getInitTimeoutMs(), a.length > 5 && $t.default.info("Cannot prefetch more than 5 users."), l = this.normalizePrefetchUsers(a).slice(0, 5).reduce(function(x, d) {
            return x[(0, Xi.getUserCacheKey)(b.getStableID(), d, b.getSDKKey()).v3] = d, x;
          }, {}), u = String((s = (i = this.getStatsigMetadata()) === null || i === void 0 ? void 0 : i.stableID) !== null && s !== void 0 ? s : ""), v = null, a.length === 0 && (v = this.store.getLastUpdateTime(o, u)), m = this.store.getPreviousHashUsed(o, u), p = this.store.getPreviousDerivedFields(o, u), [2, this.network.fetchValues({
            user: o,
            sinceTime: v,
            timeout: c,
            useDeltas: v != null && m === (this.getOptions().getDisableHashing() ? "none" : "djb2"),
            prefetchUsers: a.length > 0 ? l : void 0,
            previousDerivedFields: p
          }).eventually(function(x) {
            var d;
            (0, Zi.verifySDKKeyUsed)(x, (d = b.sdkKey) !== null && d !== void 0 ? d : "", b.errorBoundary) && x != null && x.has_updates && b.store.saveWithoutUpdatingClientState(o, x, u, a.length > 0 ? l : void 0).catch(function(g) {
              return b.errorBoundary.logError("fetchAndSaveValues:eventually", g);
            });
          }).then(function(x) {
            return b.errorBoundary.swallow("fetchAndSaveValues", function() {
              return ge(b, void 0, void 0, function() {
                var d;
                return ve(this, function(g) {
                  switch (g.label) {
                    case 0:
                      return ee.default.mark.initialize.process.start({}), (0, Zi.verifySDKKeyUsed)(x, (d = this.sdkKey) !== null && d !== void 0 ? d : "", this.errorBoundary) ? x != null && x.has_updates ? [4, this.store.save(o, x, u, a.length > 0 ? l : void 0)] : [3, 2] : (ee.default.mark.initialize.process.end({ success: false }), [
                        2
                        /*return*/
                      ]);
                    case 1:
                      return g.sent(), [3, 3];
                    case 2:
                      x != null && x.is_no_content && this.store.setEvaluationReason(Re.EvaluationReason.NetworkNotModified), g.label = 3;
                    case 3:
                      return this.prefetchedUsersByCacheKey = Hr(Hr({}, this.prefetchedUsersByCacheKey), l), ee.default.mark.initialize.process.end({ success: true }), [
                        2
                        /*return*/
                      ];
                  }
                });
              });
            });
          })];
        });
      });
    }, n.prototype.checkGateImpl = function(t, e) {
      if (this.ensureStoreLoaded(), typeof t != "string" || t.length === 0)
        throw new Wt.StatsigInvalidArgumentError("Must pass a valid string as the gateName.");
      return this.store.checkGate(t, e);
    }, n.prototype.logGateExposureImpl = function(t, e) {
      var r = !e, i = e ?? this.checkGateImpl(t, false), s = i.gate;
      this.logger.logGateExposure(this.getCurrentUser(), t, s.value, s.rule_id, s.secondary_exposures, i.evaluationDetails, r, this.store.getBootstrapMetadata());
    }, n.prototype.getConfigImpl = function(t, e) {
      if (this.ensureStoreLoaded(), typeof t != "string" || t.length === 0)
        throw new Wt.StatsigInvalidArgumentError("Must pass a valid string as the configName.");
      return this.store.getConfig(t, e);
    }, n.prototype.logConfigExposureImpl = function(t, e) {
      var r = !e, i = e ?? this.getConfigImpl(t, false);
      this.logger.logConfigExposure(this.getCurrentUser(), t, i.getRuleID(), i._getSecondaryExposures(), i.getEvaluationDetails(), r, this.store.getBootstrapMetadata());
    }, n.prototype.getExperimentImpl = function(t, e, r) {
      if (this.ensureStoreLoaded(), typeof t != "string" || t.length === 0)
        throw new Wt.StatsigInvalidArgumentError("Must pass a valid string as the experimentName.");
      return this.store.getExperiment(t, e, r);
    }, n.prototype.logExperimentExposureImpl = function(t, e, r) {
      var i = !r, s = r ?? this.getExperimentImpl(t, e, false);
      this.logger.logConfigExposure(this.getCurrentUser(), t, s.getRuleID(), s._getSecondaryExposures(), s.getEvaluationDetails(), i, this.store.getBootstrapMetadata());
    }, n.prototype.getLayerImpl = function(t, e, r) {
      if (this.ensureStoreLoaded(), typeof e != "string" || e.length === 0)
        throw new Wt.StatsigInvalidArgumentError("Must pass a valid string as the layerName.");
      return this.store.getLayer(t, e, r);
    }, n.prototype.getEmptyConfig = function(t) {
      return new Nl.default(t, {}, "", this.getEvalutionDetailsForError());
    }, n.prototype.fireAndForgetPrefechUsers = function() {
      this.prefetchUsers(this.options.getPrefetchUsers()).catch(function() {
      });
    }, n;
  }()
);
Yr.default = Wl;
var hi = {};
Object.defineProperty(hi, "__esModule", { value: true });
function ql() {
  Object.entries || (Object.entries = function(n) {
    for (var t = Object.keys(n), e = t.length, r = new Array(e); e--; )
      r[e] = [t[e], n[t[e]]];
    return r;
  });
}
hi.default = ql;
var di = {};
Object.defineProperty(di, "__esModule", { value: true });
function Ql() {
  Object.fromEntries || (Object.fromEntries = function(n) {
    for (var t = {}, e = 0, r = n; e < r.length; e++) {
      var i = r[e];
      if (Object(i) !== i)
        throw new TypeError("iterable for fromEntries should yield objects");
      var s = i[0], o = i[1];
      Object.defineProperty(t, s, {
        configurable: true,
        enumerable: true,
        writable: true,
        value: o
      });
    }
    return t;
  });
}
di.default = Ql;
var fi = {};
Object.defineProperty(fi, "__esModule", { value: true });
function $l() {
  Promise.prototype.finally = Promise.prototype.finally || function(n) {
    var t = function(e) {
      return Promise.resolve(n()).then(e);
    };
    return this.then(function(e) {
      return t(function() {
        return e;
      });
    }, function(e) {
      return t(function() {
        return Promise.reject(e);
      });
    });
  };
}
fi.default = $l;
(function(n) {
  var t = N && N.__awaiter || function(g, E, f, y) {
    function h(_) {
      return _ instanceof f ? _ : new f(function(T) {
        T(_);
      });
    }
    return new (f || (f = Promise))(function(_, T) {
      function L(D) {
        try {
          I(y.next(D));
        } catch (O) {
          T(O);
        }
      }
      function M(D) {
        try {
          I(y.throw(D));
        } catch (O) {
          T(O);
        }
      }
      function I(D) {
        D.done ? _(D.value) : h(D.value).then(L, M);
      }
      I((y = y.apply(g, E || [])).next());
    });
  }, e = N && N.__generator || function(g, E) {
    var f = { label: 0, sent: function() {
      if (_[0] & 1) throw _[1];
      return _[1];
    }, trys: [], ops: [] }, y, h, _, T;
    return T = { next: L(0), throw: L(1), return: L(2) }, typeof Symbol == "function" && (T[Symbol.iterator] = function() {
      return this;
    }), T;
    function L(I) {
      return function(D) {
        return M([I, D]);
      };
    }
    function M(I) {
      if (y) throw new TypeError("Generator is already executing.");
      for (; T && (T = 0, I[0] && (f = 0)), f; ) try {
        if (y = 1, h && (_ = I[0] & 2 ? h.return : I[0] ? h.throw || ((_ = h.return) && _.call(h), 0) : h.next) && !(_ = _.call(h, I[1])).done) return _;
        switch (h = 0, _ && (I = [I[0] & 2, _.value]), I[0]) {
          case 0:
          case 1:
            _ = I;
            break;
          case 4:
            return f.label++, { value: I[1], done: false };
          case 5:
            f.label++, h = I[1], I = [0];
            continue;
          case 7:
            I = f.ops.pop(), f.trys.pop();
            continue;
          default:
            if (_ = f.trys, !(_ = _.length > 0 && _[_.length - 1]) && (I[0] === 6 || I[0] === 2)) {
              f = 0;
              continue;
            }
            if (I[0] === 3 && (!_ || I[1] > _[0] && I[1] < _[3])) {
              f.label = I[1];
              break;
            }
            if (I[0] === 6 && f.label < _[1]) {
              f.label = _[1], _ = I;
              break;
            }
            if (_ && f.label < _[2]) {
              f.label = _[2], f.ops.push(I);
              break;
            }
            _[2] && f.ops.pop(), f.trys.pop();
            continue;
        }
        I = E.call(g, f);
      } catch (D) {
        I = [6, D], h = 0;
      } finally {
        y = _ = 0;
      }
      if (I[0] & 5) throw I[1];
      return { value: I[0] ? I[1] : void 0, done: true };
    }
  }, r = N && N.__importDefault || function(g) {
    return g && g.__esModule ? g : { default: g };
  };
  Object.defineProperty(n, "__esModule", { value: true }), n.StatsigAsyncStorage = n.EvaluationReason = n.StatsigClient = n.Layer = n.DynamicConfig = n.FeatureGate = void 0;
  var i = Ut, s = r(Yr), o = r(sn), a = Ne, c = r(hi), l = r(di), u = r(fi), v = en;
  Object.defineProperty(n, "FeatureGate", { enumerable: true, get: function() {
    return r(v).default;
  } });
  var m = fr;
  Object.defineProperty(n, "DynamicConfig", { enumerable: true, get: function() {
    return r(m).default;
  } });
  var p = pr;
  Object.defineProperty(n, "Layer", { enumerable: true, get: function() {
    return r(p).default;
  } });
  var b = Yr;
  Object.defineProperty(n, "StatsigClient", { enumerable: true, get: function() {
    return r(b).default;
  } });
  var S = Ne;
  Object.defineProperty(n, "EvaluationReason", { enumerable: true, get: function() {
    return S.EvaluationReason;
  } });
  var x = Oe;
  Object.defineProperty(n, "StatsigAsyncStorage", { enumerable: true, get: function() {
    return r(x).default;
  } }), (0, c.default)(), (0, l.default)(), (0, u.default)();
  var d = (
    /** @class */
    function() {
      function g() {
      }
      return Object.defineProperty(g, "encodeIntializeCall", {
        get: function() {
          return o.default.encodeInitializeCall;
        },
        set: function(E) {
          o.default.encodeInitializeCall = E;
        },
        enumerable: false,
        configurable: true
      }), g.initialize = function(E, f, y) {
        var h;
        return t(this, void 0, void 0, function() {
          var _;
          return e(this, function(T) {
            return _ = (h = g.instance) !== null && h !== void 0 ? h : new s.default(E, f, y), g.instance || (g.instance = _), [2, _.initializeAsync()];
          });
        });
      }, g.prefetchUsers = function(E) {
        return t(this, void 0, void 0, function() {
          return e(this, function(f) {
            switch (f.label) {
              case 0:
                return [4, g.getClientX().prefetchUsers(E)];
              case 1:
                return [2, f.sent()];
            }
          });
        });
      }, g.setInitializeValues = function(E) {
        g.getClientX().setInitializeValues(E);
      }, g.checkGate = function(E, f) {
        return f === void 0 && (f = false), g.getClientX().checkGate(E, f);
      }, g.checkGateWithExposureLoggingDisabled = function(E, f) {
        return f === void 0 && (f = false), g.getClientX().checkGateWithExposureLoggingDisabled(E, f);
      }, g.getFeatureGate = function(E, f) {
        return f === void 0 && (f = null), g.getClientX().getFeatureGate(E, f);
      }, g.manuallyLogGateExposure = function(E) {
        g.getClientX().logGateExposure(E);
      }, g.getConfig = function(E, f) {
        return f === void 0 && (f = false), g.getClientX().getConfig(E, f);
      }, g.getConfigWithExposureLoggingDisabled = function(E, f) {
        return f === void 0 && (f = false), g.getClientX().getConfigWithExposureLoggingDisabled(E, f);
      }, g.manuallyLogConfigExposure = function(E) {
        g.getClientX().logConfigExposure(E);
      }, g.getExperiment = function(E, f, y) {
        return f === void 0 && (f = false), y === void 0 && (y = false), g.getClientX().getExperiment(E, f, y);
      }, g.getExperimentWithExposureLoggingDisabled = function(E, f, y) {
        return f === void 0 && (f = false), y === void 0 && (y = false), g.getClientX().getExperimentWithExposureLoggingDisabled(E, f, y);
      }, g.manuallyLogExperimentExposure = function(E, f) {
        f === void 0 && (f = false), g.getClientX().logExperimentExposure(E, f);
      }, g.getLayer = function(E, f) {
        return f === void 0 && (f = false), g.getClientX().getLayer(E, f);
      }, g.getLayerWithExposureLoggingDisabled = function(E, f) {
        return f === void 0 && (f = false), g.getClientX().getLayerWithExposureLoggingDisabled(E, f);
      }, g.manuallyLogLayerParameterExposure = function(E, f, y) {
        y === void 0 && (y = false), g.getClientX().logLayerParameterExposure(E, f, y);
      }, g.logEvent = function(E, f, y) {
        return f === void 0 && (f = null), y === void 0 && (y = null), g.getClientX().logEvent(E, f, y);
      }, g.updateUser = function(E) {
        return g.getClientX().updateUser(E);
      }, g.updateUserWithValues = function(E, f) {
        return g.getClientX().updateUserWithValues(E, f);
      }, g.shutdown = function() {
        g.getClientX().shutdown(), g.instance = null;
      }, g.overrideGate = function(E, f) {
        g.getClientX().overrideGate(E, f);
      }, g.overrideConfig = function(E, f) {
        g.getClientX().overrideConfig(E, f);
      }, g.overrideLayer = function(E, f) {
        g.getClientX().overrideLayer(E, f);
      }, g.removeGateOverride = function(E) {
        g.getClientX().removeGateOverride(E);
      }, g.removeConfigOverride = function(E) {
        g.getClientX().removeConfigOverride(E);
      }, g.removeLayerOverride = function(E) {
        g.getClientX().removeLayerOverride(E);
      }, g.getAllOverrides = function() {
        return g.getClientX().getAllOverrides();
      }, g.getStableID = function() {
        return g.getClientX().getStableID();
      }, g.getEvaluationDetails = function() {
        var E, f;
        return (f = (E = g.instance) === null || E === void 0 ? void 0 : E.getEvaluationDetails()) !== null && f !== void 0 ? f : {
          reason: a.EvaluationReason.Uninitialized,
          time: 0
        };
      }, g.getInitializeResponseJson = function() {
        return g.getClientX().getInitializeResponseJson();
      }, g.removeOverride = function(E) {
        g.getClientX().removeOverride(E);
      }, g.getOverrides = function() {
        return g.getClientX().getOverrides();
      }, g.initializeCalled = function() {
        return g.instance != null && g.instance.initializeCalled();
      }, g.flushEvents = function() {
        g.getClientX().flushEvents();
      }, g.setDebugInfo = function(E) {
        g.getClientX().setDebugInfo(E);
      }, g.reenableAllLogging = function() {
        g.getClientX().reenableAllLogging();
      }, g.getClientX = function() {
        if (!g.instance)
          throw new i.StatsigUninitializedError();
        return g.instance;
      }, g.instance = null, g;
    }()
  );
  n.default = d;
})(Xs);
var oo = Hs(Xs);
var qi = false;
async function Jl({
  environment: n = false ? "production" : "development",
  userId: t
}) {
  if (!t)
    throw new Error("invariant: missing userId");
  if (qi) {
    console.log("Statsig already initialized, skipping.");
    return;
  }
  qi = true, await oo.initialize(
    "client-RoO8UZOrk5aM4zXe3AP7vQjy66PWeumvN2PfQ2P6xt7",
    { userID: t },
    {
      environment: {
        tier: n
      },
      localMode: n === "local"
    }
  );
}
function tc(n) {
  return oo.getFeatureGate(n).value;
}
var Kr;
var Cr = import_react_dom.default;
if (false)
  Kr = Cr.createRoot, Cr.hydrateRoot;
else {
  Qi = Cr.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
  Kr = function(n, t) {
    Qi.usingClientEntryPoint = true;
    try {
      return Cr.createRoot(n, t);
    } finally {
      Qi.usingClientEntryPoint = false;
    }
  };
}
var Qi;
function Hn(n, t) {
  return Hn = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(e, r) {
    return e.__proto__ = r, e;
  }, Hn(n, t);
}
function ec(n, t) {
  n.prototype = Object.create(t.prototype), n.prototype.constructor = n, Hn(n, t);
}
var rc = function(t, e) {
  return t === void 0 && (t = []), e === void 0 && (e = []), t.length !== e.length || t.some(function(r, i) {
    return !Object.is(r, e[i]);
  });
};
var $i = {
  error: null
};
var Xr = function(n) {
  ec(t, n);
  function t() {
    for (var r, i = arguments.length, s = new Array(i), o = 0; o < i; o++)
      s[o] = arguments[o];
    return r = n.call.apply(n, [this].concat(s)) || this, r.state = $i, r.resetErrorBoundary = function() {
      for (var a, c = arguments.length, l = new Array(c), u = 0; u < c; u++)
        l[u] = arguments[u];
      r.props.onReset == null || (a = r.props).onReset.apply(a, l), r.reset();
    }, r;
  }
  t.getDerivedStateFromError = function(i) {
    return {
      error: i
    };
  };
  var e = t.prototype;
  return e.reset = function() {
    this.setState($i);
  }, e.componentDidCatch = function(i, s) {
    var o, a;
    (o = (a = this.props).onError) == null || o.call(a, i, s);
  }, e.componentDidUpdate = function(i, s) {
    var o = this.state.error, a = this.props.resetKeys;
    if (o !== null && s.error !== null && rc(i.resetKeys, a)) {
      var c, l;
      (c = (l = this.props).onResetKeysChange) == null || c.call(l, i.resetKeys, a), this.reset();
    }
  }, e.render = function() {
    var i = this.state.error, s = this.props, o = s.fallbackRender, a = s.FallbackComponent, c = s.fallback;
    if (i !== null) {
      var l = {
        error: i,
        resetErrorBoundary: this.resetErrorBoundary
      };
      if (j.isValidElement(c))
        return c;
      if (typeof o == "function")
        return o(l);
      if (a)
        return j.createElement(a, l);
      throw new Error("react-error-boundary requires either a fallback, fallbackRender, or FallbackComponent prop");
    }
    return this.props.children;
  }, t;
}(j.Component);
function we() {
  return we = Object.assign ? Object.assign.bind() : function(n) {
    for (var t = 1; t < arguments.length; t++) {
      var e = arguments[t];
      for (var r in e) ({}).hasOwnProperty.call(e, r) && (n[r] = e[r]);
    }
    return n;
  }, we.apply(null, arguments);
}
var nc = Object.defineProperty;
var ic = (n, t, e) => t in n ? nc(n, t, { enumerable: true, configurable: true, writable: true, value: e }) : n[t] = e;
var A = (n, t, e) => (ic(n, typeof t != "symbol" ? t + "" : t, e), e);
var sc = class extends Object3D {
  constructor(t, e) {
    super(), A(this, "isTransformControls", true), A(this, "visible", false), A(this, "domElement"), A(this, "raycaster", new Raycaster()), A(this, "gizmo"), A(this, "plane"), A(this, "tempVector", new Vector3()), A(this, "tempVector2", new Vector3()), A(this, "tempQuaternion", new Quaternion()), A(this, "unit", {
      X: new Vector3(1, 0, 0),
      Y: new Vector3(0, 1, 0),
      Z: new Vector3(0, 0, 1)
    }), A(this, "pointStart", new Vector3()), A(this, "pointEnd", new Vector3()), A(this, "offset", new Vector3()), A(this, "rotationAxis", new Vector3()), A(this, "startNorm", new Vector3()), A(this, "endNorm", new Vector3()), A(this, "rotationAngle", 0), A(this, "cameraPosition", new Vector3()), A(this, "cameraQuaternion", new Quaternion()), A(this, "cameraScale", new Vector3()), A(this, "parentPosition", new Vector3()), A(this, "parentQuaternion", new Quaternion()), A(this, "parentQuaternionInv", new Quaternion()), A(this, "parentScale", new Vector3()), A(this, "worldPositionStart", new Vector3()), A(this, "worldQuaternionStart", new Quaternion()), A(this, "worldScaleStart", new Vector3()), A(this, "worldPosition", new Vector3()), A(this, "worldQuaternion", new Quaternion()), A(this, "worldQuaternionInv", new Quaternion()), A(this, "worldScale", new Vector3()), A(this, "eye", new Vector3()), A(this, "positionStart", new Vector3()), A(this, "quaternionStart", new Quaternion()), A(this, "scaleStart", new Vector3()), A(this, "camera"), A(this, "object"), A(this, "enabled", true), A(this, "axis", null), A(this, "mode", "translate"), A(this, "translationSnap", null), A(this, "rotationSnap", null), A(this, "scaleSnap", null), A(this, "space", "world"), A(this, "size", 1), A(this, "dragging", false), A(this, "showX", true), A(this, "showY", true), A(this, "showZ", true), A(this, "changeEvent", { type: "change" }), A(this, "mouseDownEvent", { type: "mouseDown", mode: this.mode }), A(this, "mouseUpEvent", { type: "mouseUp", mode: this.mode }), A(this, "objectChangeEvent", { type: "objectChange" }), A(this, "intersectObjectWithRay", (i, s, o) => {
      const a = s.intersectObject(i, true);
      for (let c = 0; c < a.length; c++)
        if (a[c].object.visible || o)
          return a[c];
      return false;
    }), A(this, "attach", (i) => (this.object = i, this.visible = true, this)), A(this, "detach", () => (this.object = void 0, this.visible = false, this.axis = null, this)), A(this, "reset", () => this.enabled ? (this.dragging && this.object !== void 0 && (this.object.position.copy(this.positionStart), this.object.quaternion.copy(this.quaternionStart), this.object.scale.copy(this.scaleStart), this.dispatchEvent(this.changeEvent), this.dispatchEvent(this.objectChangeEvent), this.pointStart.copy(this.pointEnd)), this) : this), A(this, "updateMatrixWorld", () => {
      this.object !== void 0 && (this.object.updateMatrixWorld(), this.object.parent === null ? console.error("TransformControls: The attached 3D object must be a part of the scene graph.") : this.object.parent.matrixWorld.decompose(this.parentPosition, this.parentQuaternion, this.parentScale), this.object.matrixWorld.decompose(this.worldPosition, this.worldQuaternion, this.worldScale), this.parentQuaternionInv.copy(this.parentQuaternion).invert(), this.worldQuaternionInv.copy(this.worldQuaternion).invert()), this.camera.updateMatrixWorld(), this.camera.matrixWorld.decompose(this.cameraPosition, this.cameraQuaternion, this.cameraScale), this.eye.copy(this.cameraPosition).sub(this.worldPosition).normalize(), super.updateMatrixWorld();
    }), A(this, "pointerHover", (i) => {
      if (this.object === void 0 || this.dragging === true)
        return;
      this.raycaster.setFromCamera(i, this.camera);
      const s = this.intersectObjectWithRay(this.gizmo.picker[this.mode], this.raycaster);
      s ? this.axis = s.object.name : this.axis = null;
    }), A(this, "pointerDown", (i) => {
      if (!(this.object === void 0 || this.dragging === true || i.button !== 0) && this.axis !== null) {
        this.raycaster.setFromCamera(i, this.camera);
        const s = this.intersectObjectWithRay(this.plane, this.raycaster, true);
        if (s) {
          let o = this.space;
          if (this.mode === "scale" ? o = "local" : (this.axis === "E" || this.axis === "XYZE" || this.axis === "XYZ") && (o = "world"), o === "local" && this.mode === "rotate") {
            const a = this.rotationSnap;
            this.axis === "X" && a && (this.object.rotation.x = Math.round(this.object.rotation.x / a) * a), this.axis === "Y" && a && (this.object.rotation.y = Math.round(this.object.rotation.y / a) * a), this.axis === "Z" && a && (this.object.rotation.z = Math.round(this.object.rotation.z / a) * a);
          }
          this.object.updateMatrixWorld(), this.object.parent && this.object.parent.updateMatrixWorld(), this.positionStart.copy(this.object.position), this.quaternionStart.copy(this.object.quaternion), this.scaleStart.copy(this.object.scale), this.object.matrixWorld.decompose(this.worldPositionStart, this.worldQuaternionStart, this.worldScaleStart), this.pointStart.copy(s.point).sub(this.worldPositionStart);
        }
        this.dragging = true, this.mouseDownEvent.mode = this.mode, this.dispatchEvent(this.mouseDownEvent);
      }
    }), A(this, "pointerMove", (i) => {
      const s = this.axis, o = this.mode, a = this.object;
      let c = this.space;
      if (o === "scale" ? c = "local" : (s === "E" || s === "XYZE" || s === "XYZ") && (c = "world"), a === void 0 || s === null || this.dragging === false || i.button !== -1)
        return;
      this.raycaster.setFromCamera(i, this.camera);
      const l = this.intersectObjectWithRay(this.plane, this.raycaster, true);
      if (l) {
        if (this.pointEnd.copy(l.point).sub(this.worldPositionStart), o === "translate")
          this.offset.copy(this.pointEnd).sub(this.pointStart), c === "local" && s !== "XYZ" && this.offset.applyQuaternion(this.worldQuaternionInv), s.indexOf("X") === -1 && (this.offset.x = 0), s.indexOf("Y") === -1 && (this.offset.y = 0), s.indexOf("Z") === -1 && (this.offset.z = 0), c === "local" && s !== "XYZ" ? this.offset.applyQuaternion(this.quaternionStart).divide(this.parentScale) : this.offset.applyQuaternion(this.parentQuaternionInv).divide(this.parentScale), a.position.copy(this.offset).add(this.positionStart), this.translationSnap && (c === "local" && (a.position.applyQuaternion(this.tempQuaternion.copy(this.quaternionStart).invert()), s.search("X") !== -1 && (a.position.x = Math.round(a.position.x / this.translationSnap) * this.translationSnap), s.search("Y") !== -1 && (a.position.y = Math.round(a.position.y / this.translationSnap) * this.translationSnap), s.search("Z") !== -1 && (a.position.z = Math.round(a.position.z / this.translationSnap) * this.translationSnap), a.position.applyQuaternion(this.quaternionStart)), c === "world" && (a.parent && a.position.add(this.tempVector.setFromMatrixPosition(a.parent.matrixWorld)), s.search("X") !== -1 && (a.position.x = Math.round(a.position.x / this.translationSnap) * this.translationSnap), s.search("Y") !== -1 && (a.position.y = Math.round(a.position.y / this.translationSnap) * this.translationSnap), s.search("Z") !== -1 && (a.position.z = Math.round(a.position.z / this.translationSnap) * this.translationSnap), a.parent && a.position.sub(this.tempVector.setFromMatrixPosition(a.parent.matrixWorld))));
        else if (o === "scale") {
          if (s.search("XYZ") !== -1) {
            let u = this.pointEnd.length() / this.pointStart.length();
            this.pointEnd.dot(this.pointStart) < 0 && (u *= -1), this.tempVector2.set(u, u, u);
          } else
            this.tempVector.copy(this.pointStart), this.tempVector2.copy(this.pointEnd), this.tempVector.applyQuaternion(this.worldQuaternionInv), this.tempVector2.applyQuaternion(this.worldQuaternionInv), this.tempVector2.divide(this.tempVector), s.search("X") === -1 && (this.tempVector2.x = 1), s.search("Y") === -1 && (this.tempVector2.y = 1), s.search("Z") === -1 && (this.tempVector2.z = 1);
          a.scale.copy(this.scaleStart).multiply(this.tempVector2), this.scaleSnap && this.object && (s.search("X") !== -1 && (this.object.scale.x = Math.round(a.scale.x / this.scaleSnap) * this.scaleSnap || this.scaleSnap), s.search("Y") !== -1 && (a.scale.y = Math.round(a.scale.y / this.scaleSnap) * this.scaleSnap || this.scaleSnap), s.search("Z") !== -1 && (a.scale.z = Math.round(a.scale.z / this.scaleSnap) * this.scaleSnap || this.scaleSnap));
        } else if (o === "rotate") {
          this.offset.copy(this.pointEnd).sub(this.pointStart);
          const u = 20 / this.worldPosition.distanceTo(this.tempVector.setFromMatrixPosition(this.camera.matrixWorld));
          s === "E" ? (this.rotationAxis.copy(this.eye), this.rotationAngle = this.pointEnd.angleTo(this.pointStart), this.startNorm.copy(this.pointStart).normalize(), this.endNorm.copy(this.pointEnd).normalize(), this.rotationAngle *= this.endNorm.cross(this.startNorm).dot(this.eye) < 0 ? 1 : -1) : s === "XYZE" ? (this.rotationAxis.copy(this.offset).cross(this.eye).normalize(), this.rotationAngle = this.offset.dot(this.tempVector.copy(this.rotationAxis).cross(this.eye)) * u) : (s === "X" || s === "Y" || s === "Z") && (this.rotationAxis.copy(this.unit[s]), this.tempVector.copy(this.unit[s]), c === "local" && this.tempVector.applyQuaternion(this.worldQuaternion), this.rotationAngle = this.offset.dot(this.tempVector.cross(this.eye).normalize()) * u), this.rotationSnap && (this.rotationAngle = Math.round(this.rotationAngle / this.rotationSnap) * this.rotationSnap), c === "local" && s !== "E" && s !== "XYZE" ? (a.quaternion.copy(this.quaternionStart), a.quaternion.multiply(this.tempQuaternion.setFromAxisAngle(this.rotationAxis, this.rotationAngle)).normalize()) : (this.rotationAxis.applyQuaternion(this.parentQuaternionInv), a.quaternion.copy(this.tempQuaternion.setFromAxisAngle(this.rotationAxis, this.rotationAngle)), a.quaternion.multiply(this.quaternionStart).normalize());
        }
        this.dispatchEvent(this.changeEvent), this.dispatchEvent(this.objectChangeEvent);
      }
    }), A(this, "pointerUp", (i) => {
      i.button === 0 && (this.dragging && this.axis !== null && (this.mouseUpEvent.mode = this.mode, this.dispatchEvent(this.mouseUpEvent)), this.dragging = false, this.axis = null);
    }), A(this, "getPointer", (i) => {
      var s;
      if (this.domElement && ((s = this.domElement.ownerDocument) != null && s.pointerLockElement))
        return {
          x: 0,
          y: 0,
          button: i.button
        };
      {
        const o = i.changedTouches ? i.changedTouches[0] : i, a = this.domElement.getBoundingClientRect();
        return {
          x: (o.clientX - a.left) / a.width * 2 - 1,
          y: -(o.clientY - a.top) / a.height * 2 + 1,
          button: i.button
        };
      }
    }), A(this, "onPointerHover", (i) => {
      if (this.enabled)
        switch (i.pointerType) {
          case "mouse":
          case "pen":
            this.pointerHover(this.getPointer(i));
            break;
        }
    }), A(this, "onPointerDown", (i) => {
      !this.enabled || !this.domElement || (this.domElement.style.touchAction = "none", this.domElement.ownerDocument.addEventListener("pointermove", this.onPointerMove), this.pointerHover(this.getPointer(i)), this.pointerDown(this.getPointer(i)));
    }), A(this, "onPointerMove", (i) => {
      this.enabled && this.pointerMove(this.getPointer(i));
    }), A(this, "onPointerUp", (i) => {
      !this.enabled || !this.domElement || (this.domElement.style.touchAction = "", this.domElement.ownerDocument.removeEventListener("pointermove", this.onPointerMove), this.pointerUp(this.getPointer(i)));
    }), A(this, "getMode", () => this.mode), A(this, "setMode", (i) => {
      this.mode = i;
    }), A(this, "setTranslationSnap", (i) => {
      this.translationSnap = i;
    }), A(this, "setRotationSnap", (i) => {
      this.rotationSnap = i;
    }), A(this, "setScaleSnap", (i) => {
      this.scaleSnap = i;
    }), A(this, "setSize", (i) => {
      this.size = i;
    }), A(this, "setSpace", (i) => {
      this.space = i;
    }), A(this, "update", () => {
      console.warn(
        "THREE.TransformControls: update function has no more functionality and therefore has been deprecated."
      );
    }), A(this, "connect", (i) => {
      i === document && console.error(
        'THREE.OrbitControls: "document" should not be used as the target "domElement". Please use "renderer.domElement" instead.'
      ), this.domElement = i, this.domElement.addEventListener("pointerdown", this.onPointerDown), this.domElement.addEventListener("pointermove", this.onPointerHover), this.domElement.ownerDocument.addEventListener("pointerup", this.onPointerUp);
    }), A(this, "dispose", () => {
      var i, s, o, a, c, l;
      (i = this.domElement) == null || i.removeEventListener("pointerdown", this.onPointerDown), (s = this.domElement) == null || s.removeEventListener("pointermove", this.onPointerHover), (a = (o = this.domElement) == null ? void 0 : o.ownerDocument) == null || a.removeEventListener("pointermove", this.onPointerMove), (l = (c = this.domElement) == null ? void 0 : c.ownerDocument) == null || l.removeEventListener("pointerup", this.onPointerUp), this.traverse((u) => {
        const v = u;
        v.geometry && v.geometry.dispose(), v.material && v.material.dispose();
      });
    }), this.domElement = e, this.camera = t, this.gizmo = new oc(), this.add(this.gizmo), this.plane = new ac(), this.add(this.plane);
    const r = (i, s) => {
      let o = s;
      Object.defineProperty(this, i, {
        get: function() {
          return o !== void 0 ? o : s;
        },
        set: function(a) {
          o !== a && (o = a, this.plane[i] = a, this.gizmo[i] = a, this.dispatchEvent({ type: i + "-changed", value: a }), this.dispatchEvent(this.changeEvent));
        }
      }), this[i] = s, this.plane[i] = s, this.gizmo[i] = s;
    };
    r("camera", this.camera), r("object", this.object), r("enabled", this.enabled), r("axis", this.axis), r("mode", this.mode), r("translationSnap", this.translationSnap), r("rotationSnap", this.rotationSnap), r("scaleSnap", this.scaleSnap), r("space", this.space), r("size", this.size), r("dragging", this.dragging), r("showX", this.showX), r("showY", this.showY), r("showZ", this.showZ), r("worldPosition", this.worldPosition), r("worldPositionStart", this.worldPositionStart), r("worldQuaternion", this.worldQuaternion), r("worldQuaternionStart", this.worldQuaternionStart), r("cameraPosition", this.cameraPosition), r("cameraQuaternion", this.cameraQuaternion), r("pointStart", this.pointStart), r("pointEnd", this.pointEnd), r("rotationAxis", this.rotationAxis), r("rotationAngle", this.rotationAngle), r("eye", this.eye), e !== void 0 && this.connect(e);
  }
};
var oc = class extends Object3D {
  constructor() {
    super(), A(this, "isTransformControlsGizmo", true), A(this, "type", "TransformControlsGizmo"), A(this, "tempVector", new Vector3(0, 0, 0)), A(this, "tempEuler", new Euler()), A(this, "alignVector", new Vector3(0, 1, 0)), A(this, "zeroVector", new Vector3(0, 0, 0)), A(this, "lookAtMatrix", new Matrix4()), A(this, "tempQuaternion", new Quaternion()), A(this, "tempQuaternion2", new Quaternion()), A(this, "identityQuaternion", new Quaternion()), A(this, "unitX", new Vector3(1, 0, 0)), A(this, "unitY", new Vector3(0, 1, 0)), A(this, "unitZ", new Vector3(0, 0, 1)), A(this, "gizmo"), A(this, "picker"), A(this, "helper"), A(this, "rotationAxis", new Vector3()), A(this, "cameraPosition", new Vector3()), A(this, "worldPositionStart", new Vector3()), A(this, "worldQuaternionStart", new Quaternion()), A(this, "worldPosition", new Vector3()), A(this, "worldQuaternion", new Quaternion()), A(this, "eye", new Vector3()), A(this, "camera", null), A(this, "enabled", true), A(this, "axis", null), A(this, "mode", "translate"), A(this, "space", "world"), A(this, "size", 1), A(this, "dragging", false), A(this, "showX", true), A(this, "showY", true), A(this, "showZ", true), A(this, "updateMatrixWorld", () => {
      let B = this.space;
      this.mode === "scale" && (B = "local");
      const V = B === "local" ? this.worldQuaternion : this.identityQuaternion;
      this.gizmo.translate.visible = this.mode === "translate", this.gizmo.rotate.visible = this.mode === "rotate", this.gizmo.scale.visible = this.mode === "scale", this.helper.translate.visible = this.mode === "translate", this.helper.rotate.visible = this.mode === "rotate", this.helper.scale.visible = this.mode === "scale";
      let q = [];
      q = q.concat(this.picker[this.mode].children), q = q.concat(this.gizmo[this.mode].children), q = q.concat(this.helper[this.mode].children);
      for (let nt = 0; nt < q.length; nt++) {
        const C = q[nt];
        C.visible = true, C.rotation.set(0, 0, 0), C.position.copy(this.worldPosition);
        let st;
        if (this.camera.isOrthographicCamera ? st = (this.camera.top - this.camera.bottom) / this.camera.zoom : st = this.worldPosition.distanceTo(this.cameraPosition) * Math.min(1.9 * Math.tan(Math.PI * this.camera.fov / 360) / this.camera.zoom, 7), C.scale.set(1, 1, 1).multiplyScalar(st * this.size / 7), C.tag === "helper") {
          C.visible = false, C.name === "AXIS" ? (C.position.copy(this.worldPositionStart), C.visible = !!this.axis, this.axis === "X" && (this.tempQuaternion.setFromEuler(this.tempEuler.set(0, 0, 0)), C.quaternion.copy(V).multiply(this.tempQuaternion), Math.abs(this.alignVector.copy(this.unitX).applyQuaternion(V).dot(this.eye)) > 0.9 && (C.visible = false)), this.axis === "Y" && (this.tempQuaternion.setFromEuler(this.tempEuler.set(0, 0, Math.PI / 2)), C.quaternion.copy(V).multiply(this.tempQuaternion), Math.abs(this.alignVector.copy(this.unitY).applyQuaternion(V).dot(this.eye)) > 0.9 && (C.visible = false)), this.axis === "Z" && (this.tempQuaternion.setFromEuler(this.tempEuler.set(0, Math.PI / 2, 0)), C.quaternion.copy(V).multiply(this.tempQuaternion), Math.abs(this.alignVector.copy(this.unitZ).applyQuaternion(V).dot(this.eye)) > 0.9 && (C.visible = false)), this.axis === "XYZE" && (this.tempQuaternion.setFromEuler(this.tempEuler.set(0, Math.PI / 2, 0)), this.alignVector.copy(this.rotationAxis), C.quaternion.setFromRotationMatrix(
            this.lookAtMatrix.lookAt(this.zeroVector, this.alignVector, this.unitY)
          ), C.quaternion.multiply(this.tempQuaternion), C.visible = this.dragging), this.axis === "E" && (C.visible = false)) : C.name === "START" ? (C.position.copy(this.worldPositionStart), C.visible = this.dragging) : C.name === "END" ? (C.position.copy(this.worldPosition), C.visible = this.dragging) : C.name === "DELTA" ? (C.position.copy(this.worldPositionStart), C.quaternion.copy(this.worldQuaternionStart), this.tempVector.set(1e-10, 1e-10, 1e-10).add(this.worldPositionStart).sub(this.worldPosition).multiplyScalar(-1), this.tempVector.applyQuaternion(this.worldQuaternionStart.clone().invert()), C.scale.copy(this.tempVector), C.visible = this.dragging) : (C.quaternion.copy(V), this.dragging ? C.position.copy(this.worldPositionStart) : C.position.copy(this.worldPosition), this.axis && (C.visible = this.axis.search(C.name) !== -1));
          continue;
        }
        C.quaternion.copy(V), this.mode === "translate" || this.mode === "scale" ? ((C.name === "X" || C.name === "XYZX") && Math.abs(this.alignVector.copy(this.unitX).applyQuaternion(V).dot(this.eye)) > 0.99 && (C.scale.set(1e-10, 1e-10, 1e-10), C.visible = false), (C.name === "Y" || C.name === "XYZY") && Math.abs(this.alignVector.copy(this.unitY).applyQuaternion(V).dot(this.eye)) > 0.99 && (C.scale.set(1e-10, 1e-10, 1e-10), C.visible = false), (C.name === "Z" || C.name === "XYZZ") && Math.abs(this.alignVector.copy(this.unitZ).applyQuaternion(V).dot(this.eye)) > 0.99 && (C.scale.set(1e-10, 1e-10, 1e-10), C.visible = false), C.name === "XY" && Math.abs(this.alignVector.copy(this.unitZ).applyQuaternion(V).dot(this.eye)) < 0.2 && (C.scale.set(1e-10, 1e-10, 1e-10), C.visible = false), C.name === "YZ" && Math.abs(this.alignVector.copy(this.unitX).applyQuaternion(V).dot(this.eye)) < 0.2 && (C.scale.set(1e-10, 1e-10, 1e-10), C.visible = false), C.name === "XZ" && Math.abs(this.alignVector.copy(this.unitY).applyQuaternion(V).dot(this.eye)) < 0.2 && (C.scale.set(1e-10, 1e-10, 1e-10), C.visible = false), C.name.search("X") !== -1 && (this.alignVector.copy(this.unitX).applyQuaternion(V).dot(this.eye) < 0 ? C.tag === "fwd" ? C.visible = false : C.scale.x *= -1 : C.tag === "bwd" && (C.visible = false)), C.name.search("Y") !== -1 && (this.alignVector.copy(this.unitY).applyQuaternion(V).dot(this.eye) < 0 ? C.tag === "fwd" ? C.visible = false : C.scale.y *= -1 : C.tag === "bwd" && (C.visible = false)), C.name.search("Z") !== -1 && (this.alignVector.copy(this.unitZ).applyQuaternion(V).dot(this.eye) < 0 ? C.tag === "fwd" ? C.visible = false : C.scale.z *= -1 : C.tag === "bwd" && (C.visible = false))) : this.mode === "rotate" && (this.tempQuaternion2.copy(V), this.alignVector.copy(this.eye).applyQuaternion(this.tempQuaternion.copy(V).invert()), C.name.search("E") !== -1 && C.quaternion.setFromRotationMatrix(this.lookAtMatrix.lookAt(this.eye, this.zeroVector, this.unitY)), C.name === "X" && (this.tempQuaternion.setFromAxisAngle(this.unitX, Math.atan2(-this.alignVector.y, this.alignVector.z)), this.tempQuaternion.multiplyQuaternions(this.tempQuaternion2, this.tempQuaternion), C.quaternion.copy(this.tempQuaternion)), C.name === "Y" && (this.tempQuaternion.setFromAxisAngle(this.unitY, Math.atan2(this.alignVector.x, this.alignVector.z)), this.tempQuaternion.multiplyQuaternions(this.tempQuaternion2, this.tempQuaternion), C.quaternion.copy(this.tempQuaternion)), C.name === "Z" && (this.tempQuaternion.setFromAxisAngle(this.unitZ, Math.atan2(this.alignVector.y, this.alignVector.x)), this.tempQuaternion.multiplyQuaternions(this.tempQuaternion2, this.tempQuaternion), C.quaternion.copy(this.tempQuaternion))), C.visible = C.visible && (C.name.indexOf("X") === -1 || this.showX), C.visible = C.visible && (C.name.indexOf("Y") === -1 || this.showY), C.visible = C.visible && (C.name.indexOf("Z") === -1 || this.showZ), C.visible = C.visible && (C.name.indexOf("E") === -1 || this.showX && this.showY && this.showZ), C.material.tempOpacity = C.material.tempOpacity || C.material.opacity, C.material.tempColor = C.material.tempColor || C.material.color.clone(), C.material.color.copy(C.material.tempColor), C.material.opacity = C.material.tempOpacity, this.enabled ? this.axis && (C.name === this.axis ? (C.material.opacity = 1, C.material.color.lerp(new Color(1, 1, 1), 0.5)) : this.axis.split("").some(function(St) {
          return C.name === St;
        }) ? (C.material.opacity = 1, C.material.color.lerp(new Color(1, 1, 1), 0.5)) : (C.material.opacity *= 0.25, C.material.color.lerp(new Color(1, 1, 1), 0.5))) : (C.material.opacity *= 0.5, C.material.color.lerp(new Color(1, 1, 1), 0.5));
      }
      super.updateMatrixWorld();
    });
    const t = new MeshBasicMaterial({
      depthTest: false,
      depthWrite: false,
      transparent: true,
      side: DoubleSide,
      fog: false,
      toneMapped: false
    }), e = new LineBasicMaterial({
      depthTest: false,
      depthWrite: false,
      transparent: true,
      linewidth: 1,
      fog: false,
      toneMapped: false
    }), r = t.clone();
    r.opacity = 0.15;
    const i = t.clone();
    i.opacity = 0.33;
    const s = t.clone();
    s.color.set(16711680);
    const o = t.clone();
    o.color.set(65280);
    const a = t.clone();
    a.color.set(255);
    const c = t.clone();
    c.opacity = 0.25;
    const l = c.clone();
    l.color.set(16776960);
    const u = c.clone();
    u.color.set(65535);
    const v = c.clone();
    v.color.set(16711935), t.clone().color.set(16776960);
    const p = e.clone();
    p.color.set(16711680);
    const b = e.clone();
    b.color.set(65280);
    const S = e.clone();
    S.color.set(255);
    const x = e.clone();
    x.color.set(65535);
    const d = e.clone();
    d.color.set(16711935);
    const g = e.clone();
    g.color.set(16776960);
    const E = e.clone();
    E.color.set(7895160);
    const f = g.clone();
    f.opacity = 0.25;
    const y = new CylinderGeometry(0, 0.05, 0.2, 12, 1, false), h = new BoxGeometry(0.125, 0.125, 0.125), _ = new BufferGeometry();
    _.setAttribute("position", new Float32BufferAttribute([0, 0, 0, 1, 0, 0], 3));
    const T = (B, V) => {
      const q = new BufferGeometry(), nt = [];
      for (let C = 0; C <= 64 * V; ++C)
        nt.push(0, Math.cos(C / 32 * Math.PI) * B, Math.sin(C / 32 * Math.PI) * B);
      return q.setAttribute("position", new Float32BufferAttribute(nt, 3)), q;
    }, L = () => {
      const B = new BufferGeometry();
      return B.setAttribute("position", new Float32BufferAttribute([0, 0, 0, 1, 1, 1], 3)), B;
    }, M = {
      X: [
        [new Mesh(y, s), [1, 0, 0], [0, 0, -Math.PI / 2], null, "fwd"],
        [new Mesh(y, s), [1, 0, 0], [0, 0, Math.PI / 2], null, "bwd"],
        [new Line(_, p)]
      ],
      Y: [
        [new Mesh(y, o), [0, 1, 0], null, null, "fwd"],
        [new Mesh(y, o), [0, 1, 0], [Math.PI, 0, 0], null, "bwd"],
        [new Line(_, b), null, [0, 0, Math.PI / 2]]
      ],
      Z: [
        [new Mesh(y, a), [0, 0, 1], [Math.PI / 2, 0, 0], null, "fwd"],
        [new Mesh(y, a), [0, 0, 1], [-Math.PI / 2, 0, 0], null, "bwd"],
        [new Line(_, S), null, [0, -Math.PI / 2, 0]]
      ],
      XYZ: [[new Mesh(new OctahedronGeometry(0.1, 0), c.clone()), [0, 0, 0], [0, 0, 0]]],
      XY: [
        [new Mesh(new PlaneGeometry(0.295, 0.295), l.clone()), [0.15, 0.15, 0]],
        [new Line(_, g), [0.18, 0.3, 0], null, [0.125, 1, 1]],
        [new Line(_, g), [0.3, 0.18, 0], [0, 0, Math.PI / 2], [0.125, 1, 1]]
      ],
      YZ: [
        [new Mesh(new PlaneGeometry(0.295, 0.295), u.clone()), [0, 0.15, 0.15], [0, Math.PI / 2, 0]],
        [new Line(_, x), [0, 0.18, 0.3], [0, 0, Math.PI / 2], [0.125, 1, 1]],
        [new Line(_, x), [0, 0.3, 0.18], [0, -Math.PI / 2, 0], [0.125, 1, 1]]
      ],
      XZ: [
        [
          new Mesh(new PlaneGeometry(0.295, 0.295), v.clone()),
          [0.15, 0, 0.15],
          [-Math.PI / 2, 0, 0]
        ],
        [new Line(_, d), [0.18, 0, 0.3], null, [0.125, 1, 1]],
        [new Line(_, d), [0.3, 0, 0.18], [0, -Math.PI / 2, 0], [0.125, 1, 1]]
      ]
    }, I = {
      X: [[new Mesh(new CylinderGeometry(0.2, 0, 1, 4, 1, false), r), [0.6, 0, 0], [0, 0, -Math.PI / 2]]],
      Y: [[new Mesh(new CylinderGeometry(0.2, 0, 1, 4, 1, false), r), [0, 0.6, 0]]],
      Z: [[new Mesh(new CylinderGeometry(0.2, 0, 1, 4, 1, false), r), [0, 0, 0.6], [Math.PI / 2, 0, 0]]],
      XYZ: [[new Mesh(new OctahedronGeometry(0.2, 0), r)]],
      XY: [[new Mesh(new PlaneGeometry(0.4, 0.4), r), [0.2, 0.2, 0]]],
      YZ: [[new Mesh(new PlaneGeometry(0.4, 0.4), r), [0, 0.2, 0.2], [0, Math.PI / 2, 0]]],
      XZ: [[new Mesh(new PlaneGeometry(0.4, 0.4), r), [0.2, 0, 0.2], [-Math.PI / 2, 0, 0]]]
    }, D = {
      START: [[new Mesh(new OctahedronGeometry(0.01, 2), i), null, null, null, "helper"]],
      END: [[new Mesh(new OctahedronGeometry(0.01, 2), i), null, null, null, "helper"]],
      DELTA: [[new Line(L(), i), null, null, null, "helper"]],
      X: [[new Line(_, i.clone()), [-1e3, 0, 0], null, [1e6, 1, 1], "helper"]],
      Y: [[new Line(_, i.clone()), [0, -1e3, 0], [0, 0, Math.PI / 2], [1e6, 1, 1], "helper"]],
      Z: [[new Line(_, i.clone()), [0, 0, -1e3], [0, -Math.PI / 2, 0], [1e6, 1, 1], "helper"]]
    }, O = {
      X: [
        [new Line(T(1, 0.5), p)],
        [new Mesh(new OctahedronGeometry(0.04, 0), s), [0, 0, 0.99], null, [1, 3, 1]]
      ],
      Y: [
        [new Line(T(1, 0.5), b), null, [0, 0, -Math.PI / 2]],
        [new Mesh(new OctahedronGeometry(0.04, 0), o), [0, 0, 0.99], null, [3, 1, 1]]
      ],
      Z: [
        [new Line(T(1, 0.5), S), null, [0, Math.PI / 2, 0]],
        [new Mesh(new OctahedronGeometry(0.04, 0), a), [0.99, 0, 0], null, [1, 3, 1]]
      ],
      E: [
        [new Line(T(1.25, 1), f), null, [0, Math.PI / 2, 0]],
        [
          new Mesh(new CylinderGeometry(0.03, 0, 0.15, 4, 1, false), f),
          [1.17, 0, 0],
          [0, 0, -Math.PI / 2],
          [1, 1, 1e-3]
        ],
        [
          new Mesh(new CylinderGeometry(0.03, 0, 0.15, 4, 1, false), f),
          [-1.17, 0, 0],
          [0, 0, Math.PI / 2],
          [1, 1, 1e-3]
        ],
        [
          new Mesh(new CylinderGeometry(0.03, 0, 0.15, 4, 1, false), f),
          [0, -1.17, 0],
          [Math.PI, 0, 0],
          [1, 1, 1e-3]
        ],
        [
          new Mesh(new CylinderGeometry(0.03, 0, 0.15, 4, 1, false), f),
          [0, 1.17, 0],
          [0, 0, 0],
          [1, 1, 1e-3]
        ]
      ],
      XYZE: [[new Line(T(1, 1), E), null, [0, Math.PI / 2, 0]]]
    }, F = {
      AXIS: [[new Line(_, i.clone()), [-1e3, 0, 0], null, [1e6, 1, 1], "helper"]]
    }, U = {
      X: [[new Mesh(new TorusGeometry(1, 0.1, 4, 24), r), [0, 0, 0], [0, -Math.PI / 2, -Math.PI / 2]]],
      Y: [[new Mesh(new TorusGeometry(1, 0.1, 4, 24), r), [0, 0, 0], [Math.PI / 2, 0, 0]]],
      Z: [[new Mesh(new TorusGeometry(1, 0.1, 4, 24), r), [0, 0, 0], [0, 0, -Math.PI / 2]]],
      E: [[new Mesh(new TorusGeometry(1.25, 0.1, 2, 24), r)]],
      XYZE: [[new Mesh(new SphereGeometry(0.7, 10, 8), r)]]
    }, X = {
      X: [
        [new Mesh(h, s), [0.8, 0, 0], [0, 0, -Math.PI / 2]],
        [new Line(_, p), null, null, [0.8, 1, 1]]
      ],
      Y: [
        [new Mesh(h, o), [0, 0.8, 0]],
        [new Line(_, b), null, [0, 0, Math.PI / 2], [0.8, 1, 1]]
      ],
      Z: [
        [new Mesh(h, a), [0, 0, 0.8], [Math.PI / 2, 0, 0]],
        [new Line(_, S), null, [0, -Math.PI / 2, 0], [0.8, 1, 1]]
      ],
      XY: [
        [new Mesh(h, l), [0.85, 0.85, 0], null, [2, 2, 0.2]],
        [new Line(_, g), [0.855, 0.98, 0], null, [0.125, 1, 1]],
        [new Line(_, g), [0.98, 0.855, 0], [0, 0, Math.PI / 2], [0.125, 1, 1]]
      ],
      YZ: [
        [new Mesh(h, u), [0, 0.85, 0.85], null, [0.2, 2, 2]],
        [new Line(_, x), [0, 0.855, 0.98], [0, 0, Math.PI / 2], [0.125, 1, 1]],
        [new Line(_, x), [0, 0.98, 0.855], [0, -Math.PI / 2, 0], [0.125, 1, 1]]
      ],
      XZ: [
        [new Mesh(h, v), [0.85, 0, 0.85], null, [2, 0.2, 2]],
        [new Line(_, d), [0.855, 0, 0.98], null, [0.125, 1, 1]],
        [new Line(_, d), [0.98, 0, 0.855], [0, -Math.PI / 2, 0], [0.125, 1, 1]]
      ],
      XYZX: [[new Mesh(new BoxGeometry(0.125, 0.125, 0.125), c.clone()), [1.1, 0, 0]]],
      XYZY: [[new Mesh(new BoxGeometry(0.125, 0.125, 0.125), c.clone()), [0, 1.1, 0]]],
      XYZZ: [[new Mesh(new BoxGeometry(0.125, 0.125, 0.125), c.clone()), [0, 0, 1.1]]]
    }, $ = {
      X: [[new Mesh(new CylinderGeometry(0.2, 0, 0.8, 4, 1, false), r), [0.5, 0, 0], [0, 0, -Math.PI / 2]]],
      Y: [[new Mesh(new CylinderGeometry(0.2, 0, 0.8, 4, 1, false), r), [0, 0.5, 0]]],
      Z: [[new Mesh(new CylinderGeometry(0.2, 0, 0.8, 4, 1, false), r), [0, 0, 0.5], [Math.PI / 2, 0, 0]]],
      XY: [[new Mesh(h, r), [0.85, 0.85, 0], null, [3, 3, 0.2]]],
      YZ: [[new Mesh(h, r), [0, 0.85, 0.85], null, [0.2, 3, 3]]],
      XZ: [[new Mesh(h, r), [0.85, 0, 0.85], null, [3, 0.2, 3]]],
      XYZX: [[new Mesh(new BoxGeometry(0.2, 0.2, 0.2), r), [1.1, 0, 0]]],
      XYZY: [[new Mesh(new BoxGeometry(0.2, 0.2, 0.2), r), [0, 1.1, 0]]],
      XYZZ: [[new Mesh(new BoxGeometry(0.2, 0.2, 0.2), r), [0, 0, 1.1]]]
    }, rt = {
      X: [[new Line(_, i.clone()), [-1e3, 0, 0], null, [1e6, 1, 1], "helper"]],
      Y: [[new Line(_, i.clone()), [0, -1e3, 0], [0, 0, Math.PI / 2], [1e6, 1, 1], "helper"]],
      Z: [[new Line(_, i.clone()), [0, 0, -1e3], [0, -Math.PI / 2, 0], [1e6, 1, 1], "helper"]]
    }, Y = (B) => {
      const V = new Object3D();
      for (let q in B)
        for (let nt = B[q].length; nt--; ) {
          const C = B[q][nt][0].clone(), st = B[q][nt][1], St = B[q][nt][2], At = B[q][nt][3], zt = B[q][nt][4];
          C.name = q, C.tag = zt, st && C.position.set(st[0], st[1], st[2]), St && C.rotation.set(St[0], St[1], St[2]), At && C.scale.set(At[0], At[1], At[2]), C.updateMatrix();
          const Xt = C.geometry.clone();
          Xt.applyMatrix4(C.matrix), C.geometry = Xt, C.renderOrder = 1 / 0, C.position.set(0, 0, 0), C.rotation.set(0, 0, 0), C.scale.set(1, 1, 1), V.add(C);
        }
      return V;
    };
    this.gizmo = {}, this.picker = {}, this.helper = {}, this.add(this.gizmo.translate = Y(M)), this.add(this.gizmo.rotate = Y(O)), this.add(this.gizmo.scale = Y(X)), this.add(this.picker.translate = Y(I)), this.add(this.picker.rotate = Y(U)), this.add(this.picker.scale = Y($)), this.add(this.helper.translate = Y(D)), this.add(this.helper.rotate = Y(F)), this.add(this.helper.scale = Y(rt)), this.picker.translate.visible = false, this.picker.rotate.visible = false, this.picker.scale.visible = false;
  }
};
var ac = class extends Mesh {
  constructor() {
    super(
      new PlaneGeometry(1e5, 1e5, 2, 2),
      new MeshBasicMaterial({
        visible: false,
        wireframe: true,
        side: DoubleSide,
        transparent: true,
        opacity: 0.1,
        toneMapped: false
      })
    ), A(this, "isTransformControlsPlane", true), A(this, "type", "TransformControlsPlane"), A(this, "unitX", new Vector3(1, 0, 0)), A(this, "unitY", new Vector3(0, 1, 0)), A(this, "unitZ", new Vector3(0, 0, 1)), A(this, "tempVector", new Vector3()), A(this, "dirVector", new Vector3()), A(this, "alignVector", new Vector3()), A(this, "tempMatrix", new Matrix4()), A(this, "identityQuaternion", new Quaternion()), A(this, "cameraQuaternion", new Quaternion()), A(this, "worldPosition", new Vector3()), A(this, "worldQuaternion", new Quaternion()), A(this, "eye", new Vector3()), A(this, "axis", null), A(this, "mode", "translate"), A(this, "space", "world"), A(this, "updateMatrixWorld", () => {
      let t = this.space;
      switch (this.position.copy(this.worldPosition), this.mode === "scale" && (t = "local"), this.unitX.set(1, 0, 0).applyQuaternion(t === "local" ? this.worldQuaternion : this.identityQuaternion), this.unitY.set(0, 1, 0).applyQuaternion(t === "local" ? this.worldQuaternion : this.identityQuaternion), this.unitZ.set(0, 0, 1).applyQuaternion(t === "local" ? this.worldQuaternion : this.identityQuaternion), this.alignVector.copy(this.unitY), this.mode) {
        case "translate":
        case "scale":
          switch (this.axis) {
            case "X":
              this.alignVector.copy(this.eye).cross(this.unitX), this.dirVector.copy(this.unitX).cross(this.alignVector);
              break;
            case "Y":
              this.alignVector.copy(this.eye).cross(this.unitY), this.dirVector.copy(this.unitY).cross(this.alignVector);
              break;
            case "Z":
              this.alignVector.copy(this.eye).cross(this.unitZ), this.dirVector.copy(this.unitZ).cross(this.alignVector);
              break;
            case "XY":
              this.dirVector.copy(this.unitZ);
              break;
            case "YZ":
              this.dirVector.copy(this.unitX);
              break;
            case "XZ":
              this.alignVector.copy(this.unitZ), this.dirVector.copy(this.unitY);
              break;
            case "XYZ":
            case "E":
              this.dirVector.set(0, 0, 0);
              break;
          }
          break;
        case "rotate":
        default:
          this.dirVector.set(0, 0, 0);
      }
      this.dirVector.length() === 0 ? this.quaternion.copy(this.cameraQuaternion) : (this.tempMatrix.lookAt(this.tempVector.set(0, 0, 0), this.dirVector, this.alignVector), this.quaternion.setFromRotationMatrix(this.tempMatrix)), super.updateMatrixWorld();
    });
  }
};
var lc = (n) => typeof n == "object" && typeof n.then == "function";
var Ir = [];
function cc(n, t, e = (r, i) => r === i) {
  if (n === t) return true;
  if (!n || !t) return false;
  const r = n.length;
  if (t.length !== r) return false;
  for (let i = 0; i < r; i++) if (!e(n[i], t[i])) return false;
  return true;
}
function uc(n, t = null, e = false, r = {}) {
  t === null && (t = [n]);
  for (const s of Ir)
    if (cc(t, s.keys, s.equal)) {
      if (e) return;
      if (Object.prototype.hasOwnProperty.call(s, "error")) throw s.error;
      if (Object.prototype.hasOwnProperty.call(s, "response"))
        return r.lifespan && r.lifespan > 0 && (s.timeout && clearTimeout(s.timeout), s.timeout = setTimeout(s.remove, r.lifespan)), s.response;
      if (!e) throw s.promise;
    }
  const i = {
    keys: t,
    equal: r.equal,
    remove: () => {
      const s = Ir.indexOf(i);
      s !== -1 && Ir.splice(s, 1);
    },
    promise: (
      // Execute the promise
      (lc(n) ? n : n(...t)).then((s) => {
        i.response = s, r.lifespan && r.lifespan > 0 && (i.timeout = setTimeout(i.remove, r.lifespan));
      }).catch((s) => i.error = s)
    )
  };
  if (Ir.push(i), !e) throw i.promise;
}
var hc = (n, t, e) => uc(n, t, false, e);
function dc(n, t, e, r) {
  const i = class extends ShaderMaterial {
    constructor(o = {}) {
      const a = Object.entries(n);
      super({
        uniforms: a.reduce((c, [l, u]) => {
          const v = UniformsUtils.clone({
            [l]: {
              value: u
            }
          });
          return {
            ...c,
            ...v
          };
        }, {}),
        vertexShader: t,
        fragmentShader: e
      }), this.key = "", a.forEach(([c]) => Object.defineProperty(this, c, {
        get: () => this.uniforms[c].value,
        set: (l) => this.uniforms[c].value = l
      })), Object.assign(this, o);
    }
  };
  return i.key = MathUtils.generateUUID(), i;
}
var fc = () => parseInt(REVISION.replace(/\D+/g, ""));
var pc = fc();
function pi(n, t, e) {
  const r = useThree((m) => m.size), i = useThree((m) => m.viewport), s = typeof n == "number" ? n : r.width * i.dpr, o = r.height * i.dpr, a = (typeof n == "number" ? e : n) || {}, {
    samples: c = 0,
    depth: l,
    ...u
  } = a, v = j.useMemo(() => {
    const m = new WebGLRenderTarget(s, o, {
      minFilter: LinearFilter,
      magFilter: LinearFilter,
      type: HalfFloatType,
      ...u
    });
    return l && (m.depthTexture = new DepthTexture(s, o, FloatType)), m.samples = c, m;
  }, []);
  return j.useLayoutEffect(() => {
    v.setSize(s, o), c && (v.samples = c);
  }, [c, v, s, o]), j.useEffect(() => () => v.dispose(), []), v;
}
var gc = (n) => typeof n == "function";
var vc = j.forwardRef(({
  envMap: n,
  resolution: t = 256,
  frames: e = 1 / 0,
  children: r,
  makeDefault: i,
  ...s
}, o) => {
  const a = useThree(({
    set: x
  }) => x), c = useThree(({
    camera: x
  }) => x), l = useThree(({
    size: x
  }) => x), u = j.useRef(null);
  j.useImperativeHandle(o, () => u.current, []);
  const v = j.useRef(null), m = pi(t);
  j.useLayoutEffect(() => {
    s.manual || u.current.updateProjectionMatrix();
  }, [l, s]), j.useLayoutEffect(() => {
    u.current.updateProjectionMatrix();
  }), j.useLayoutEffect(() => {
    if (i) {
      const x = c;
      return a(() => ({
        camera: u.current
      })), () => a(() => ({
        camera: x
      }));
    }
  }, [u, i, a]);
  let p = 0, b = null;
  const S = gc(r);
  return useFrame((x) => {
    S && (e === 1 / 0 || p < e) && (v.current.visible = false, x.gl.setRenderTarget(m), b = x.scene.background, n && (x.scene.background = n), x.gl.render(x.scene, u.current), x.scene.background = b, x.gl.setRenderTarget(null), v.current.visible = true, p++);
  }), j.createElement(j.Fragment, null, j.createElement("orthographicCamera", we({
    left: l.width / -2,
    right: l.width / 2,
    top: l.height / 2,
    bottom: l.height / -2,
    ref: u
  }, s), !S && r), j.createElement("group", {
    ref: v
  }, S && r(m.texture)));
});
var mc = j.forwardRef(({
  children: n,
  domElement: t,
  onChange: e,
  onMouseDown: r,
  onMouseUp: i,
  onObjectChange: s,
  object: o,
  makeDefault: a,
  camera: c,
  // Transform
  enabled: l,
  axis: u,
  mode: v,
  translationSnap: m,
  rotationSnap: p,
  scaleSnap: b,
  space: S,
  size: x,
  showX: d,
  showY: g,
  showZ: E,
  ...f
}, y) => {
  const h = useThree((V) => V.controls), _ = useThree((V) => V.gl), T = useThree((V) => V.events), L = useThree((V) => V.camera), M = useThree((V) => V.invalidate), I = useThree((V) => V.get), D = useThree((V) => V.set), O = c || L, F = t || T.connected || _.domElement, U = j.useMemo(() => new sc(O, F), [O, F]), X = j.useRef(null);
  j.useLayoutEffect(() => (o ? U.attach(o instanceof Object3D ? o : o.current) : X.current instanceof Object3D && U.attach(X.current), () => void U.detach()), [o, n, U]), j.useEffect(() => {
    if (h) {
      const V = (q) => h.enabled = !q.value;
      return U.addEventListener("dragging-changed", V), () => U.removeEventListener("dragging-changed", V);
    }
  }, [U, h]);
  const $ = j.useRef(), rt = j.useRef(), Y = j.useRef(), B = j.useRef();
  return j.useLayoutEffect(() => void ($.current = e), [e]), j.useLayoutEffect(() => void (rt.current = r), [r]), j.useLayoutEffect(() => void (Y.current = i), [i]), j.useLayoutEffect(() => void (B.current = s), [s]), j.useEffect(() => {
    const V = (st) => {
      M(), $.current == null || $.current(st);
    }, q = (st) => rt.current == null ? void 0 : rt.current(st), nt = (st) => Y.current == null ? void 0 : Y.current(st), C = (st) => B.current == null ? void 0 : B.current(st);
    return U.addEventListener("change", V), U.addEventListener("mouseDown", q), U.addEventListener("mouseUp", nt), U.addEventListener("objectChange", C), () => {
      U.removeEventListener("change", V), U.removeEventListener("mouseDown", q), U.removeEventListener("mouseUp", nt), U.removeEventListener("objectChange", C);
    };
  }, [M, U]), j.useEffect(() => {
    if (a) {
      const V = I().controls;
      return D({
        controls: U
      }), () => D({
        controls: V
      });
    }
  }, [a, U]), j.createElement(j.Fragment, null, j.createElement("primitive", {
    ref: y,
    object: U,
    enabled: l,
    axis: u,
    mode: v,
    translationSnap: m,
    rotationSnap: p,
    scaleSnap: b,
    space: S,
    size: x,
    showX: d,
    showY: g,
    showZ: E
  }), j.createElement("group", we({
    ref: X
  }, f), n));
});
var dt = {
  LEFT: 1,
  RIGHT: 2,
  MIDDLE: 4
};
var R = Object.freeze({
  NONE: 0,
  ROTATE: 1,
  TRUCK: 2,
  OFFSET: 4,
  DOLLY: 8,
  ZOOM: 16,
  TOUCH_ROTATE: 32,
  TOUCH_TRUCK: 64,
  TOUCH_OFFSET: 128,
  TOUCH_DOLLY: 256,
  TOUCH_ZOOM: 512,
  TOUCH_DOLLY_TRUCK: 1024,
  TOUCH_DOLLY_OFFSET: 2048,
  TOUCH_DOLLY_ROTATE: 4096,
  TOUCH_ZOOM_TRUCK: 8192,
  TOUCH_ZOOM_OFFSET: 16384,
  TOUCH_ZOOM_ROTATE: 32768
});
var Pe = {
  NONE: 0,
  IN: 1,
  OUT: -1
};
function me(n) {
  return n.isPerspectiveCamera;
}
function se(n) {
  return n.isOrthographicCamera;
}
var Me = Math.PI * 2;
var Ji = Math.PI / 2;
var ao = 1e-5;
var $e = Math.PI / 180;
function qt(n, t, e) {
  return Math.max(t, Math.min(e, n));
}
function ht(n, t = ao) {
  return Math.abs(n) < t;
}
function lt(n, t, e = ao) {
  return ht(n - t, e);
}
function ts(n, t) {
  return Math.round(n / t) * t;
}
function Je(n) {
  return isFinite(n) ? n : n < 0 ? -Number.MAX_VALUE : Number.MAX_VALUE;
}
function tr(n) {
  return Math.abs(n) < Number.MAX_VALUE ? n : n * (1 / 0);
}
function Lr(n, t, e, r, i = 1 / 0, s) {
  r = Math.max(1e-4, r);
  const o = 2 / r, a = o * s, c = 1 / (1 + a + 0.48 * a * a + 0.235 * a * a * a);
  let l = n - t;
  const u = t, v = i * r;
  l = qt(l, -v, v), t = n - l;
  const m = (e.value + o * l) * s;
  e.value = (e.value - o * m) * c;
  let p = t + (l + m) * c;
  return u - n > 0 == p > u && (p = u, e.value = (p - u) / s), p;
}
function es(n, t, e, r, i = 1 / 0, s, o) {
  r = Math.max(1e-4, r);
  const a = 2 / r, c = a * s, l = 1 / (1 + c + 0.48 * c * c + 0.235 * c * c * c);
  let u = t.x, v = t.y, m = t.z, p = n.x - u, b = n.y - v, S = n.z - m;
  const x = u, d = v, g = m, E = i * r, f = E * E, y = p * p + b * b + S * S;
  if (y > f) {
    const U = Math.sqrt(y);
    p = p / U * E, b = b / U * E, S = S / U * E;
  }
  u = n.x - p, v = n.y - b, m = n.z - S;
  const h = (e.x + a * p) * s, _ = (e.y + a * b) * s, T = (e.z + a * S) * s;
  e.x = (e.x - a * h) * l, e.y = (e.y - a * _) * l, e.z = (e.z - a * T) * l, o.x = u + (p + h) * l, o.y = v + (b + _) * l, o.z = m + (S + T) * l;
  const L = x - n.x, M = d - n.y, I = g - n.z, D = o.x - x, O = o.y - d, F = o.z - g;
  return L * D + M * O + I * F > 0 && (o.x = x, o.y = d, o.z = g, e.x = (o.x - x) / s, e.y = (o.y - d) / s, e.z = (o.z - g) / s), o;
}
function On(n, t) {
  t.set(0, 0), n.forEach((e) => {
    t.x += e.clientX, t.y += e.clientY;
  }), t.x /= n.length, t.y /= n.length;
}
function Tn(n, t) {
  return se(n) ? (console.warn(`${t} is not supported in OrthographicCamera`), true) : false;
}
var _c = class {
  constructor() {
    this._listeners = {};
  }
  /**
   * Adds the specified event listener.
   * @param type event name
   * @param listener handler function
   * @category Methods
   */
  addEventListener(t, e) {
    const r = this._listeners;
    r[t] === void 0 && (r[t] = []), r[t].indexOf(e) === -1 && r[t].push(e);
  }
  /**
   * Presence of the specified event listener.
   * @param type event name
   * @param listener handler function
   * @category Methods
   */
  hasEventListener(t, e) {
    const r = this._listeners;
    return r[t] !== void 0 && r[t].indexOf(e) !== -1;
  }
  /**
   * Removes the specified event listener
   * @param type event name
   * @param listener handler function
   * @category Methods
   */
  removeEventListener(t, e) {
    const i = this._listeners[t];
    if (i !== void 0) {
      const s = i.indexOf(e);
      s !== -1 && i.splice(s, 1);
    }
  }
  /**
   * Removes all event listeners
   * @param type event name
   * @category Methods
   */
  removeAllEventListeners(t) {
    if (!t) {
      this._listeners = {};
      return;
    }
    Array.isArray(this._listeners[t]) && (this._listeners[t].length = 0);
  }
  /**
   * Fire an event type.
   * @param event DispatcherEvent
   * @category Methods
   */
  dispatchEvent(t) {
    const r = this._listeners[t.type];
    if (r !== void 0) {
      t.target = this;
      const i = r.slice(0);
      for (let s = 0, o = i.length; s < o; s++)
        i[s].call(this, t);
    }
  }
};
var Cn;
var yc = "2.9.0";
var Dr = 1 / 8;
var Ec = /Mac/.test((Cn = globalThis == null ? void 0 : globalThis.navigator) === null || Cn === void 0 ? void 0 : Cn.platform);
var K;
var rs;
var Ar;
var In;
var Mt;
var Q;
var it;
var ke;
var er;
var Jt;
var te;
var _e;
var ns;
var is;
var Bt;
var rr;
var Ue;
var ss;
var Ln;
var os;
var Dn;
var An;
var Rr;
var Vr = class Kn extends _c {
  /**
       * Injects THREE as the dependency. You can then proceed to use CameraControls.
       *
       * e.g
       * ```javascript
       * CameraControls.install( { THREE: THREE } );
       * ```
       *
       * Note: If you do not wish to use enter three.js to reduce file size(tree-shaking for example), make a subset to install.
       *
       * ```js
       * import {
       * 	Vector2,
       * 	Vector3,
       * 	Vector4,
       * 	Quaternion,
       * 	Matrix4,
       * 	Spherical,
       * 	Box3,
       * 	Sphere,
       * 	Raycaster,
       * 	MathUtils,
       * } from 'three';
       *
       * const subsetOfTHREE = {
       * 	Vector2   : Vector2,
       * 	Vector3   : Vector3,
       * 	Vector4   : Vector4,
       * 	Quaternion: Quaternion,
       * 	Matrix4   : Matrix4,
       * 	Spherical : Spherical,
       * 	Box3      : Box3,
       * 	Sphere    : Sphere,
       * 	Raycaster : Raycaster,
       * };
  
       * CameraControls.install( { THREE: subsetOfTHREE } );
       * ```
       * @category Statics
       */
  static install(t) {
    K = t.THREE, rs = Object.freeze(new K.Vector3(0, 0, 0)), Ar = Object.freeze(new K.Vector3(0, 1, 0)), In = Object.freeze(new K.Vector3(0, 0, 1)), Mt = new K.Vector2(), Q = new K.Vector3(), it = new K.Vector3(), ke = new K.Vector3(), er = new K.Vector3(), Jt = new K.Vector3(), te = new K.Vector3(), _e = new K.Vector3(), ns = new K.Vector3(), is = new K.Vector3(), Bt = new K.Spherical(), rr = new K.Spherical(), Ue = new K.Box3(), ss = new K.Box3(), Ln = new K.Sphere(), os = new K.Quaternion(), Dn = new K.Quaternion(), An = new K.Matrix4(), Rr = new K.Raycaster();
  }
  /**
   * list all ACTIONs
   * @category Statics
   */
  static get ACTION() {
    return R;
  }
  /**
   * Creates a `CameraControls` instance.
   *
   * Note:
   * You **must install** three.js before using camera-controls. see [#install](#install)
   * Not doing so will lead to runtime errors (`undefined` references to THREE).
   *
   * e.g.
   * ```
   * CameraControls.install( { THREE } );
   * const cameraControls = new CameraControls( camera, domElement );
   * ```
   *
   * @param camera A `THREE.PerspectiveCamera` or `THREE.OrthographicCamera` to be controlled.
   * @param domElement A `HTMLElement` for the draggable area, usually `renderer.domElement`.
   * @category Constructor
   */
  constructor(t, e) {
    super(), this.minPolarAngle = 0, this.maxPolarAngle = Math.PI, this.minAzimuthAngle = -1 / 0, this.maxAzimuthAngle = 1 / 0, this.minDistance = Number.EPSILON, this.maxDistance = 1 / 0, this.infinityDolly = false, this.minZoom = 0.01, this.maxZoom = 1 / 0, this.smoothTime = 0.25, this.draggingSmoothTime = 0.125, this.maxSpeed = 1 / 0, this.azimuthRotateSpeed = 1, this.polarRotateSpeed = 1, this.dollySpeed = 1, this.dollyDragInverted = false, this.truckSpeed = 2, this.dollyToCursor = false, this.dragToOffset = false, this.verticalDragToForward = false, this.boundaryFriction = 0, this.restThreshold = 0.01, this.colliderMeshes = [], this.cancel = () => {
    }, this._enabled = true, this._state = R.NONE, this._viewport = null, this._changedDolly = 0, this._changedZoom = 0, this._hasRested = true, this._boundaryEnclosesCamera = false, this._needsUpdate = true, this._updatedLastTime = false, this._elementRect = new DOMRect(), this._isDragging = false, this._dragNeedsUpdate = true, this._activePointers = [], this._lockedPointer = null, this._interactiveArea = new DOMRect(0, 0, 1, 1), this._isUserControllingRotate = false, this._isUserControllingDolly = false, this._isUserControllingTruck = false, this._isUserControllingOffset = false, this._isUserControllingZoom = false, this._lastDollyDirection = Pe.NONE, this._thetaVelocity = { value: 0 }, this._phiVelocity = { value: 0 }, this._radiusVelocity = { value: 0 }, this._targetVelocity = new K.Vector3(), this._focalOffsetVelocity = new K.Vector3(), this._zoomVelocity = { value: 0 }, this._truckInternal = (d, g, E) => {
      let f, y;
      if (me(this._camera)) {
        const h = Q.copy(this._camera.position).sub(this._target), _ = this._camera.getEffectiveFOV() * $e, T = h.length() * Math.tan(_ * 0.5);
        f = this.truckSpeed * d * T / this._elementRect.height, y = this.truckSpeed * g * T / this._elementRect.height;
      } else if (se(this._camera)) {
        const h = this._camera;
        f = d * (h.right - h.left) / h.zoom / this._elementRect.width, y = g * (h.top - h.bottom) / h.zoom / this._elementRect.height;
      } else
        return;
      this.verticalDragToForward ? (E ? this.setFocalOffset(this._focalOffsetEnd.x + f, this._focalOffsetEnd.y, this._focalOffsetEnd.z, true) : this.truck(f, 0, true), this.forward(-y, true)) : E ? this.setFocalOffset(this._focalOffsetEnd.x + f, this._focalOffsetEnd.y + y, this._focalOffsetEnd.z, true) : this.truck(f, y, true);
    }, this._rotateInternal = (d, g) => {
      const E = Me * this.azimuthRotateSpeed * d / this._elementRect.height, f = Me * this.polarRotateSpeed * g / this._elementRect.height;
      this.rotate(E, f, true);
    }, this._dollyInternal = (d, g, E) => {
      const f = Math.pow(0.95, -d * this.dollySpeed), y = this._sphericalEnd.radius, h = this._sphericalEnd.radius * f, _ = qt(h, this.minDistance, this.maxDistance), T = _ - h;
      this.infinityDolly && this.dollyToCursor ? this._dollyToNoClamp(h, true) : this.infinityDolly && !this.dollyToCursor ? (this.dollyInFixed(T, true), this._dollyToNoClamp(_, true)) : this._dollyToNoClamp(_, true), this.dollyToCursor && (this._changedDolly += (this.infinityDolly ? h : _) - y, this._dollyControlCoord.set(g, E)), this._lastDollyDirection = Math.sign(-d);
    }, this._zoomInternal = (d, g, E) => {
      const f = Math.pow(0.95, d * this.dollySpeed), y = this._zoom, h = this._zoom * f;
      this.zoomTo(h, true), this.dollyToCursor && (this._changedZoom += h - y, this._dollyControlCoord.set(g, E));
    }, typeof K > "u" && console.error("camera-controls: `THREE` is undefined. You must first run `CameraControls.install( { THREE: THREE } )`. Check the docs for further information."), this._camera = t, this._yAxisUpSpace = new K.Quaternion().setFromUnitVectors(this._camera.up, Ar), this._yAxisUpSpaceInverse = this._yAxisUpSpace.clone().invert(), this._state = R.NONE, this._target = new K.Vector3(), this._targetEnd = this._target.clone(), this._focalOffset = new K.Vector3(), this._focalOffsetEnd = this._focalOffset.clone(), this._spherical = new K.Spherical().setFromVector3(Q.copy(this._camera.position).applyQuaternion(this._yAxisUpSpace)), this._sphericalEnd = this._spherical.clone(), this._lastDistance = this._spherical.radius, this._zoom = this._camera.zoom, this._zoomEnd = this._zoom, this._lastZoom = this._zoom, this._nearPlaneCorners = [
      new K.Vector3(),
      new K.Vector3(),
      new K.Vector3(),
      new K.Vector3()
    ], this._updateNearPlaneCorners(), this._boundary = new K.Box3(new K.Vector3(-1 / 0, -1 / 0, -1 / 0), new K.Vector3(1 / 0, 1 / 0, 1 / 0)), this._cameraUp0 = this._camera.up.clone(), this._target0 = this._target.clone(), this._position0 = this._camera.position.clone(), this._zoom0 = this._zoom, this._focalOffset0 = this._focalOffset.clone(), this._dollyControlCoord = new K.Vector2(), this.mouseButtons = {
      left: R.ROTATE,
      middle: R.DOLLY,
      right: R.TRUCK,
      wheel: me(this._camera) ? R.DOLLY : se(this._camera) ? R.ZOOM : R.NONE
    }, this.touches = {
      one: R.TOUCH_ROTATE,
      two: me(this._camera) ? R.TOUCH_DOLLY_TRUCK : se(this._camera) ? R.TOUCH_ZOOM_TRUCK : R.NONE,
      three: R.TOUCH_TRUCK
    };
    const r = new K.Vector2(), i = new K.Vector2(), s = new K.Vector2(), o = (d) => {
      if (!this._enabled || !this._domElement)
        return;
      if (this._interactiveArea.left !== 0 || this._interactiveArea.top !== 0 || this._interactiveArea.width !== 1 || this._interactiveArea.height !== 1) {
        const f = this._domElement.getBoundingClientRect(), y = d.clientX / f.width, h = d.clientY / f.height;
        if (y < this._interactiveArea.left || y > this._interactiveArea.right || h < this._interactiveArea.top || h > this._interactiveArea.bottom)
          return;
      }
      const g = d.pointerType !== "mouse" ? null : (d.buttons & dt.LEFT) === dt.LEFT ? dt.LEFT : (d.buttons & dt.MIDDLE) === dt.MIDDLE ? dt.MIDDLE : (d.buttons & dt.RIGHT) === dt.RIGHT ? dt.RIGHT : null;
      if (g !== null) {
        const f = this._findPointerByMouseButton(g);
        f && this._disposePointer(f);
      }
      if ((d.buttons & dt.LEFT) === dt.LEFT && this._lockedPointer)
        return;
      const E = {
        pointerId: d.pointerId,
        clientX: d.clientX,
        clientY: d.clientY,
        deltaX: 0,
        deltaY: 0,
        mouseButton: g
      };
      this._activePointers.push(E), this._domElement.ownerDocument.removeEventListener("pointermove", a, { passive: false }), this._domElement.ownerDocument.removeEventListener("pointerup", c), this._domElement.ownerDocument.addEventListener("pointermove", a, { passive: false }), this._domElement.ownerDocument.addEventListener("pointerup", c), this._isDragging = true, m(d);
    }, a = (d) => {
      d.cancelable && d.preventDefault();
      const g = d.pointerId, E = this._lockedPointer || this._findPointerById(g);
      if (E) {
        if (E.clientX = d.clientX, E.clientY = d.clientY, E.deltaX = d.movementX, E.deltaY = d.movementY, this._state = 0, d.pointerType === "touch")
          switch (this._activePointers.length) {
            case 1:
              this._state = this.touches.one;
              break;
            case 2:
              this._state = this.touches.two;
              break;
            case 3:
              this._state = this.touches.three;
              break;
          }
        else
          (!this._isDragging && this._lockedPointer || this._isDragging && (d.buttons & dt.LEFT) === dt.LEFT) && (this._state = this._state | this.mouseButtons.left), this._isDragging && (d.buttons & dt.MIDDLE) === dt.MIDDLE && (this._state = this._state | this.mouseButtons.middle), this._isDragging && (d.buttons & dt.RIGHT) === dt.RIGHT && (this._state = this._state | this.mouseButtons.right);
        p();
      }
    }, c = (d) => {
      const g = this._findPointerById(d.pointerId);
      if (!(g && g === this._lockedPointer)) {
        if (g && this._disposePointer(g), d.pointerType === "touch")
          switch (this._activePointers.length) {
            case 0:
              this._state = R.NONE;
              break;
            case 1:
              this._state = this.touches.one;
              break;
            case 2:
              this._state = this.touches.two;
              break;
            case 3:
              this._state = this.touches.three;
              break;
          }
        else
          this._state = R.NONE;
        b();
      }
    };
    let l = -1;
    const u = (d) => {
      if (!this._domElement || !this._enabled || this.mouseButtons.wheel === R.NONE)
        return;
      if (this._interactiveArea.left !== 0 || this._interactiveArea.top !== 0 || this._interactiveArea.width !== 1 || this._interactiveArea.height !== 1) {
        const h = this._domElement.getBoundingClientRect(), _ = d.clientX / h.width, T = d.clientY / h.height;
        if (_ < this._interactiveArea.left || _ > this._interactiveArea.right || T < this._interactiveArea.top || T > this._interactiveArea.bottom)
          return;
      }
      if (d.preventDefault(), this.dollyToCursor || this.mouseButtons.wheel === R.ROTATE || this.mouseButtons.wheel === R.TRUCK) {
        const h = performance.now();
        l - h < 1e3 && this._getClientRect(this._elementRect), l = h;
      }
      const g = Ec ? -1 : -3, E = d.deltaMode === 1 ? d.deltaY / g : d.deltaY / (g * 10), f = this.dollyToCursor ? (d.clientX - this._elementRect.x) / this._elementRect.width * 2 - 1 : 0, y = this.dollyToCursor ? (d.clientY - this._elementRect.y) / this._elementRect.height * -2 + 1 : 0;
      switch (this.mouseButtons.wheel) {
        case R.ROTATE: {
          this._rotateInternal(d.deltaX, d.deltaY), this._isUserControllingRotate = true;
          break;
        }
        case R.TRUCK: {
          this._truckInternal(d.deltaX, d.deltaY, false), this._isUserControllingTruck = true;
          break;
        }
        case R.OFFSET: {
          this._truckInternal(d.deltaX, d.deltaY, true), this._isUserControllingOffset = true;
          break;
        }
        case R.DOLLY: {
          this._dollyInternal(-E, f, y), this._isUserControllingDolly = true;
          break;
        }
        case R.ZOOM: {
          this._zoomInternal(-E, f, y), this._isUserControllingZoom = true;
          break;
        }
      }
      this.dispatchEvent({ type: "control" });
    }, v = (d) => {
      if (!(!this._domElement || !this._enabled)) {
        if (this.mouseButtons.right === Kn.ACTION.NONE) {
          const g = d instanceof PointerEvent ? d.pointerId : 0, E = this._findPointerById(g);
          E && this._disposePointer(E), this._domElement.ownerDocument.removeEventListener("pointermove", a, { passive: false }), this._domElement.ownerDocument.removeEventListener("pointerup", c);
          return;
        }
        d.preventDefault();
      }
    }, m = (d) => {
      if (!this._enabled)
        return;
      if (On(this._activePointers, Mt), this._getClientRect(this._elementRect), r.copy(Mt), i.copy(Mt), this._activePointers.length >= 2) {
        const E = Mt.x - this._activePointers[1].clientX, f = Mt.y - this._activePointers[1].clientY, y = Math.sqrt(E * E + f * f);
        s.set(0, y);
        const h = (this._activePointers[0].clientX + this._activePointers[1].clientX) * 0.5, _ = (this._activePointers[0].clientY + this._activePointers[1].clientY) * 0.5;
        i.set(h, _);
      }
      if (this._state = 0, !d)
        this._lockedPointer && (this._state = this._state | this.mouseButtons.left);
      else if ("pointerType" in d && d.pointerType === "touch")
        switch (this._activePointers.length) {
          case 1:
            this._state = this.touches.one;
            break;
          case 2:
            this._state = this.touches.two;
            break;
          case 3:
            this._state = this.touches.three;
            break;
        }
      else
        !this._lockedPointer && (d.buttons & dt.LEFT) === dt.LEFT && (this._state = this._state | this.mouseButtons.left), (d.buttons & dt.MIDDLE) === dt.MIDDLE && (this._state = this._state | this.mouseButtons.middle), (d.buttons & dt.RIGHT) === dt.RIGHT && (this._state = this._state | this.mouseButtons.right);
      ((this._state & R.ROTATE) === R.ROTATE || (this._state & R.TOUCH_ROTATE) === R.TOUCH_ROTATE || (this._state & R.TOUCH_DOLLY_ROTATE) === R.TOUCH_DOLLY_ROTATE || (this._state & R.TOUCH_ZOOM_ROTATE) === R.TOUCH_ZOOM_ROTATE) && (this._sphericalEnd.theta = this._spherical.theta, this._sphericalEnd.phi = this._spherical.phi, this._thetaVelocity.value = 0, this._phiVelocity.value = 0), ((this._state & R.TRUCK) === R.TRUCK || (this._state & R.TOUCH_TRUCK) === R.TOUCH_TRUCK || (this._state & R.TOUCH_DOLLY_TRUCK) === R.TOUCH_DOLLY_TRUCK || (this._state & R.TOUCH_ZOOM_TRUCK) === R.TOUCH_ZOOM_TRUCK) && (this._targetEnd.copy(this._target), this._targetVelocity.set(0, 0, 0)), ((this._state & R.DOLLY) === R.DOLLY || (this._state & R.TOUCH_DOLLY) === R.TOUCH_DOLLY || (this._state & R.TOUCH_DOLLY_TRUCK) === R.TOUCH_DOLLY_TRUCK || (this._state & R.TOUCH_DOLLY_OFFSET) === R.TOUCH_DOLLY_OFFSET || (this._state & R.TOUCH_DOLLY_ROTATE) === R.TOUCH_DOLLY_ROTATE) && (this._sphericalEnd.radius = this._spherical.radius, this._radiusVelocity.value = 0), ((this._state & R.ZOOM) === R.ZOOM || (this._state & R.TOUCH_ZOOM) === R.TOUCH_ZOOM || (this._state & R.TOUCH_ZOOM_TRUCK) === R.TOUCH_ZOOM_TRUCK || (this._state & R.TOUCH_ZOOM_OFFSET) === R.TOUCH_ZOOM_OFFSET || (this._state & R.TOUCH_ZOOM_ROTATE) === R.TOUCH_ZOOM_ROTATE) && (this._zoomEnd = this._zoom, this._zoomVelocity.value = 0), ((this._state & R.OFFSET) === R.OFFSET || (this._state & R.TOUCH_OFFSET) === R.TOUCH_OFFSET || (this._state & R.TOUCH_DOLLY_OFFSET) === R.TOUCH_DOLLY_OFFSET || (this._state & R.TOUCH_ZOOM_OFFSET) === R.TOUCH_ZOOM_OFFSET) && (this._focalOffsetEnd.copy(this._focalOffset), this._focalOffsetVelocity.set(0, 0, 0)), this.dispatchEvent({ type: "controlstart" });
    }, p = () => {
      if (!this._enabled || !this._dragNeedsUpdate)
        return;
      this._dragNeedsUpdate = false, On(this._activePointers, Mt);
      const g = this._domElement && this._domElement.ownerDocument.pointerLockElement === this._domElement ? this._lockedPointer || this._activePointers[0] : null, E = g ? -g.deltaX : i.x - Mt.x, f = g ? -g.deltaY : i.y - Mt.y;
      if (i.copy(Mt), ((this._state & R.ROTATE) === R.ROTATE || (this._state & R.TOUCH_ROTATE) === R.TOUCH_ROTATE || (this._state & R.TOUCH_DOLLY_ROTATE) === R.TOUCH_DOLLY_ROTATE || (this._state & R.TOUCH_ZOOM_ROTATE) === R.TOUCH_ZOOM_ROTATE) && (this._rotateInternal(E, f), this._isUserControllingRotate = true), (this._state & R.DOLLY) === R.DOLLY || (this._state & R.ZOOM) === R.ZOOM) {
        const y = this.dollyToCursor ? (r.x - this._elementRect.x) / this._elementRect.width * 2 - 1 : 0, h = this.dollyToCursor ? (r.y - this._elementRect.y) / this._elementRect.height * -2 + 1 : 0, _ = this.dollyDragInverted ? -1 : 1;
        (this._state & R.DOLLY) === R.DOLLY ? (this._dollyInternal(_ * f * Dr, y, h), this._isUserControllingDolly = true) : (this._zoomInternal(_ * f * Dr, y, h), this._isUserControllingZoom = true);
      }
      if ((this._state & R.TOUCH_DOLLY) === R.TOUCH_DOLLY || (this._state & R.TOUCH_ZOOM) === R.TOUCH_ZOOM || (this._state & R.TOUCH_DOLLY_TRUCK) === R.TOUCH_DOLLY_TRUCK || (this._state & R.TOUCH_ZOOM_TRUCK) === R.TOUCH_ZOOM_TRUCK || (this._state & R.TOUCH_DOLLY_OFFSET) === R.TOUCH_DOLLY_OFFSET || (this._state & R.TOUCH_ZOOM_OFFSET) === R.TOUCH_ZOOM_OFFSET || (this._state & R.TOUCH_DOLLY_ROTATE) === R.TOUCH_DOLLY_ROTATE || (this._state & R.TOUCH_ZOOM_ROTATE) === R.TOUCH_ZOOM_ROTATE) {
        const y = Mt.x - this._activePointers[1].clientX, h = Mt.y - this._activePointers[1].clientY, _ = Math.sqrt(y * y + h * h), T = s.y - _;
        s.set(0, _);
        const L = this.dollyToCursor ? (i.x - this._elementRect.x) / this._elementRect.width * 2 - 1 : 0, M = this.dollyToCursor ? (i.y - this._elementRect.y) / this._elementRect.height * -2 + 1 : 0;
        (this._state & R.TOUCH_DOLLY) === R.TOUCH_DOLLY || (this._state & R.TOUCH_DOLLY_ROTATE) === R.TOUCH_DOLLY_ROTATE || (this._state & R.TOUCH_DOLLY_TRUCK) === R.TOUCH_DOLLY_TRUCK || (this._state & R.TOUCH_DOLLY_OFFSET) === R.TOUCH_DOLLY_OFFSET ? (this._dollyInternal(T * Dr, L, M), this._isUserControllingDolly = true) : (this._zoomInternal(T * Dr, L, M), this._isUserControllingZoom = true);
      }
      ((this._state & R.TRUCK) === R.TRUCK || (this._state & R.TOUCH_TRUCK) === R.TOUCH_TRUCK || (this._state & R.TOUCH_DOLLY_TRUCK) === R.TOUCH_DOLLY_TRUCK || (this._state & R.TOUCH_ZOOM_TRUCK) === R.TOUCH_ZOOM_TRUCK) && (this._truckInternal(E, f, false), this._isUserControllingTruck = true), ((this._state & R.OFFSET) === R.OFFSET || (this._state & R.TOUCH_OFFSET) === R.TOUCH_OFFSET || (this._state & R.TOUCH_DOLLY_OFFSET) === R.TOUCH_DOLLY_OFFSET || (this._state & R.TOUCH_ZOOM_OFFSET) === R.TOUCH_ZOOM_OFFSET) && (this._truckInternal(E, f, true), this._isUserControllingOffset = true), this.dispatchEvent({ type: "control" });
    }, b = () => {
      On(this._activePointers, Mt), i.copy(Mt), this._dragNeedsUpdate = false, (this._activePointers.length === 0 || this._activePointers.length === 1 && this._activePointers[0] === this._lockedPointer) && (this._isDragging = false), this._activePointers.length === 0 && this._domElement && (this._domElement.ownerDocument.removeEventListener("pointermove", a, { passive: false }), this._domElement.ownerDocument.removeEventListener("pointerup", c), this.dispatchEvent({ type: "controlend" }));
    };
    this.lockPointer = () => {
      !this._enabled || !this._domElement || (this.cancel(), this._lockedPointer = {
        pointerId: -1,
        clientX: 0,
        clientY: 0,
        deltaX: 0,
        deltaY: 0,
        mouseButton: null
      }, this._activePointers.push(this._lockedPointer), this._domElement.ownerDocument.removeEventListener("pointermove", a, { passive: false }), this._domElement.ownerDocument.removeEventListener("pointerup", c), this._domElement.requestPointerLock(), this._domElement.ownerDocument.addEventListener("pointerlockchange", S), this._domElement.ownerDocument.addEventListener("pointerlockerror", x), this._domElement.ownerDocument.addEventListener("pointermove", a, { passive: false }), this._domElement.ownerDocument.addEventListener("pointerup", c), m());
    }, this.unlockPointer = () => {
      var d, g, E;
      this._lockedPointer !== null && (this._disposePointer(this._lockedPointer), this._lockedPointer = null), (d = this._domElement) === null || d === void 0 || d.ownerDocument.exitPointerLock(), (g = this._domElement) === null || g === void 0 || g.ownerDocument.removeEventListener("pointerlockchange", S), (E = this._domElement) === null || E === void 0 || E.ownerDocument.removeEventListener("pointerlockerror", x), this.cancel();
    };
    const S = () => {
      this._domElement && this._domElement.ownerDocument.pointerLockElement === this._domElement || this.unlockPointer();
    }, x = () => {
      this.unlockPointer();
    };
    this._addAllEventListeners = (d) => {
      this._domElement = d, this._domElement.style.touchAction = "none", this._domElement.style.userSelect = "none", this._domElement.style.webkitUserSelect = "none", this._domElement.addEventListener("pointerdown", o), this._domElement.addEventListener("pointercancel", c), this._domElement.addEventListener("wheel", u, { passive: false }), this._domElement.addEventListener("contextmenu", v);
    }, this._removeAllEventListeners = () => {
      this._domElement && (this._domElement.style.touchAction = "", this._domElement.style.userSelect = "", this._domElement.style.webkitUserSelect = "", this._domElement.removeEventListener("pointerdown", o), this._domElement.removeEventListener("pointercancel", c), this._domElement.removeEventListener("wheel", u, { passive: false }), this._domElement.removeEventListener("contextmenu", v), this._domElement.ownerDocument.removeEventListener("pointermove", a, { passive: false }), this._domElement.ownerDocument.removeEventListener("pointerup", c), this._domElement.ownerDocument.removeEventListener("pointerlockchange", S), this._domElement.ownerDocument.removeEventListener("pointerlockerror", x));
    }, this.cancel = () => {
      this._state !== R.NONE && (this._state = R.NONE, this._activePointers.length = 0, b());
    }, e && this.connect(e), this.update(0);
  }
  /**
   * The camera to be controlled
   * @category Properties
   */
  get camera() {
    return this._camera;
  }
  set camera(t) {
    this._camera = t, this.updateCameraUp(), this._camera.updateProjectionMatrix(), this._updateNearPlaneCorners(), this._needsUpdate = true;
  }
  /**
   * Whether or not the controls are enabled.
   * `false` to disable user dragging/touch-move, but all methods works.
   * @category Properties
   */
  get enabled() {
    return this._enabled;
  }
  set enabled(t) {
    this._enabled = t, this._domElement && (t ? (this._domElement.style.touchAction = "none", this._domElement.style.userSelect = "none", this._domElement.style.webkitUserSelect = "none") : (this.cancel(), this._domElement.style.touchAction = "", this._domElement.style.userSelect = "", this._domElement.style.webkitUserSelect = ""));
  }
  /**
   * Returns `true` if the controls are active updating.
   * readonly value.
   * @category Properties
   */
  get active() {
    return !this._hasRested;
  }
  /**
   * Getter for the current `ACTION`.
   * readonly value.
   * @category Properties
   */
  get currentAction() {
    return this._state;
  }
  /**
   * get/set Current distance.
   * @category Properties
   */
  get distance() {
    return this._spherical.radius;
  }
  set distance(t) {
    this._spherical.radius === t && this._sphericalEnd.radius === t || (this._spherical.radius = t, this._sphericalEnd.radius = t, this._needsUpdate = true);
  }
  // horizontal angle
  /**
   * get/set the azimuth angle (horizontal) in radians.
   * Every 360 degrees turn is added to `.azimuthAngle` value, which is accumulative.
   * @category Properties
   */
  get azimuthAngle() {
    return this._spherical.theta;
  }
  set azimuthAngle(t) {
    this._spherical.theta === t && this._sphericalEnd.theta === t || (this._spherical.theta = t, this._sphericalEnd.theta = t, this._needsUpdate = true);
  }
  // vertical angle
  /**
   * get/set the polar angle (vertical) in radians.
   * @category Properties
   */
  get polarAngle() {
    return this._spherical.phi;
  }
  set polarAngle(t) {
    this._spherical.phi === t && this._sphericalEnd.phi === t || (this._spherical.phi = t, this._sphericalEnd.phi = t, this._needsUpdate = true);
  }
  /**
   * Whether camera position should be enclosed in the boundary or not.
   * @category Properties
   */
  get boundaryEnclosesCamera() {
    return this._boundaryEnclosesCamera;
  }
  set boundaryEnclosesCamera(t) {
    this._boundaryEnclosesCamera = t, this._needsUpdate = true;
  }
  /**
   * Set drag-start, touches and wheel enable area in the domElement.
   * each values are between `0` and `1` inclusive, where `0` is left/top and `1` is right/bottom of the screen.
   * e.g. `{ x: 0, y: 0, width: 1, height: 1 }` for entire area.
   * @category Properties
   */
  set interactiveArea(t) {
    this._interactiveArea.width = qt(t.width, 0, 1), this._interactiveArea.height = qt(t.height, 0, 1), this._interactiveArea.x = qt(t.x, 0, 1 - this._interactiveArea.width), this._interactiveArea.y = qt(t.y, 0, 1 - this._interactiveArea.height);
  }
  /**
   * Adds the specified event listener.
   * Applicable event types (which is `K`) are:
   * | Event name          | Timing |
   * | ------------------- | ------ |
   * | `'controlstart'`    | When the user starts to control the camera via mouse / touches. ¹ |
   * | `'control'`         | When the user controls the camera (dragging). |
   * | `'controlend'`      | When the user ends to control the camera. ¹ |
   * | `'transitionstart'` | When any kind of transition starts, either user control or using a method with `enableTransition = true` |
   * | `'update'`          | When the camera position is updated. |
   * | `'wake'`            | When the camera starts moving. |
   * | `'rest'`            | When the camera movement is below `.restThreshold` ². |
   * | `'sleep'`           | When the camera end moving. |
   *
   * 1. `mouseButtons.wheel` (Mouse wheel control) does not emit `'controlstart'` and `'controlend'`. `mouseButtons.wheel` uses scroll-event internally, and scroll-event happens intermittently. That means "start" and "end" cannot be detected.
   * 2. Due to damping, `sleep` will usually fire a few seconds after the camera _appears_ to have stopped moving. If you want to do something (e.g. enable UI, perform another transition) at the point when the camera has stopped, you probably want the `rest` event. This can be fine tuned using the `.restThreshold` parameter. See the [Rest and Sleep Example](https://yomotsu.github.io/camera-controls/examples/rest-and-sleep.html).
   *
   * e.g.
   * ```
   * cameraControl.addEventListener( 'controlstart', myCallbackFunction );
   * ```
   * @param type event name
   * @param listener handler function
   * @category Methods
   */
  addEventListener(t, e) {
    super.addEventListener(t, e);
  }
  /**
   * Removes the specified event listener
   * e.g.
   * ```
   * cameraControl.addEventListener( 'controlstart', myCallbackFunction );
   * ```
   * @param type event name
   * @param listener handler function
   * @category Methods
   */
  removeEventListener(t, e) {
    super.removeEventListener(t, e);
  }
  /**
   * Rotate azimuthal angle(horizontal) and polar angle(vertical).
   * Every value is added to the current value.
   * @param azimuthAngle Azimuth rotate angle. In radian.
   * @param polarAngle Polar rotate angle. In radian.
   * @param enableTransition Whether to move smoothly or immediately
   * @category Methods
   */
  rotate(t, e, r = false) {
    return this.rotateTo(this._sphericalEnd.theta + t, this._sphericalEnd.phi + e, r);
  }
  /**
   * Rotate azimuthal angle(horizontal) to the given angle and keep the same polar angle(vertical) target.
   *
   * e.g.
   * ```
   * cameraControls.rotateAzimuthTo( 30 * THREE.MathUtils.DEG2RAD, true );
   * ```
   * @param azimuthAngle Azimuth rotate angle. In radian.
   * @param enableTransition Whether to move smoothly or immediately
   * @category Methods
   */
  rotateAzimuthTo(t, e = false) {
    return this.rotateTo(t, this._sphericalEnd.phi, e);
  }
  /**
   * Rotate polar angle(vertical) to the given angle and keep the same azimuthal angle(horizontal) target.
   *
   * e.g.
   * ```
   * cameraControls.rotatePolarTo( 30 * THREE.MathUtils.DEG2RAD, true );
   * ```
   * @param polarAngle Polar rotate angle. In radian.
   * @param enableTransition Whether to move smoothly or immediately
   * @category Methods
   */
  rotatePolarTo(t, e = false) {
    return this.rotateTo(this._sphericalEnd.theta, t, e);
  }
  /**
   * Rotate azimuthal angle(horizontal) and polar angle(vertical) to the given angle.
   * Camera view will rotate over the orbit pivot absolutely:
   *
   * azimuthAngle
   * ```
   *       0º
   *         \
   * 90º -----+----- -90º
   *           \
   *           180º
   * ```
   * | direction | angle                  |
   * | --------- | ---------------------- |
   * | front     | 0º                     |
   * | left      | 90º (`Math.PI / 2`)    |
   * | right     | -90º (`- Math.PI / 2`) |
   * | back      | 180º (`Math.PI`)       |
   *
   * polarAngle
   * ```
   *     180º
   *      |
   *      90º
   *      |
   *      0º
   * ```
   * | direction            | angle                  |
   * | -------------------- | ---------------------- |
   * | top/sky              | 180º (`Math.PI`)       |
   * | horizontal from view | 90º (`Math.PI / 2`)    |
   * | bottom/floor         | 0º                     |
   *
   * @param azimuthAngle Azimuth rotate angle to. In radian.
   * @param polarAngle Polar rotate angle to. In radian.
   * @param enableTransition  Whether to move smoothly or immediately
   * @category Methods
   */
  rotateTo(t, e, r = false) {
    this._isUserControllingRotate = false;
    const i = qt(t, this.minAzimuthAngle, this.maxAzimuthAngle), s = qt(e, this.minPolarAngle, this.maxPolarAngle);
    this._sphericalEnd.theta = i, this._sphericalEnd.phi = s, this._sphericalEnd.makeSafe(), this._needsUpdate = true, r || (this._spherical.theta = this._sphericalEnd.theta, this._spherical.phi = this._sphericalEnd.phi);
    const o = !r || lt(this._spherical.theta, this._sphericalEnd.theta, this.restThreshold) && lt(this._spherical.phi, this._sphericalEnd.phi, this.restThreshold);
    return this._createOnRestPromise(o);
  }
  /**
   * Dolly in/out camera position.
   * @param distance Distance of dollyIn. Negative number for dollyOut.
   * @param enableTransition Whether to move smoothly or immediately.
   * @category Methods
   */
  dolly(t, e = false) {
    return this.dollyTo(this._sphericalEnd.radius - t, e);
  }
  /**
   * Dolly in/out camera position to given distance.
   * @param distance Distance of dolly.
   * @param enableTransition Whether to move smoothly or immediately.
   * @category Methods
   */
  dollyTo(t, e = false) {
    return this._isUserControllingDolly = false, this._lastDollyDirection = Pe.NONE, this._changedDolly = 0, this._dollyToNoClamp(qt(t, this.minDistance, this.maxDistance), e);
  }
  _dollyToNoClamp(t, e = false) {
    const r = this._sphericalEnd.radius;
    if (this.colliderMeshes.length >= 1) {
      const o = this._collisionTest(), a = lt(o, this._spherical.radius);
      if (!(r > t) && a)
        return Promise.resolve();
      this._sphericalEnd.radius = Math.min(t, o);
    } else
      this._sphericalEnd.radius = t;
    this._needsUpdate = true, e || (this._spherical.radius = this._sphericalEnd.radius);
    const s = !e || lt(this._spherical.radius, this._sphericalEnd.radius, this.restThreshold);
    return this._createOnRestPromise(s);
  }
  /**
   * Dolly in, but does not change the distance between the target and the camera, and moves the target position instead.
   * Specify a negative value for dolly out.
   * @param distance Distance of dolly.
   * @param enableTransition Whether to move smoothly or immediately.
   * @category Methods
   */
  dollyInFixed(t, e = false) {
    this._targetEnd.add(this._getCameraDirection(er).multiplyScalar(t)), e || this._target.copy(this._targetEnd);
    const r = !e || lt(this._target.x, this._targetEnd.x, this.restThreshold) && lt(this._target.y, this._targetEnd.y, this.restThreshold) && lt(this._target.z, this._targetEnd.z, this.restThreshold);
    return this._createOnRestPromise(r);
  }
  /**
   * Zoom in/out camera. The value is added to camera zoom.
   * Limits set with `.minZoom` and `.maxZoom`
   * @param zoomStep zoom scale
   * @param enableTransition Whether to move smoothly or immediately
   * @category Methods
   */
  zoom(t, e = false) {
    return this.zoomTo(this._zoomEnd + t, e);
  }
  /**
   * Zoom in/out camera to given scale. The value overwrites camera zoom.
   * Limits set with .minZoom and .maxZoom
   * @param zoom
   * @param enableTransition
   * @category Methods
   */
  zoomTo(t, e = false) {
    this._isUserControllingZoom = false, this._zoomEnd = qt(t, this.minZoom, this.maxZoom), this._needsUpdate = true, e || (this._zoom = this._zoomEnd);
    const r = !e || lt(this._zoom, this._zoomEnd, this.restThreshold);
    return this._changedZoom = 0, this._createOnRestPromise(r);
  }
  /**
   * @deprecated `pan()` has been renamed to `truck()`
   * @category Methods
   */
  pan(t, e, r = false) {
    return console.warn("`pan` has been renamed to `truck`"), this.truck(t, e, r);
  }
  /**
   * Truck and pedestal camera using current azimuthal angle
   * @param x Horizontal translate amount
   * @param y Vertical translate amount
   * @param enableTransition Whether to move smoothly or immediately
   * @category Methods
   */
  truck(t, e, r = false) {
    this._camera.updateMatrix(), Jt.setFromMatrixColumn(this._camera.matrix, 0), te.setFromMatrixColumn(this._camera.matrix, 1), Jt.multiplyScalar(t), te.multiplyScalar(-e);
    const i = Q.copy(Jt).add(te), s = it.copy(this._targetEnd).add(i);
    return this.moveTo(s.x, s.y, s.z, r);
  }
  /**
   * Move forward / backward.
   * @param distance Amount to move forward / backward. Negative value to move backward
   * @param enableTransition Whether to move smoothly or immediately
   * @category Methods
   */
  forward(t, e = false) {
    Q.setFromMatrixColumn(this._camera.matrix, 0), Q.crossVectors(this._camera.up, Q), Q.multiplyScalar(t);
    const r = it.copy(this._targetEnd).add(Q);
    return this.moveTo(r.x, r.y, r.z, e);
  }
  /**
   * Move up / down.
   * @param height Amount to move up / down. Negative value to move down
   * @param enableTransition Whether to move smoothly or immediately
   * @category Methods
   */
  elevate(t, e = false) {
    return Q.copy(this._camera.up).multiplyScalar(t), this.moveTo(this._targetEnd.x + Q.x, this._targetEnd.y + Q.y, this._targetEnd.z + Q.z, e);
  }
  /**
   * Move target position to given point.
   * @param x x coord to move center position
   * @param y y coord to move center position
   * @param z z coord to move center position
   * @param enableTransition Whether to move smoothly or immediately
   * @category Methods
   */
  moveTo(t, e, r, i = false) {
    this._isUserControllingTruck = false;
    const s = Q.set(t, e, r).sub(this._targetEnd);
    this._encloseToBoundary(this._targetEnd, s, this.boundaryFriction), this._needsUpdate = true, i || this._target.copy(this._targetEnd);
    const o = !i || lt(this._target.x, this._targetEnd.x, this.restThreshold) && lt(this._target.y, this._targetEnd.y, this.restThreshold) && lt(this._target.z, this._targetEnd.z, this.restThreshold);
    return this._createOnRestPromise(o);
  }
  /**
   * Look in the given point direction.
   * @param x point x.
   * @param y point y.
   * @param z point z.
   * @param enableTransition Whether to move smoothly or immediately.
   * @returns Transition end promise
   * @category Methods
   */
  lookInDirectionOf(t, e, r, i = false) {
    const a = Q.set(t, e, r).sub(this._targetEnd).normalize().multiplyScalar(-this._sphericalEnd.radius).add(this._targetEnd);
    return this.setPosition(a.x, a.y, a.z, i);
  }
  /**
   * Fit the viewport to the box or the bounding box of the object, using the nearest axis. paddings are in unit.
   * set `cover: true` to fill enter screen.
   * e.g.
   * ```
   * cameraControls.fitToBox( myMesh );
   * ```
   * @param box3OrObject Axis aligned bounding box to fit the view.
   * @param enableTransition Whether to move smoothly or immediately.
   * @param options | `<object>` { cover: boolean, paddingTop: number, paddingLeft: number, paddingBottom: number, paddingRight: number }
   * @returns Transition end promise
   * @category Methods
   */
  fitToBox(t, e, { cover: r = false, paddingLeft: i = 0, paddingRight: s = 0, paddingBottom: o = 0, paddingTop: a = 0 } = {}) {
    const c = [], l = t.isBox3 ? Ue.copy(t) : Ue.setFromObject(t);
    l.isEmpty() && (console.warn("camera-controls: fitTo() cannot be used with an empty box. Aborting"), Promise.resolve());
    const u = ts(this._sphericalEnd.theta, Ji), v = ts(this._sphericalEnd.phi, Ji);
    c.push(this.rotateTo(u, v, e));
    const m = Q.setFromSpherical(this._sphericalEnd).normalize(), p = os.setFromUnitVectors(m, In), b = lt(Math.abs(m.y), 1);
    b && p.multiply(Dn.setFromAxisAngle(Ar, u)), p.multiply(this._yAxisUpSpaceInverse);
    const S = ss.makeEmpty();
    it.copy(l.min).applyQuaternion(p), S.expandByPoint(it), it.copy(l.min).setX(l.max.x).applyQuaternion(p), S.expandByPoint(it), it.copy(l.min).setY(l.max.y).applyQuaternion(p), S.expandByPoint(it), it.copy(l.max).setZ(l.min.z).applyQuaternion(p), S.expandByPoint(it), it.copy(l.min).setZ(l.max.z).applyQuaternion(p), S.expandByPoint(it), it.copy(l.max).setY(l.min.y).applyQuaternion(p), S.expandByPoint(it), it.copy(l.max).setX(l.min.x).applyQuaternion(p), S.expandByPoint(it), it.copy(l.max).applyQuaternion(p), S.expandByPoint(it), S.min.x -= i, S.min.y -= o, S.max.x += s, S.max.y += a, p.setFromUnitVectors(In, m), b && p.premultiply(Dn.invert()), p.premultiply(this._yAxisUpSpace);
    const x = S.getSize(Q), d = S.getCenter(it).applyQuaternion(p);
    if (me(this._camera)) {
      const g = this.getDistanceToFitBox(x.x, x.y, x.z, r);
      c.push(this.moveTo(d.x, d.y, d.z, e)), c.push(this.dollyTo(g, e)), c.push(this.setFocalOffset(0, 0, 0, e));
    } else if (se(this._camera)) {
      const g = this._camera, E = g.right - g.left, f = g.top - g.bottom, y = r ? Math.max(E / x.x, f / x.y) : Math.min(E / x.x, f / x.y);
      c.push(this.moveTo(d.x, d.y, d.z, e)), c.push(this.zoomTo(y, e)), c.push(this.setFocalOffset(0, 0, 0, e));
    }
    return Promise.all(c);
  }
  /**
   * Fit the viewport to the sphere or the bounding sphere of the object.
   * @param sphereOrMesh
   * @param enableTransition
   * @category Methods
   */
  fitToSphere(t, e) {
    const r = [], s = "isObject3D" in t ? Kn.createBoundingSphere(t, Ln) : Ln.copy(t);
    if (r.push(this.moveTo(s.center.x, s.center.y, s.center.z, e)), me(this._camera)) {
      const o = this.getDistanceToFitSphere(s.radius);
      r.push(this.dollyTo(o, e));
    } else if (se(this._camera)) {
      const o = this._camera.right - this._camera.left, a = this._camera.top - this._camera.bottom, c = 2 * s.radius, l = Math.min(o / c, a / c);
      r.push(this.zoomTo(l, e));
    }
    return r.push(this.setFocalOffset(0, 0, 0, e)), Promise.all(r);
  }
  /**
   * Look at the `target` from the `position`.
   * @param positionX
   * @param positionY
   * @param positionZ
   * @param targetX
   * @param targetY
   * @param targetZ
   * @param enableTransition
   * @category Methods
   */
  setLookAt(t, e, r, i, s, o, a = false) {
    this._isUserControllingRotate = false, this._isUserControllingDolly = false, this._isUserControllingTruck = false, this._lastDollyDirection = Pe.NONE, this._changedDolly = 0;
    const c = it.set(i, s, o), l = Q.set(t, e, r);
    this._targetEnd.copy(c), this._sphericalEnd.setFromVector3(l.sub(c).applyQuaternion(this._yAxisUpSpace)), this.normalizeRotations(), this._needsUpdate = true, a || (this._target.copy(this._targetEnd), this._spherical.copy(this._sphericalEnd));
    const u = !a || lt(this._target.x, this._targetEnd.x, this.restThreshold) && lt(this._target.y, this._targetEnd.y, this.restThreshold) && lt(this._target.z, this._targetEnd.z, this.restThreshold) && lt(this._spherical.theta, this._sphericalEnd.theta, this.restThreshold) && lt(this._spherical.phi, this._sphericalEnd.phi, this.restThreshold) && lt(this._spherical.radius, this._sphericalEnd.radius, this.restThreshold);
    return this._createOnRestPromise(u);
  }
  /**
   * Similar to setLookAt, but it interpolates between two states.
   * @param positionAX
   * @param positionAY
   * @param positionAZ
   * @param targetAX
   * @param targetAY
   * @param targetAZ
   * @param positionBX
   * @param positionBY
   * @param positionBZ
   * @param targetBX
   * @param targetBY
   * @param targetBZ
   * @param t
   * @param enableTransition
   * @category Methods
   */
  lerpLookAt(t, e, r, i, s, o, a, c, l, u, v, m, p, b = false) {
    this._isUserControllingRotate = false, this._isUserControllingDolly = false, this._isUserControllingTruck = false, this._lastDollyDirection = Pe.NONE, this._changedDolly = 0;
    const S = Q.set(i, s, o), x = it.set(t, e, r);
    Bt.setFromVector3(x.sub(S).applyQuaternion(this._yAxisUpSpace));
    const d = ke.set(u, v, m), g = it.set(a, c, l);
    rr.setFromVector3(g.sub(d).applyQuaternion(this._yAxisUpSpace)), this._targetEnd.copy(S.lerp(d, p));
    const E = rr.theta - Bt.theta, f = rr.phi - Bt.phi, y = rr.radius - Bt.radius;
    this._sphericalEnd.set(Bt.radius + y * p, Bt.phi + f * p, Bt.theta + E * p), this.normalizeRotations(), this._needsUpdate = true, b || (this._target.copy(this._targetEnd), this._spherical.copy(this._sphericalEnd));
    const h = !b || lt(this._target.x, this._targetEnd.x, this.restThreshold) && lt(this._target.y, this._targetEnd.y, this.restThreshold) && lt(this._target.z, this._targetEnd.z, this.restThreshold) && lt(this._spherical.theta, this._sphericalEnd.theta, this.restThreshold) && lt(this._spherical.phi, this._sphericalEnd.phi, this.restThreshold) && lt(this._spherical.radius, this._sphericalEnd.radius, this.restThreshold);
    return this._createOnRestPromise(h);
  }
  /**
   * Set angle and distance by given position.
   * An alias of `setLookAt()`, without target change. Thus keep gazing at the current target
   * @param positionX
   * @param positionY
   * @param positionZ
   * @param enableTransition
   * @category Methods
   */
  setPosition(t, e, r, i = false) {
    return this.setLookAt(t, e, r, this._targetEnd.x, this._targetEnd.y, this._targetEnd.z, i);
  }
  /**
   * Set the target position where gaze at.
   * An alias of `setLookAt()`, without position change. Thus keep the same position.
   * @param targetX
   * @param targetY
   * @param targetZ
   * @param enableTransition
   * @category Methods
   */
  setTarget(t, e, r, i = false) {
    const s = this.getPosition(Q), o = this.setLookAt(s.x, s.y, s.z, t, e, r, i);
    return this._sphericalEnd.phi = qt(this._sphericalEnd.phi, this.minPolarAngle, this.maxPolarAngle), o;
  }
  /**
   * Set focal offset using the screen parallel coordinates. z doesn't affect in Orthographic as with Dolly.
   * @param x
   * @param y
   * @param z
   * @param enableTransition
   * @category Methods
   */
  setFocalOffset(t, e, r, i = false) {
    this._isUserControllingOffset = false, this._focalOffsetEnd.set(t, e, r), this._needsUpdate = true, i || this._focalOffset.copy(this._focalOffsetEnd);
    const s = !i || lt(this._focalOffset.x, this._focalOffsetEnd.x, this.restThreshold) && lt(this._focalOffset.y, this._focalOffsetEnd.y, this.restThreshold) && lt(this._focalOffset.z, this._focalOffsetEnd.z, this.restThreshold);
    return this._createOnRestPromise(s);
  }
  /**
   * Set orbit point without moving the camera.
   * SHOULD NOT RUN DURING ANIMATIONS. `setOrbitPoint()` will immediately fix the positions.
   * @param targetX
   * @param targetY
   * @param targetZ
   * @category Methods
   */
  setOrbitPoint(t, e, r) {
    this._camera.updateMatrixWorld(), Jt.setFromMatrixColumn(this._camera.matrixWorldInverse, 0), te.setFromMatrixColumn(this._camera.matrixWorldInverse, 1), _e.setFromMatrixColumn(this._camera.matrixWorldInverse, 2);
    const i = Q.set(t, e, r), s = i.distanceTo(this._camera.position), o = i.sub(this._camera.position);
    Jt.multiplyScalar(o.x), te.multiplyScalar(o.y), _e.multiplyScalar(o.z), Q.copy(Jt).add(te).add(_e), Q.z = Q.z + s, this.dollyTo(s, false), this.setFocalOffset(-Q.x, Q.y, -Q.z, false), this.moveTo(t, e, r, false);
  }
  /**
   * Set the boundary box that encloses the target of the camera. box3 is in THREE.Box3
   * @param box3
   * @category Methods
   */
  setBoundary(t) {
    if (!t) {
      this._boundary.min.set(-1 / 0, -1 / 0, -1 / 0), this._boundary.max.set(1 / 0, 1 / 0, 1 / 0), this._needsUpdate = true;
      return;
    }
    this._boundary.copy(t), this._boundary.clampPoint(this._targetEnd, this._targetEnd), this._needsUpdate = true;
  }
  /**
   * Set (or unset) the current viewport.
   * Set this when you want to use renderer viewport and .dollyToCursor feature at the same time.
   * @param viewportOrX
   * @param y
   * @param width
   * @param height
   * @category Methods
   */
  setViewport(t, e, r, i) {
    if (t === null) {
      this._viewport = null;
      return;
    }
    this._viewport = this._viewport || new K.Vector4(), typeof t == "number" ? this._viewport.set(t, e, r, i) : this._viewport.copy(t);
  }
  /**
   * Calculate the distance to fit the box.
   * @param width box width
   * @param height box height
   * @param depth box depth
   * @returns distance
   * @category Methods
   */
  getDistanceToFitBox(t, e, r, i = false) {
    if (Tn(this._camera, "getDistanceToFitBox"))
      return this._spherical.radius;
    const s = t / e, o = this._camera.getEffectiveFOV() * $e, a = this._camera.aspect;
    return ((i ? s > a : s < a) ? e : t / a) * 0.5 / Math.tan(o * 0.5) + r * 0.5;
  }
  /**
   * Calculate the distance to fit the sphere.
   * @param radius sphere radius
   * @returns distance
   * @category Methods
   */
  getDistanceToFitSphere(t) {
    if (Tn(this._camera, "getDistanceToFitSphere"))
      return this._spherical.radius;
    const e = this._camera.getEffectiveFOV() * $e, r = Math.atan(Math.tan(e * 0.5) * this._camera.aspect) * 2, i = 1 < this._camera.aspect ? e : r;
    return t / Math.sin(i * 0.5);
  }
  /**
   * Returns the orbit center position, where the camera looking at.
   * @param out The receiving Vector3 instance to copy the result
   * @param receiveEndValue Whether receive the transition end coords or current. default is `true`
   * @category Methods
   */
  getTarget(t, e = true) {
    return (t && t.isVector3 ? t : new K.Vector3()).copy(e ? this._targetEnd : this._target);
  }
  /**
   * Returns the camera position.
   * @param out The receiving Vector3 instance to copy the result
   * @param receiveEndValue Whether receive the transition end coords or current. default is `true`
   * @category Methods
   */
  getPosition(t, e = true) {
    return (t && t.isVector3 ? t : new K.Vector3()).setFromSpherical(e ? this._sphericalEnd : this._spherical).applyQuaternion(this._yAxisUpSpaceInverse).add(e ? this._targetEnd : this._target);
  }
  /**
   * Returns the spherical coordinates of the orbit.
   * @param out The receiving Spherical instance to copy the result
   * @param receiveEndValue Whether receive the transition end coords or current. default is `true`
   * @category Methods
   */
  getSpherical(t, e = true) {
    return (t || new K.Spherical()).copy(e ? this._sphericalEnd : this._spherical);
  }
  /**
   * Returns the focal offset, which is how much the camera appears to be translated in screen parallel coordinates.
   * @param out The receiving Vector3 instance to copy the result
   * @param receiveEndValue Whether receive the transition end coords or current. default is `true`
   * @category Methods
   */
  getFocalOffset(t, e = true) {
    return (t && t.isVector3 ? t : new K.Vector3()).copy(e ? this._focalOffsetEnd : this._focalOffset);
  }
  /**
   * Normalize camera azimuth angle rotation between 0 and 360 degrees.
   * @category Methods
   */
  normalizeRotations() {
    this._sphericalEnd.theta = this._sphericalEnd.theta % Me, this._sphericalEnd.theta < 0 && (this._sphericalEnd.theta += Me), this._spherical.theta += Me * Math.round((this._sphericalEnd.theta - this._spherical.theta) / Me);
  }
  /**
   * stop all transitions.
   */
  stop() {
    this._focalOffset.copy(this._focalOffsetEnd), this._target.copy(this._targetEnd), this._spherical.copy(this._sphericalEnd), this._zoom = this._zoomEnd;
  }
  /**
   * Reset all rotation and position to defaults.
   * @param enableTransition
   * @category Methods
   */
  reset(t = false) {
    if (!lt(this._camera.up.x, this._cameraUp0.x) || !lt(this._camera.up.y, this._cameraUp0.y) || !lt(this._camera.up.z, this._cameraUp0.z)) {
      this._camera.up.copy(this._cameraUp0);
      const r = this.getPosition(Q);
      this.updateCameraUp(), this.setPosition(r.x, r.y, r.z);
    }
    const e = [
      this.setLookAt(this._position0.x, this._position0.y, this._position0.z, this._target0.x, this._target0.y, this._target0.z, t),
      this.setFocalOffset(this._focalOffset0.x, this._focalOffset0.y, this._focalOffset0.z, t),
      this.zoomTo(this._zoom0, t)
    ];
    return Promise.all(e);
  }
  /**
   * Set current camera position as the default position.
   * @category Methods
   */
  saveState() {
    this._cameraUp0.copy(this._camera.up), this.getTarget(this._target0), this.getPosition(this._position0), this._zoom0 = this._zoom, this._focalOffset0.copy(this._focalOffset);
  }
  /**
   * Sync camera-up direction.
   * When camera-up vector is changed, `.updateCameraUp()` must be called.
   * @category Methods
   */
  updateCameraUp() {
    this._yAxisUpSpace.setFromUnitVectors(this._camera.up, Ar), this._yAxisUpSpaceInverse.copy(this._yAxisUpSpace).invert();
  }
  /**
   * Apply current camera-up direction to the camera.
   * The orbit system will be re-initialized with the current position.
   * @category Methods
   */
  applyCameraUp() {
    const t = Q.subVectors(this._target, this._camera.position).normalize(), e = it.crossVectors(t, this._camera.up);
    this._camera.up.crossVectors(e, t).normalize(), this._camera.updateMatrixWorld();
    const r = this.getPosition(Q);
    this.updateCameraUp(), this.setPosition(r.x, r.y, r.z);
  }
  /**
   * Update camera position and directions.
   * This should be called in your tick loop every time, and returns true if re-rendering is needed.
   * @param delta
   * @returns updated
   * @category Methods
   */
  update(t) {
    const e = this._sphericalEnd.theta - this._spherical.theta, r = this._sphericalEnd.phi - this._spherical.phi, i = this._sphericalEnd.radius - this._spherical.radius, s = ns.subVectors(this._targetEnd, this._target), o = is.subVectors(this._focalOffsetEnd, this._focalOffset), a = this._zoomEnd - this._zoom;
    if (ht(e))
      this._thetaVelocity.value = 0, this._spherical.theta = this._sphericalEnd.theta;
    else {
      const v = this._isUserControllingRotate ? this.draggingSmoothTime : this.smoothTime;
      this._spherical.theta = Lr(this._spherical.theta, this._sphericalEnd.theta, this._thetaVelocity, v, 1 / 0, t), this._needsUpdate = true;
    }
    if (ht(r))
      this._phiVelocity.value = 0, this._spherical.phi = this._sphericalEnd.phi;
    else {
      const v = this._isUserControllingRotate ? this.draggingSmoothTime : this.smoothTime;
      this._spherical.phi = Lr(this._spherical.phi, this._sphericalEnd.phi, this._phiVelocity, v, 1 / 0, t), this._needsUpdate = true;
    }
    if (ht(i))
      this._radiusVelocity.value = 0, this._spherical.radius = this._sphericalEnd.radius;
    else {
      const v = this._isUserControllingDolly ? this.draggingSmoothTime : this.smoothTime;
      this._spherical.radius = Lr(this._spherical.radius, this._sphericalEnd.radius, this._radiusVelocity, v, this.maxSpeed, t), this._needsUpdate = true;
    }
    if (ht(s.x) && ht(s.y) && ht(s.z))
      this._targetVelocity.set(0, 0, 0), this._target.copy(this._targetEnd);
    else {
      const v = this._isUserControllingTruck ? this.draggingSmoothTime : this.smoothTime;
      es(this._target, this._targetEnd, this._targetVelocity, v, this.maxSpeed, t, this._target), this._needsUpdate = true;
    }
    if (ht(o.x) && ht(o.y) && ht(o.z))
      this._focalOffsetVelocity.set(0, 0, 0), this._focalOffset.copy(this._focalOffsetEnd);
    else {
      const v = this._isUserControllingOffset ? this.draggingSmoothTime : this.smoothTime;
      es(this._focalOffset, this._focalOffsetEnd, this._focalOffsetVelocity, v, this.maxSpeed, t, this._focalOffset), this._needsUpdate = true;
    }
    if (ht(a))
      this._zoomVelocity.value = 0, this._zoom = this._zoomEnd;
    else {
      const v = this._isUserControllingZoom ? this.draggingSmoothTime : this.smoothTime;
      this._zoom = Lr(this._zoom, this._zoomEnd, this._zoomVelocity, v, 1 / 0, t);
    }
    if (this.dollyToCursor) {
      if (me(this._camera) && this._changedDolly !== 0) {
        const v = this._spherical.radius - this._lastDistance, m = this._camera, p = this._getCameraDirection(er), b = Q.copy(p).cross(m.up).normalize();
        b.lengthSq() === 0 && (b.x = 1);
        const S = it.crossVectors(b, p), x = this._sphericalEnd.radius * Math.tan(m.getEffectiveFOV() * $e * 0.5), g = (this._sphericalEnd.radius - v - this._sphericalEnd.radius) / this._sphericalEnd.radius, E = ke.copy(this._targetEnd).add(b.multiplyScalar(this._dollyControlCoord.x * x * m.aspect)).add(S.multiplyScalar(this._dollyControlCoord.y * x)), f = Q.copy(this._targetEnd).lerp(E, g), y = this._lastDollyDirection === Pe.IN && this._spherical.radius <= this.minDistance, h = this._lastDollyDirection === Pe.OUT && this.maxDistance <= this._spherical.radius;
        if (this.infinityDolly && (y || h)) {
          this._sphericalEnd.radius -= v, this._spherical.radius -= v;
          const T = it.copy(p).multiplyScalar(-v);
          f.add(T);
        }
        this._boundary.clampPoint(f, f);
        const _ = it.subVectors(f, this._targetEnd);
        this._targetEnd.copy(f), this._target.add(_), this._changedDolly -= v, ht(this._changedDolly) && (this._changedDolly = 0);
      } else if (se(this._camera) && this._changedZoom !== 0) {
        const v = this._zoom - this._lastZoom, m = this._camera, p = Q.set(this._dollyControlCoord.x, this._dollyControlCoord.y, (m.near + m.far) / (m.near - m.far)).unproject(m), b = it.set(0, 0, -1).applyQuaternion(m.quaternion), S = ke.copy(p).add(b.multiplyScalar(-p.dot(m.up))), d = -(this._zoom - v - this._zoom) / this._zoom, g = this._getCameraDirection(er), E = this._targetEnd.dot(g), f = Q.copy(this._targetEnd).lerp(S, d), y = f.dot(g), h = g.multiplyScalar(y - E);
        f.sub(h), this._boundary.clampPoint(f, f);
        const _ = it.subVectors(f, this._targetEnd);
        this._targetEnd.copy(f), this._target.add(_), this._changedZoom -= v, ht(this._changedZoom) && (this._changedZoom = 0);
      }
    }
    this._camera.zoom !== this._zoom && (this._camera.zoom = this._zoom, this._camera.updateProjectionMatrix(), this._updateNearPlaneCorners(), this._needsUpdate = true), this._dragNeedsUpdate = true;
    const c = this._collisionTest();
    this._spherical.radius = Math.min(this._spherical.radius, c), this._spherical.makeSafe(), this._camera.position.setFromSpherical(this._spherical).applyQuaternion(this._yAxisUpSpaceInverse).add(this._target), this._camera.lookAt(this._target), (!ht(this._focalOffset.x) || !ht(this._focalOffset.y) || !ht(this._focalOffset.z)) && (this._camera.updateMatrixWorld(), Jt.setFromMatrixColumn(this._camera.matrix, 0), te.setFromMatrixColumn(this._camera.matrix, 1), _e.setFromMatrixColumn(this._camera.matrix, 2), Jt.multiplyScalar(this._focalOffset.x), te.multiplyScalar(-this._focalOffset.y), _e.multiplyScalar(this._focalOffset.z), Q.copy(Jt).add(te).add(_e), this._camera.position.add(Q)), this._boundaryEnclosesCamera && this._encloseToBoundary(this._camera.position.copy(this._target), Q.setFromSpherical(this._spherical).applyQuaternion(this._yAxisUpSpaceInverse), 1);
    const u = this._needsUpdate;
    return u && !this._updatedLastTime ? (this._hasRested = false, this.dispatchEvent({ type: "wake" }), this.dispatchEvent({ type: "update" })) : u ? (this.dispatchEvent({ type: "update" }), ht(e, this.restThreshold) && ht(r, this.restThreshold) && ht(i, this.restThreshold) && ht(s.x, this.restThreshold) && ht(s.y, this.restThreshold) && ht(s.z, this.restThreshold) && ht(o.x, this.restThreshold) && ht(o.y, this.restThreshold) && ht(o.z, this.restThreshold) && ht(a, this.restThreshold) && !this._hasRested && (this._hasRested = true, this.dispatchEvent({ type: "rest" }))) : !u && this._updatedLastTime && this.dispatchEvent({ type: "sleep" }), this._lastDistance = this._spherical.radius, this._lastZoom = this._zoom, this._updatedLastTime = u, this._needsUpdate = false, u;
  }
  /**
   * Get all state in JSON string
   * @category Methods
   */
  toJSON() {
    return JSON.stringify({
      enabled: this._enabled,
      minDistance: this.minDistance,
      maxDistance: Je(this.maxDistance),
      minZoom: this.minZoom,
      maxZoom: Je(this.maxZoom),
      minPolarAngle: this.minPolarAngle,
      maxPolarAngle: Je(this.maxPolarAngle),
      minAzimuthAngle: Je(this.minAzimuthAngle),
      maxAzimuthAngle: Je(this.maxAzimuthAngle),
      smoothTime: this.smoothTime,
      draggingSmoothTime: this.draggingSmoothTime,
      dollySpeed: this.dollySpeed,
      truckSpeed: this.truckSpeed,
      dollyToCursor: this.dollyToCursor,
      verticalDragToForward: this.verticalDragToForward,
      target: this._targetEnd.toArray(),
      position: Q.setFromSpherical(this._sphericalEnd).add(this._targetEnd).toArray(),
      zoom: this._zoomEnd,
      focalOffset: this._focalOffsetEnd.toArray(),
      target0: this._target0.toArray(),
      position0: this._position0.toArray(),
      zoom0: this._zoom0,
      focalOffset0: this._focalOffset0.toArray()
    });
  }
  /**
   * Reproduce the control state with JSON. enableTransition is where anim or not in a boolean.
   * @param json
   * @param enableTransition
   * @category Methods
   */
  fromJSON(t, e = false) {
    const r = JSON.parse(t);
    this.enabled = r.enabled, this.minDistance = r.minDistance, this.maxDistance = tr(r.maxDistance), this.minZoom = r.minZoom, this.maxZoom = tr(r.maxZoom), this.minPolarAngle = r.minPolarAngle, this.maxPolarAngle = tr(r.maxPolarAngle), this.minAzimuthAngle = tr(r.minAzimuthAngle), this.maxAzimuthAngle = tr(r.maxAzimuthAngle), this.smoothTime = r.smoothTime, this.draggingSmoothTime = r.draggingSmoothTime, this.dollySpeed = r.dollySpeed, this.truckSpeed = r.truckSpeed, this.dollyToCursor = r.dollyToCursor, this.verticalDragToForward = r.verticalDragToForward, this._target0.fromArray(r.target0), this._position0.fromArray(r.position0), this._zoom0 = r.zoom0, this._focalOffset0.fromArray(r.focalOffset0), this.moveTo(r.target[0], r.target[1], r.target[2], e), Bt.setFromVector3(Q.fromArray(r.position).sub(this._targetEnd).applyQuaternion(this._yAxisUpSpace)), this.rotateTo(Bt.theta, Bt.phi, e), this.dollyTo(Bt.radius, e), this.zoomTo(r.zoom, e), this.setFocalOffset(r.focalOffset[0], r.focalOffset[1], r.focalOffset[2], e), this._needsUpdate = true;
  }
  /**
   * Attach all internal event handlers to enable drag control.
   * @category Methods
   */
  connect(t) {
    if (this._domElement) {
      console.warn("camera-controls is already connected.");
      return;
    }
    t.setAttribute("data-camera-controls-version", yc), this._addAllEventListeners(t), this._getClientRect(this._elementRect);
  }
  /**
   * Detach all internal event handlers to disable drag control.
   */
  disconnect() {
    this.cancel(), this._removeAllEventListeners(), this._domElement && (this._domElement.removeAttribute("data-camera-controls-version"), this._domElement = void 0);
  }
  /**
   * Dispose the cameraControls instance itself, remove all eventListeners.
   * @category Methods
   */
  dispose() {
    this.removeAllEventListeners(), this.disconnect();
  }
  // it's okay to expose public though
  _getTargetDirection(t) {
    return t.setFromSpherical(this._spherical).divideScalar(this._spherical.radius).applyQuaternion(this._yAxisUpSpaceInverse);
  }
  // it's okay to expose public though
  _getCameraDirection(t) {
    return this._getTargetDirection(t).negate();
  }
  _findPointerById(t) {
    return this._activePointers.find((e) => e.pointerId === t);
  }
  _findPointerByMouseButton(t) {
    return this._activePointers.find((e) => e.mouseButton === t);
  }
  _disposePointer(t) {
    this._activePointers.splice(this._activePointers.indexOf(t), 1);
  }
  _encloseToBoundary(t, e, r) {
    const i = e.lengthSq();
    if (i === 0)
      return t;
    const s = it.copy(e).add(t), a = this._boundary.clampPoint(s, ke).sub(s), c = a.lengthSq();
    if (c === 0)
      return t.add(e);
    if (c === i)
      return t;
    if (r === 0)
      return t.add(e).add(a);
    {
      const l = 1 + r * c / e.dot(a);
      return t.add(it.copy(e).multiplyScalar(l)).add(a.multiplyScalar(1 - r));
    }
  }
  _updateNearPlaneCorners() {
    if (me(this._camera)) {
      const t = this._camera, e = t.near, r = t.getEffectiveFOV() * $e, i = Math.tan(r * 0.5) * e, s = i * t.aspect;
      this._nearPlaneCorners[0].set(-s, -i, 0), this._nearPlaneCorners[1].set(s, -i, 0), this._nearPlaneCorners[2].set(s, i, 0), this._nearPlaneCorners[3].set(-s, i, 0);
    } else if (se(this._camera)) {
      const t = this._camera, e = 1 / t.zoom, r = t.left * e, i = t.right * e, s = t.top * e, o = t.bottom * e;
      this._nearPlaneCorners[0].set(r, s, 0), this._nearPlaneCorners[1].set(i, s, 0), this._nearPlaneCorners[2].set(i, o, 0), this._nearPlaneCorners[3].set(r, o, 0);
    }
  }
  // lateUpdate
  _collisionTest() {
    let t = 1 / 0;
    if (!(this.colliderMeshes.length >= 1) || Tn(this._camera, "_collisionTest"))
      return t;
    const r = this._getTargetDirection(er);
    An.lookAt(rs, r, this._camera.up);
    for (let i = 0; i < 4; i++) {
      const s = it.copy(this._nearPlaneCorners[i]);
      s.applyMatrix4(An);
      const o = ke.addVectors(this._target, s);
      Rr.set(o, r), Rr.far = this._spherical.radius + 1;
      const a = Rr.intersectObjects(this.colliderMeshes);
      a.length !== 0 && a[0].distance < t && (t = a[0].distance);
    }
    return t;
  }
  /**
   * Get its client rect and package into given `DOMRect` .
   */
  _getClientRect(t) {
    if (!this._domElement)
      return;
    const e = this._domElement.getBoundingClientRect();
    return t.x = e.left, t.y = e.top, this._viewport ? (t.x += this._viewport.x, t.y += e.height - this._viewport.w - this._viewport.y, t.width = this._viewport.z, t.height = this._viewport.w) : (t.width = e.width, t.height = e.height), t;
  }
  _createOnRestPromise(t) {
    return t ? Promise.resolve() : (this._hasRested = false, this.dispatchEvent({ type: "transitionstart" }), new Promise((e) => {
      const r = () => {
        this.removeEventListener("rest", r), e();
      };
      this.addEventListener("rest", r);
    }));
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  _addAllEventListeners(t) {
  }
  _removeAllEventListeners() {
  }
  /**
   * backward compatible
   * @deprecated use smoothTime (in seconds) instead
   * @category Properties
   */
  get dampingFactor() {
    return console.warn(".dampingFactor has been deprecated. use smoothTime (in seconds) instead."), 0;
  }
  /**
   * backward compatible
   * @deprecated use smoothTime (in seconds) instead
   * @category Properties
   */
  set dampingFactor(t) {
    console.warn(".dampingFactor has been deprecated. use smoothTime (in seconds) instead.");
  }
  /**
   * backward compatible
   * @deprecated use draggingSmoothTime (in seconds) instead
   * @category Properties
   */
  get draggingDampingFactor() {
    return console.warn(".draggingDampingFactor has been deprecated. use draggingSmoothTime (in seconds) instead."), 0;
  }
  /**
   * backward compatible
   * @deprecated use draggingSmoothTime (in seconds) instead
   * @category Properties
   */
  set draggingDampingFactor(t) {
    console.warn(".draggingDampingFactor has been deprecated. use draggingSmoothTime (in seconds) instead.");
  }
  static createBoundingSphere(t, e = new K.Sphere()) {
    const r = e, i = r.center;
    Ue.makeEmpty(), t.traverseVisible((o) => {
      o.isMesh && Ue.expandByObject(o);
    }), Ue.getCenter(i);
    let s = 0;
    return t.traverseVisible((o) => {
      if (!o.isMesh)
        return;
      const a = o, c = a.geometry.clone();
      c.applyMatrix4(a.matrixWorld);
      const u = c.attributes.position;
      for (let v = 0, m = u.count; v < m; v++)
        Q.fromBufferAttribute(u, v), s = Math.max(s, i.distanceToSquared(Q));
    }), r.radius = Math.sqrt(s), r;
  }
};
var Sc = (0, import_react.forwardRef)((n, t) => {
  (0, import_react.useMemo)(() => {
    const y = {
      Box3,
      MathUtils: {
        clamp: MathUtils.clamp
      },
      Matrix4,
      Quaternion,
      Raycaster,
      Sphere,
      Spherical,
      Vector2,
      Vector3,
      Vector4
    };
    Vr.install({
      THREE: y
    }), extend({
      CameraControlsImpl: Vr
    });
  }, []);
  const {
    camera: e,
    domElement: r,
    makeDefault: i,
    onStart: s,
    onEnd: o,
    onChange: a,
    regress: c,
    ...l
  } = n, u = useThree((y) => y.camera), v = useThree((y) => y.gl), m = useThree((y) => y.invalidate), p = useThree((y) => y.events), b = useThree((y) => y.setEvents), S = useThree((y) => y.set), x = useThree((y) => y.get), d = useThree((y) => y.performance), g = e || u, E = r || p.connected || v.domElement, f = (0, import_react.useMemo)(() => new Vr(g), [g]);
  return useFrame((y, h) => {
    f.enabled && f.update(h);
  }, -1), (0, import_react.useEffect)(() => (f.connect(E), () => void f.disconnect()), [E, f]), (0, import_react.useEffect)(() => {
    const y = (T) => {
      m(), c && d.regress(), a && a(T);
    }, h = (T) => {
      s && s(T);
    }, _ = (T) => {
      o && o(T);
    };
    return f.addEventListener("update", y), f.addEventListener("controlstart", h), f.addEventListener("controlend", _), f.addEventListener("control", y), f.addEventListener("transitionstart", y), f.addEventListener("wake", y), () => {
      f.removeEventListener("update", y), f.removeEventListener("controlstart", h), f.removeEventListener("controlend", _), f.removeEventListener("control", y), f.removeEventListener("transitionstart", y), f.removeEventListener("wake", y);
    };
  }, [f, s, o, m, b, c, a]), (0, import_react.useEffect)(() => {
    if (i) {
      const y = x().controls;
      return S({
        controls: f
      }), () => S({
        controls: y
      });
    }
  }, [i, f]), j.createElement("primitive", we({
    ref: t,
    object: f
  }, l));
});
function bc({
  defaultScene: n,
  defaultCamera: t,
  renderPriority: e = 1
}) {
  const {
    gl: r,
    scene: i,
    camera: s
  } = useThree();
  let o;
  return useFrame(() => {
    o = r.autoClear, e === 1 && (r.autoClear = true, r.render(n, t)), r.autoClear = false, r.clearDepth(), r.render(i, s), r.autoClear = o;
  }, e), j.createElement("group", {
    onPointerOver: () => null
  });
}
function wc({
  children: n,
  renderPriority: t = 1
}) {
  const {
    scene: e,
    camera: r
  } = useThree(), [i] = j.useState(() => new Scene());
  return j.createElement(j.Fragment, null, createPortal(j.createElement(j.Fragment, null, n, j.createElement(bc, {
    defaultScene: e,
    defaultCamera: r,
    renderPriority: t
  })), i, {
    events: {
      priority: t + 1
    }
  }));
}
var xc = j.createContext({});
var Oc = 2 * Math.PI;
var as = new Object3D();
var ls = new Matrix4();
var [Fe, Rn] = [new Quaternion(), new Quaternion()];
var cs = new Vector3();
var us = new Vector3();
var Tc = (n) => "minPolarAngle" in n;
var hs = (n) => "getTarget" in n;
var Cc = ({
  alignment: n = "bottom-right",
  margin: t = [80, 80],
  renderPriority: e = 1,
  onUpdate: r,
  onTarget: i,
  children: s
}) => {
  const o = useThree((h) => h.size), a = useThree((h) => h.camera), c = useThree((h) => h.controls), l = useThree((h) => h.invalidate), u = j.useRef(null), v = j.useRef(null), m = j.useRef(false), p = j.useRef(0), b = j.useRef(new Vector3(0, 0, 0)), S = j.useRef(new Vector3(0, 0, 0));
  j.useEffect(() => {
    S.current.copy(a.up);
  }, [a]);
  const x = j.useCallback((h) => {
    m.current = true, (c || i) && (b.current = (i == null ? void 0 : i()) || (hs(c) ? c.getTarget(b.current) : c == null ? void 0 : c.target)), p.current = a.position.distanceTo(cs), Fe.copy(a.quaternion), us.copy(h).multiplyScalar(p.current).add(cs), as.lookAt(us), Rn.copy(as.quaternion), l();
  }, [c, a, i, l]);
  useFrame((h, _) => {
    if (v.current && u.current) {
      var T;
      if (m.current)
        if (Fe.angleTo(Rn) < 0.01)
          m.current = false, Tc(c) && a.up.copy(S.current);
        else {
          const L = _ * Oc;
          Fe.rotateTowards(Rn, L), a.position.set(0, 0, 1).applyQuaternion(Fe).multiplyScalar(p.current).add(b.current), a.up.set(0, 1, 0).applyQuaternion(Fe).normalize(), a.quaternion.copy(Fe), hs(c) && c.setPosition(a.position.x, a.position.y, a.position.z), r ? r() : c && c.update(_), l();
        }
      ls.copy(a.matrix).invert(), (T = u.current) == null || T.quaternion.setFromRotationMatrix(ls);
    }
  });
  const d = j.useMemo(() => ({
    tweenCamera: x
  }), [x]), [g, E] = t, f = n.endsWith("-center") ? 0 : n.endsWith("-left") ? -o.width / 2 + g : o.width / 2 - g, y = n.startsWith("center-") ? 0 : n.startsWith("top-") ? o.height / 2 - E : -o.height / 2 + E;
  return j.createElement(wc, {
    renderPriority: e
  }, j.createElement(xc.Provider, {
    value: d
  }, j.createElement(vc, {
    makeDefault: true,
    ref: v,
    position: [0, 0, 200]
  }), j.createElement("group", {
    ref: u,
    position: [f, y, 0]
  }, s)));
};
var Ic = dc(
  {
    cellSize: 0.5,
    sectionSize: 1,
    fadeDistance: 100,
    fadeStrength: 1,
    fadeFrom: 1,
    cellThickness: 0.5,
    sectionThickness: 1,
    cellColor: new Color(),
    sectionColor: new Color(),
    infiniteGrid: false,
    followCamera: false,
    worldCamProjPosition: new Vector3(),
    worldPlanePosition: new Vector3()
  },
  /* glsl */
  `
    varying vec3 localPosition;
    varying vec4 worldPosition;

    uniform vec3 worldCamProjPosition;
    uniform vec3 worldPlanePosition;
    uniform float fadeDistance;
    uniform bool infiniteGrid;
    uniform bool followCamera;

    void main() {
      localPosition = position.xzy;
      if (infiniteGrid) localPosition *= 1.0 + fadeDistance;
      
      worldPosition = modelMatrix * vec4(localPosition, 1.0);
      if (followCamera) {
        worldPosition.xyz += (worldCamProjPosition - worldPlanePosition);
        localPosition = (inverse(modelMatrix) * worldPosition).xyz;
      }

      gl_Position = projectionMatrix * viewMatrix * worldPosition;
    }
  `,
  /* glsl */
  `
    varying vec3 localPosition;
    varying vec4 worldPosition;

    uniform vec3 worldCamProjPosition;
    uniform float cellSize;
    uniform float sectionSize;
    uniform vec3 cellColor;
    uniform vec3 sectionColor;
    uniform float fadeDistance;
    uniform float fadeStrength;
    uniform float fadeFrom;
    uniform float cellThickness;
    uniform float sectionThickness;

    float getGrid(float size, float thickness) {
      vec2 r = localPosition.xz / size;
      vec2 grid = abs(fract(r - 0.5) - 0.5) / fwidth(r);
      float line = min(grid.x, grid.y) + 1.0 - thickness;
      return 1.0 - min(line, 1.0);
    }

    void main() {
      float g1 = getGrid(cellSize, cellThickness);
      float g2 = getGrid(sectionSize, sectionThickness);

      vec3 from = worldCamProjPosition*vec3(fadeFrom);
      float dist = distance(from, worldPosition.xyz);
      float d = 1.0 - min(dist / fadeDistance, 1.0);
      vec3 color = mix(cellColor, sectionColor, min(1.0, sectionThickness * g2));

      gl_FragColor = vec4(color, (g1 + g2) * pow(d, fadeStrength));
      gl_FragColor.a = mix(0.75 * gl_FragColor.a, gl_FragColor.a, g2);
      if (gl_FragColor.a <= 0.0) discard;

      #include <tonemapping_fragment>
      #include <${pc >= 154 ? "colorspace_fragment" : "encodings_fragment"}>
    }
  `
);
var Lc = j.forwardRef(({
  args: n,
  cellColor: t = "#000000",
  sectionColor: e = "#2080ff",
  cellSize: r = 0.5,
  sectionSize: i = 1,
  followCamera: s = false,
  infiniteGrid: o = false,
  fadeDistance: a = 100,
  fadeStrength: c = 1,
  fadeFrom: l = 1,
  cellThickness: u = 0.5,
  sectionThickness: v = 1,
  side: m = BackSide,
  ...p
}, b) => {
  extend({
    GridMaterial: Ic
  });
  const S = j.useRef(null);
  j.useImperativeHandle(b, () => S.current, []);
  const x = new Plane(), d = new Vector3(0, 1, 0), g = new Vector3(0, 0, 0);
  useFrame((y) => {
    x.setFromNormalAndCoplanarPoint(d, g).applyMatrix4(S.current.matrixWorld);
    const h = S.current.material, _ = h.uniforms.worldCamProjPosition, T = h.uniforms.worldPlanePosition;
    x.projectPoint(y.camera.position, _.value), T.value.set(0, 0, 0).applyMatrix4(S.current.matrixWorld);
  });
  const E = {
    cellSize: r,
    sectionSize: i,
    cellColor: t,
    sectionColor: e,
    cellThickness: u,
    sectionThickness: v
  }, f = {
    fadeDistance: a,
    fadeStrength: c,
    fadeFrom: l,
    infiniteGrid: o,
    followCamera: s
  };
  return j.createElement("mesh", we({
    ref: S,
    frustumCulled: false
  }, p), j.createElement("gridMaterial", we({
    transparent: true,
    "extensions-derivatives": true,
    side: m
  }, E, f)), j.createElement("planeGeometry", {
    args: n
  }));
});
var Gt = function(n) {
  return n[n.NONE = 0] = "NONE", n[n.START = 1] = "START", n[n.ACTIVE = 2] = "ACTIVE", n;
}(Gt || {});
var je = (n) => n && n.isOrthographicCamera;
var Dc = (n) => n && n.isBox3;
var Ac = (n) => 1 - Math.exp(-5 * n) + 7e-3 * n;
var Rc = j.createContext(null);
function Pc({
  children: n,
  maxDuration: t = 1,
  margin: e = 1.2,
  observe: r,
  fit: i,
  clip: s,
  interpolateFunc: o = Ac,
  onFit: a
}) {
  const c = j.useRef(null), {
    camera: l,
    size: u,
    invalidate: v
  } = useThree(), m = useThree((y) => y.controls), p = j.useRef(a);
  p.current = a;
  const b = j.useRef({
    camPos: new Vector3(),
    camRot: new Quaternion(),
    camZoom: 1
  }), S = j.useRef({
    camPos: void 0,
    camRot: void 0,
    camZoom: void 0,
    camUp: void 0,
    target: void 0
  }), x = j.useRef(Gt.NONE), d = j.useRef(0), [g] = j.useState(() => new Box3()), E = j.useMemo(() => {
    function y() {
      const h = g.getSize(new Vector3()), _ = g.getCenter(new Vector3()), T = Math.max(h.x, h.y, h.z), L = je(l) ? T * 4 : T / (2 * Math.atan(Math.PI * l.fov / 360)), M = je(l) ? T * 4 : L / l.aspect, I = e * Math.max(L, M);
      return {
        box: g,
        size: h,
        center: _,
        distance: I
      };
    }
    return {
      getSize: y,
      refresh(h) {
        if (Dc(h)) g.copy(h);
        else {
          const _ = h || c.current;
          if (!_) return this;
          _.updateWorldMatrix(true, true), g.setFromObject(_);
        }
        if (g.isEmpty()) {
          const _ = l.position.length() || 10;
          g.setFromCenterAndSize(new Vector3(), new Vector3(_, _, _));
        }
        return b.current.camPos.copy(l.position), b.current.camRot.copy(l.quaternion), je(l) && (b.current.camZoom = l.zoom), S.current.camPos = void 0, S.current.camRot = void 0, S.current.camZoom = void 0, S.current.camUp = void 0, S.current.target = void 0, this;
      },
      reset() {
        const {
          center: h,
          distance: _
        } = y(), T = l.position.clone().sub(h).normalize();
        S.current.camPos = h.clone().addScaledVector(T, _), S.current.target = h.clone();
        const L = new Matrix4().lookAt(S.current.camPos, S.current.target, l.up);
        return S.current.camRot = new Quaternion().setFromRotationMatrix(L), x.current = Gt.START, d.current = 0, this;
      },
      moveTo(h) {
        return S.current.camPos = Array.isArray(h) ? new Vector3(...h) : h.clone(), x.current = Gt.START, d.current = 0, this;
      },
      lookAt({
        target: h,
        up: _
      }) {
        S.current.target = Array.isArray(h) ? new Vector3(...h) : h.clone(), _ ? S.current.camUp = Array.isArray(_) ? new Vector3(..._) : _.clone() : S.current.camUp = l.up.clone();
        const T = new Matrix4().lookAt(S.current.camPos || l.position, S.current.target, S.current.camUp);
        return S.current.camRot = new Quaternion().setFromRotationMatrix(T), x.current = Gt.START, d.current = 0, this;
      },
      /**
       * @deprecated Use moveTo and lookAt instead
       */
      to({
        position: h,
        target: _
      }) {
        return this.moveTo(h).lookAt({
          target: _
        });
      },
      fit() {
        if (!je(l))
          return this.reset();
        let h = 0, _ = 0;
        const T = [new Vector3(g.min.x, g.min.y, g.min.z), new Vector3(g.min.x, g.max.y, g.min.z), new Vector3(g.min.x, g.min.y, g.max.z), new Vector3(g.min.x, g.max.y, g.max.z), new Vector3(g.max.x, g.max.y, g.max.z), new Vector3(g.max.x, g.max.y, g.min.z), new Vector3(g.max.x, g.min.y, g.max.z), new Vector3(g.max.x, g.min.y, g.min.z)], L = S.current.camPos || l.position, M = S.current.target || (m == null ? void 0 : m.target), I = S.current.camUp || l.up, D = M ? new Matrix4().lookAt(L, M, I).setPosition(L).invert() : l.matrixWorldInverse;
        for (const U of T)
          U.applyMatrix4(D), h = Math.max(h, Math.abs(U.y)), _ = Math.max(_, Math.abs(U.x));
        h *= 2, _ *= 2;
        const O = (l.top - l.bottom) / h, F = (l.right - l.left) / _;
        return S.current.camZoom = Math.min(O, F) / e, x.current = Gt.START, d.current = 0, p.current && p.current(this.getSize()), this;
      },
      clip() {
        const {
          distance: h
        } = y();
        return l.near = h / 100, l.far = h * 100, l.updateProjectionMatrix(), m && (m.maxDistance = h * 10, m.update()), v(), this;
      }
    };
  }, [g, l, m, e, v]);
  j.useLayoutEffect(() => {
    if (m) {
      const y = () => {
        if (m && S.current.target && x.current !== Gt.NONE) {
          const h = new Vector3().setFromMatrixColumn(l.matrix, 2), _ = b.current.camPos.distanceTo(m.target), T = (S.current.camPos || b.current.camPos).distanceTo(S.current.target), L = (1 - d.current) * _ + d.current * T;
          m.target.copy(l.position).addScaledVector(h, -L), m.update();
        }
        x.current = Gt.NONE;
      };
      return m.addEventListener("start", y), () => m.removeEventListener("start", y);
    }
  }, [m]);
  const f = j.useRef(0);
  return j.useLayoutEffect(() => {
    (r || f.current++ === 0) && (E.refresh(), i && E.reset().fit(), s && E.clip());
  }, [u, s, i, r, l, m]), useFrame((y, h) => {
    if (x.current === Gt.START)
      x.current = Gt.ACTIVE, v();
    else if (x.current === Gt.ACTIVE) {
      if (d.current += h / t, d.current >= 1)
        S.current.camPos && l.position.copy(S.current.camPos), S.current.camRot && l.quaternion.copy(S.current.camRot), S.current.camUp && l.up.copy(S.current.camUp), S.current.camZoom && je(l) && (l.zoom = S.current.camZoom), l.updateMatrixWorld(), l.updateProjectionMatrix(), m && S.current.target && (m.target.copy(S.current.target), m.update()), x.current = Gt.NONE;
      else {
        const _ = o(d.current);
        S.current.camPos && l.position.lerpVectors(b.current.camPos, S.current.camPos, _), S.current.camRot && l.quaternion.slerpQuaternions(b.current.camRot, S.current.camRot, _), S.current.camUp && l.up.set(0, 1, 0).applyQuaternion(l.quaternion), S.current.camZoom && je(l) && (l.zoom = (1 - _) * b.current.camZoom + _ * S.current.camZoom), l.updateMatrixWorld(), l.updateProjectionMatrix();
      }
      v();
    }
  }), j.createElement("group", {
    ref: c
  }, j.createElement(Rc.Provider, {
    value: E
  }, n));
}
var Mc = { BASE_URL: "/", DEV: false, MODE: "production", PROD: true, SSR: false, VITE_CJS_IGNORE_WARNING: "true" };
var ds = (n) => {
  let t;
  const e = /* @__PURE__ */ new Set(), r = (u, v) => {
    const m = typeof u == "function" ? u(t) : u;
    if (!Object.is(m, t)) {
      const p = t;
      t = v ?? (typeof m != "object" || m === null) ? m : Object.assign({}, t, m), e.forEach((b) => b(t, p));
    }
  }, i = () => t, c = { setState: r, getState: i, getInitialState: () => l, subscribe: (u) => (e.add(u), () => e.delete(u)), destroy: () => {
    (Mc ? "production" : void 0) !== "production" && console.warn(
      "[DEPRECATED] The `destroy` method will be unsupported in a future version. Instead use unsubscribe function returned by subscribe. Everything will be garbage-collected if store is garbage-collected."
    ), e.clear();
  } }, l = t = n(r, i, c);
  return c;
};
var kc = (n) => n ? ds(n) : ds;
var Xn = { exports: {} };
var Pr = { exports: {} };
var kn = {};
var ps;
function Fc() {
  return ps || (ps = 1, function() {
    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
    var n = import_react.default, t = n.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function e(E) {
      {
        for (var f = arguments.length, y = new Array(f > 1 ? f - 1 : 0), h = 1; h < f; h++)
          y[h - 1] = arguments[h];
        r("error", E, y);
      }
    }
    function r(E, f, y) {
      {
        var h = t.ReactDebugCurrentFrame, _ = h.getStackAddendum();
        _ !== "" && (f += "%s", y = y.concat([_]));
        var T = y.map(function(L) {
          return String(L);
        });
        T.unshift("Warning: " + f), Function.prototype.apply.call(console[E], console, T);
      }
    }
    function i(E, f) {
      return E === f && (E !== 0 || 1 / E === 1 / f) || E !== E && f !== f;
    }
    var s = typeof Object.is == "function" ? Object.is : i, o = n.useState, a = n.useEffect, c = n.useLayoutEffect, l = n.useDebugValue, u = false, v = false;
    function m(E, f, y) {
      u || n.startTransition !== void 0 && (u = true, e("You are using an outdated, pre-release alpha of React 18 that does not support useSyncExternalStore. The use-sync-external-store shim will not work correctly. Upgrade to a newer pre-release."));
      var h = f();
      if (!v) {
        var _ = f();
        s(h, _) || (e("The result of getSnapshot should be cached to avoid an infinite loop"), v = true);
      }
      var T = o({
        inst: {
          value: h,
          getSnapshot: f
        }
      }), L = T[0].inst, M = T[1];
      return c(function() {
        L.value = h, L.getSnapshot = f, p(L) && M({
          inst: L
        });
      }, [E, h, f]), a(function() {
        p(L) && M({
          inst: L
        });
        var I = function() {
          p(L) && M({
            inst: L
          });
        };
        return E(I);
      }, [E]), l(h), h;
    }
    function p(E) {
      var f = E.getSnapshot, y = E.value;
      try {
        var h = f();
        return !s(y, h);
      } catch {
        return true;
      }
    }
    function b(E, f, y) {
      return f();
    }
    var S = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u", x = !S, d = x ? b : m, g = n.useSyncExternalStore !== void 0 ? n.useSyncExternalStore : d;
    kn.useSyncExternalStore = g, typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
  }()), kn;
}
var gs;
function lo() {
  return gs || (gs = 1, false ? Pr.exports = Uc() : Pr.exports = Fc()), Pr.exports;
}
var Un = {};
var ms;
function Vc() {
  return ms || (ms = 1, function() {
    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
    var n = import_react.default, t = lo();
    function e(u, v) {
      return u === v && (u !== 0 || 1 / u === 1 / v) || u !== u && v !== v;
    }
    var r = typeof Object.is == "function" ? Object.is : e, i = t.useSyncExternalStore, s = n.useRef, o = n.useEffect, a = n.useMemo, c = n.useDebugValue;
    function l(u, v, m, p, b) {
      var S = s(null), x;
      S.current === null ? (x = {
        hasValue: false,
        value: null
      }, S.current = x) : x = S.current;
      var d = a(function() {
        var y = false, h, _, T = function(D) {
          if (!y) {
            y = true, h = D;
            var O = p(D);
            if (b !== void 0 && x.hasValue) {
              var F = x.value;
              if (b(F, O))
                return _ = F, F;
            }
            return _ = O, O;
          }
          var U = h, X = _;
          if (r(U, D))
            return X;
          var $ = p(D);
          return b !== void 0 && b(X, $) ? X : (h = D, _ = $, $);
        }, L = m === void 0 ? null : m, M = function() {
          return T(v());
        }, I = L === null ? void 0 : function() {
          return T(L());
        };
        return [M, I];
      }, [v, m, p, b]), g = d[0], E = d[1], f = i(u, g, E);
      return o(function() {
        x.hasValue = true, x.value = f;
      }, [f]), c(f), f;
    }
    Un.useSyncExternalStoreWithSelector = l, typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
  }()), Un;
}
false ? Xn.exports = jc() : Xn.exports = Vc();
var zc = Xn.exports;
var Nc = Hs(zc);
var co = { BASE_URL: "/", DEV: false, MODE: "production", PROD: true, SSR: false, VITE_CJS_IGNORE_WARNING: "true" };
var { useDebugValue: Yc } = import_react.default;
var { useSyncExternalStoreWithSelector: Bc } = Nc;
var _s = false;
var Gc = (n) => n;
function Hc(n, t = Gc, e) {
  (co ? "production" : void 0) !== "production" && e && !_s && (console.warn(
    "[DEPRECATED] Use `createWithEqualityFn` instead of `create` or use `useStoreWithEqualityFn` instead of `useStore`. They can be imported from 'zustand/traditional'. https://github.com/pmndrs/zustand/discussions/1937"
  ), _s = true);
  const r = Bc(
    n.subscribe,
    n.getState,
    n.getServerState || n.getInitialState,
    t,
    e
  );
  return Yc(r), r;
}
var ys = (n) => {
  (co ? "production" : void 0) !== "production" && typeof n != "function" && console.warn(
    "[DEPRECATED] Passing a vanilla store will be unsupported in a future version. Instead use `import { useStore } from 'zustand'`."
  );
  const t = typeof n == "function" ? kc(n) : n, e = (r, i) => Hc(t, r, i);
  return Object.assign(e, t), e;
};
var Kc = (n) => n ? ys(n) : ys;
var Es;
var Ss;
var bs = typeof window < "u" && ((Es = window.document) != null && Es.createElement || ((Ss = window.navigator) == null ? void 0 : Ss.product) === "ReactNative") ? import_react.default.useLayoutEffect : import_react.default.useEffect;
function Xc() {
  const n = Kc((t) => ({
    current: new Array(),
    version: 0,
    set: t
  }));
  return {
    In: ({
      children: t
    }) => {
      const e = n((i) => i.set), r = n((i) => i.version);
      return bs(() => {
        e((i) => ({
          version: i.version + 1
        }));
      }, []), bs(() => (e(({
        current: i
      }) => ({
        current: [...i, t]
      })), () => e(({
        current: i
      }) => ({
        current: i.filter((s) => s !== t)
      }))), [t, r]), null;
    },
    Out: () => {
      const t = n((e) => e.current);
      return import_react.default.createElement(import_react.default.Fragment, null, t);
    }
  };
}
var Zr = Xc();
var uo = (0, import_react.createContext)(null);
function Zc() {
  const n = (0, import_react.useContext)(uo);
  if (!n)
    throw new Error("invariant: could not find triplex scene context");
  return n;
}
var Wc = uo.Provider;
function nr(n) {
  const t = (0, import_react.useRef)(
    qc
  );
  (0, import_react.useInsertionEffect)(() => {
    t.current = n;
  }, [n]);
  const e = (0, import_react.useRef)(null);
  return e.current || (e.current = (...r) => t.current(...r)), e.current;
}
function qc() {
  throw new Error(
    "INVALID_USEEVENT_INVOCATION: the callback from useEvent cannot be invoked before the component has mounted."
  );
}
function gi() {
  const [n, t] = (0, import_react.useState)("edit");
  return (0, import_react.useEffect)(() => mt("request-state-change", ({ state: e }) => {
    t(e);
  }), []), n;
}
var Qc = 0;
var $c = new Layers();
var Jc = 31;
var le = new Layers();
le.set(Jc);
var ho = 30;
var fo = new Layers();
fo.set(ho);
var Wr = 29;
var tu = new Layers();
tu.set(Wr);
var Zn = new Layers();
Zn.enableAll();
function eu({ children: n }) {
  const t = gi();
  return P.jsx(
    Canvas,
    {
      gl: {
        ...typeof window.triplex.renderer.attributes.gl == "object" ? window.triplex.renderer.attributes.gl : void 0,
        antialias: false
      },
      raycaster: {
        layers: t === "play" ? $c : (
          // This forces the default r3f raycaster to be fired on a different layer (31)
          // than the default layer (0) that object3d's are set to default.
          le
        )
      },
      shadows: true,
      style: { inset: 0, position: "absolute" },
      children: n
    }
  );
}
var ru = (n, t) => {
  const e = t.transform === "none" ? "translate" : t.transform;
  let r, i;
  return n.traverse((s) => {
    const o = vi(s);
    o && (!r && o[e] && (r = s), !i && o.translate && (i = s));
  }), r || i || n;
};
function nu(n) {
  return "__triplex" in n;
}
function vi(n) {
  if (n && nu(n)) {
    const { __r3f: t, ...e } = n.__triplex;
    return e;
  }
}
function iu(n, t) {
  if (t.path === n.path) {
    for (const e of t.elements)
      if (n.line === e.line && n.column === e.column)
        return true;
  }
  return false;
}
function su(n) {
  const t = "isMesh" in n;
  if ("isInteractionPanel" in n)
    return true;
  if (!t || !n.visible)
    return false;
  let r = n;
  for (; r; ) {
    if (!r.visible)
      return false;
    r = r.parent;
  }
  return true;
}
function po(n, t) {
  let e = n;
  for (; e; ) {
    const r = vi(e);
    if (r) {
      for (const i of r.parents)
        if ("column" in t ? t.column === i.column && t.line === i.line && i.path === t.path : iu(i, t))
          return i;
      if (r.column >= 0 && r.line >= 0)
        return r;
    }
    e = e.parent;
  }
  return null;
}
var mi = (n, t) => {
  let e = null;
  return n.traverse((r) => {
    const i = vi(r);
    if (!(!i || e)) {
      i.path === t.path && i.column === t.column && i.line === t.line && (e = r);
      for (const s of i.parents)
        s.path === t.path && s.column === t.column && s.line === t.line && (e = r);
    }
  }), e;
};
var ws = (n, t) => {
  const e = mi(n, t);
  if (e) {
    const r = po(e, t);
    if (r) {
      const i = /^[a-z]/.test(r.name) ? e : ru(e, t);
      return {
        ...r,
        parentPath: t.path,
        sceneObject: i,
        space: "local"
      };
    }
  }
  return null;
};
function go(n) {
  let t = new Box3();
  return n.children.forEach((e) => {
    if (e.layers.test(le))
      return;
    const r = new Box3().setFromObject(e), i = r.max.lengthSq();
    i === Number.POSITIVE_INFINITY || i > 1e6 || (t = t.union(r));
  }), t.getBoundingSphere(new Sphere());
}
var Fn = "__triplex_camera";
var jn = "perspective";
var xs = [0, 0, 1];
var Mr = Vr.ACTION;
var Vn = {
  ctrl: {},
  rest: {
    left: Mr.ROTATE,
    middle: Mr.DOLLY,
    right: Mr.TRUCK
  },
  shift: {
    left: Mr.TRUCK
  }
};
var zn = {
  ctrl: {},
  rest: {},
  shift: {}
};
function Ve(n, t) {
  const e = t;
  for (const r in t)
    n[r] = e[r];
}
var vo = (0, import_react.createContext)({
  camera: void 0,
  controls: { current: null },
  isTriplexCamera: true
});
function Nn(n, t) {
  if ("isOrthographicCamera" in n) {
    const e = t.width / -2, r = t.width / 2, i = t.height / 2, s = t.height / -2;
    n.left = e, n.right = r, n.top = i, n.bottom = s, n.updateProjectionMatrix();
  } else
    n.aspect = t.width / t.height, n.updateProjectionMatrix();
}
function mr() {
  return (0, import_react.useContext)(vo);
}
function ou({
  children: n,
  id: t
}) {
  const { controls: e } = mr(), r = useThree((i) => i.scene);
  return (0, import_react.useLayoutEffect)(() => {
    if (e.current) {
      const i = go(r);
      if (i.isEmpty())
        return;
      const s = new Spherical().setFromVector3(
        // Z forward rotation.
        new Vector3(0, 0, 1)
      );
      e.current.rotateTo(s.theta, s.phi, false), e.current.fitToSphere(i, false);
    }
  }, [e, r, t]), P.jsx(P.Fragment, { children: n });
}
function au({
  children: n,
  defaultCamera: t = jn
}) {
  const [e, r] = (0, import_react.useState)(
    t
  ), i = useThree((E) => E.scene), s = useThree((E) => E.set), o = useThree((E) => E.camera), a = useThree((E) => E.gl), c = (0, import_react.useRef)(), l = (0, import_react.useRef)(null), u = (0, import_react.useRef)(null), v = (0, import_react.useRef)(null), [m, p] = (0, import_react.useState)(
    void 0
  ), b = m && m.name === Fn, S = (0, import_react.useRef)(), [x, d] = (0, import_react.useState)(
    "Rest"
  );
  (0, import_react.useEffect)(() => {
    if (v.current)
      switch (x) {
        case "Control":
          Ve(v.current.touches, zn.ctrl), Ve(v.current.mouseButtons, Vn.ctrl);
          break;
        case "Shift":
          Ve(v.current.touches, zn.shift), Ve(v.current.mouseButtons, Vn.shift);
          break;
        default:
          Ve(v.current.touches, zn.rest), Ve(v.current.mouseButtons, Vn.rest);
          break;
      }
  }, [x, m]), (0, import_react.useEffect)(() => {
    let E;
    const f = (_) => {
      function T() {
        window.clearInterval(E), E = window.setInterval(() => {
          document.hasFocus() || (window.clearInterval(E), d("Rest"));
        }, 200);
      }
      switch (_.key) {
        case "Shift":
        case "Control":
          T(), d(_.key);
          break;
      }
    }, y = (_) => {
      switch (_.key) {
        case "Shift":
        case "Control":
          window.clearInterval(E), d("Rest");
          break;
      }
    }, h = () => {
      document.visibilityState === "hidden" && (window.clearInterval(E), d("Rest"));
    };
    return document.addEventListener("keydown", f), document.addEventListener("keyup", y), document.addEventListener("visibilitychange", h), () => {
      document.removeEventListener("keydown", f), document.removeEventListener("keyup", y), document.removeEventListener(
        "visibilitychange",
        h
      );
    };
  }, []), (0, import_react.useEffect)(() => mt("request-state-change", ({ camera: E, state: f }) => {
    f !== "edit" && E === "default" ? (r("user"), p(S.current)) : r(c.current || jn);
  }), []), (0, import_react.useEffect)(() => dr([
    mt("extension-point-triggered", (E) => {
      if (E.scope === "scene")
        switch (E.id) {
          case "perspective":
          case "orthographic":
            return e === "user" ? void 0 : (r(E.id), { handled: true });
        }
    }),
    mt("extension-point-triggered", (E) => {
      if (E.scope === "element")
        switch (E.id) {
          case "camera_enter": {
            const f = mi(i, {
              column: E.data.column,
              line: E.data.line,
              path: E.data.parentPath
            });
            return f && ["PerspectiveCamera", "OrthographicCamera"].includes(f.type) ? (r("user"), p(f), { handled: true }) : { handled: false };
          }
          case "camera_exit":
            return r(c.current || jn), p(
              c.current === "orthographic" ? l.current : u.current
            ), { handled: true };
        }
    })
  ]), [i, e]), (0, import_react.useLayoutEffect)(() => {
    e === "orthographic" ? (c.current = "orthographic", p(l.current)) : e === "perspective" && (c.current = "perspective", p(u.current));
  }, [i, e]), (0, import_react.useLayoutEffect)(() => {
    function E() {
      const y = {
        height: a.domElement.clientHeight,
        left: 0,
        top: 0,
        width: a.domElement.clientWidth
      };
      Nn(l.current, y), Nn(u.current, y), Nn(o, y);
    }
    const f = new ResizeObserver(E);
    return f.observe(a.domElement), () => {
      f.disconnect();
    };
  }, [o, a.domElement]), useFrame(({ camera: E, gl: f, scene: y }) => {
    m ? (f.render(y, m), E !== m && (s({ camera: m }), E !== u.current && E !== l.current && (S.current = E))) : f.render(y, E);
  }, 1);
  const g = (0, import_react.useMemo)(
    () => ({
      camera: m,
      controls: v,
      isTriplexCamera: !!b
    }),
    [m, b]
  );
  return P.jsxs(vo.Provider, { value: g, children: [
    n,
    P.jsx(
      "perspectiveCamera",
      {
        far: 1e5,
        layers: Zn,
        manual: true,
        name: Fn,
        near: 0.01,
        position: xs,
        ref: u
      }
    ),
    P.jsx(
      "orthographicCamera",
      {
        far: 1e5,
        layers: Zn,
        manual: true,
        name: Fn,
        near: -100,
        position: xs,
        ref: l,
        zoom: 100
      }
    ),
    b && P.jsx(
      Sc,
      {
        camera: m,
        ref: v
      }
    ),
    false
  ] });
}
var Os = (n, t, e) => {
  const r = go(t);
  if (r.isEmpty())
    return;
  const i = new Spherical().setFromVector3(
    new Vector3(e.x, e.y, e.z)
  );
  n.rotateTo(i.theta, i.phi, true), n.fitToSphere(r, true);
};
var ir = { bg: "#f0f0f0", hover: "#999", stroke: "black", text: "black" };
var lu = ["Right", "Left", "Top", "Bottom", "Front", "Back"];
var mo = (n) => new Vector3(...n).multiplyScalar(0.38);
var cu = [
  [1, 1, 1],
  [1, 1, -1],
  [1, -1, 1],
  [1, -1, -1],
  [-1, 1, 1],
  [-1, 1, -1],
  [-1, -1, 1],
  [-1, -1, -1]
].map(mo);
var uu = [0.25, 0.25, 0.25];
var _o = [
  [1, 1, 0],
  [1, 0, 1],
  [1, 0, -1],
  [1, -1, 0],
  [0, 1, 1],
  [0, 1, -1],
  [0, -1, 1],
  [0, -1, -1],
  [-1, 1, 0],
  [-1, 0, 1],
  [-1, 0, -1],
  [-1, -1, 0]
].map(mo);
var hu = _o.map(
  (n) => n.toArray().map((t) => t == 0 ? 0.5 : 0.25)
);
var du = ({
  color: n = ir.bg,
  faces: t = lu,
  font: e = "20px Inter var, Arial, sans-serif",
  hover: r,
  hoverColor: i = ir.hover,
  index: s,
  strokeColor: o = ir.stroke,
  textColor: a = ir.text
}) => {
  const c = (0, import_react.useMemo)(() => {
    const l = document.createElement("canvas");
    l.width = 128, l.height = 128;
    const u = l.getContext("2d");
    return u.fillStyle = n, u.fillRect(0, 0, l.width, l.height), u.strokeStyle = o, u.lineWidth = 2, u.strokeRect(0, 0, l.width, l.height), u.font = e, u.textAlign = "center", u.fillStyle = a, u.fillText(t[s], 64, 76), new CanvasTexture(l);
  }, [s, t, e, n, a, o]);
  return P.jsx(
    "meshStandardMaterial",
    {
      attach: `material-${s}`,
      color: r ? i : "white",
      emissive: r ? "white" : "black",
      emissiveIntensity: r ? 0.06 : 1,
      map: c,
      opacity: r ? 1 : 0.5,
      transparent: true
    }
  );
};
var fu = ({ onClick: n, ...t }) => {
  const [e, r] = (0, import_react.useState)(null), i = (o) => {
    o.stopPropagation(), r(null);
  }, s = (o) => {
    o.stopPropagation(), r(Math.floor(o.faceIndex / 2));
  };
  return P.jsxs(
    "mesh",
    {
      onClick: n,
      onPointerMove: s,
      onPointerOut: i,
      children: [
        [...Array(6)].map((o, a) => P.jsx(
          du,
          {
            hover: e === a,
            index: a,
            ...t
          },
          a
        )),
        P.jsx("boxGeometry", {})
      ]
    }
  );
};
var Ts = ({
  dimensions: n,
  hoverColor: t = ir.hover,
  onClick: e,
  position: r
}) => {
  const [i, s] = (0, import_react.useState)(false), o = (c) => {
    c.stopPropagation(), s(false);
  }, a = (c) => {
    c.stopPropagation(), s(true);
  };
  return P.jsxs(
    "mesh",
    {
      onClick: e,
      onPointerOut: o,
      onPointerOver: a,
      position: r,
      scale: 1.01,
      children: [
        P.jsx(
          "meshBasicMaterial",
          {
            color: i ? t : "white",
            opacity: 0.4,
            transparent: true,
            visible: i
          }
        ),
        P.jsx("boxGeometry", { args: n })
      ]
    }
  );
};
function pu(n) {
  return P.jsxs("group", { scale: [50, 50, 50], children: [
    P.jsx(fu, { ...n }),
    _o.map((t, e) => P.jsx(
      Ts,
      {
        dimensions: hu[e],
        position: t,
        ...n
      },
      e
    )),
    cu.map((t, e) => P.jsx(
      Ts,
      {
        dimensions: uu,
        position: t,
        ...n
      },
      e
    )),
    P.jsx("ambientLight", { intensity: 4 })
  ] });
}
function gu() {
  const { controls: n, isTriplexCamera: t } = mr(), e = useThree((r) => r.scene);
  return t ? P.jsx(
    Cc,
    {
      alignment: "bottom-right",
      layers: le,
      margin: [50, 50],
      renderPriority: 2,
      children: P.jsx(
        pu,
        {
          color: "rgb(30 30 30)",
          font: "30px ui-sans-serif, system-ui, -apple-system, BlinkMacSystemFont, Segoe UI, Roboto, Noto Sans, Ubuntu, Cantarell, Helvetica Neue, Arial, sans-serif",
          onClick: (r) => (n.current && (r.stopPropagation(), r.eventObject.position.x === 0 && r.eventObject.position.y === 0 && r.eventObject.position.z === 0 ? Os(n.current, e, r.face.normal) : Os(n.current, e, r.eventObject.position), pt("track", { actionId: "controls_viewcube" })), null),
          strokeColor: "rgb(115 115 115)",
          textColor: "rgb(212 212 212)"
        }
      )
    }
  ) : null;
}
function vu() {
  const n = gi();
  return P.jsx(
    Lc,
    {
      cellColor: "#6f6f6f",
      cellSize: 1,
      cellThickness: 1,
      fadeDistance: 100,
      fadeStrength: 5,
      followCamera: true,
      infiniteGrid: true,
      layers: le,
      sectionColor: "#9d4b4b",
      sectionSize: 3,
      side: 2,
      visible: n !== "play"
    }
  );
}
function Cs() {
  return P.jsxs(
    "div",
    {
      style: {
        alignItems: "center",
        bottom: 12,
        display: "flex",
        height: 50,
        justifyContent: "center",
        pointerEvents: "none",
        position: "fixed",
        right: 12,
        width: 50
      },
      children: [
        P.jsx("style", { children: `
  .loading--animate-dashes {
    stroke-dasharray: 25;
    animation: dash 1.4s linear infinite;
  }

  @keyframes dash {
    to {
      stroke-dashoffset: 100;
    }
  }
      ` }),
        P.jsxs("svg", { height: "33", viewBox: "0 0 33 33", width: "33", children: [
          P.jsx("defs", { children: P.jsxs("linearGradient", { id: "l-gradient", x1: "0%", x2: "100%", y1: "0%", y2: "0%", children: [
            P.jsx("stop", { offset: "0%", stopColor: "rgb(245 245 245)" }),
            P.jsx("stop", { offset: "100%", stopColor: "rgb(163 163 163)" })
          ] }) }),
          P.jsx(
            "polygon",
            {
              className: "loading--animate-dashes",
              fill: "none",
              points: "16,1 32,32 1,32",
              stroke: "url(#l-gradient)",
              strokeWidth: "2"
            }
          )
        ] })
      ]
    }
  );
}
function yo(n) {
  let t = 0;
  for (let e = 0; e < n.length; e++) {
    const r = n.charCodeAt(e);
    t = (t << 5) - t + r;
  }
  return (t >>> 0).toString(36).padStart(7, "0");
}
var Is = `uniform sampler2D u_maskTexture;
uniform vec2 u_viewportSize;
varying vec2 v_uv;

const float LINE_WEIGHT = 2.5;
const vec3 LINE_COLOR = vec3(1.0, 1.0, 0.0);

void main() {
  float dx = 1.0 / u_viewportSize.x * LINE_WEIGHT;
  float dy = 1.0 / u_viewportSize.y * LINE_WEIGHT;

  vec2 uvCenter = v_uv;
  vec2 uvRight = vec2(uvCenter.x + dx, uvCenter.y);
  vec2 uvTop = vec2(uvCenter.x, uvCenter.y - dx);
  vec2 uvTopRight = vec2(uvCenter.x + dx, uvCenter.y - dx);

  float mCenter = texture2D(u_maskTexture, uvCenter).a;
  float mTop = texture2D(u_maskTexture, uvTop).a;
  float mRight = texture2D(u_maskTexture, uvRight).a;
  float mTopRight = texture2D(u_maskTexture, uvTopRight).a;

  float dT = abs(mCenter - mTop);
  float dR = abs(mCenter - mRight);
  float dTR = abs(mCenter - mTopRight);

  float delta = 0.0;
  delta = max(delta, dT);
  delta = max(delta, dR);
  delta = max(delta, dTR);

  if (delta > 0.0) {
    gl_FragColor = vec4(LINE_COLOR, 1.0);
  } else {
    gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);
  }
}`;
var Ls = `varying vec2 v_uv;

void main() {
  v_uv = uv;
  gl_Position = vec4(position, 0.5);
}`;
function mu({ debug: n = false }) {
  const t = pi(), e = (0, import_react.useRef)(null), [r] = (0, import_react.useState)(
    () => new Vector2(t.width, t.height)
  );
  return useFrame((i) => {
    const s = i.scene.background;
    i.scene.background = null, i.gl.setRenderTarget(t), i.camera.layers.set(Wr), r.set(t.height * 2, t.width), i.gl.render(i.scene, i.camera), i.gl.setRenderTarget(null), i.camera.layers.enableAll(), i.scene.background = s;
  }), P.jsxs(P.Fragment, { children: [
    P.jsxs("mesh", { frustumCulled: false, layers: le, raycast: () => null, children: [
      P.jsx("planeGeometry", {}),
      P.jsx(
        "shaderMaterial",
        {
          depthTest: false,
          fragmentShader: Is,
          ref: e,
          transparent: true,
          uniforms: {
            u_maskTexture: { value: t.texture },
            u_viewportSize: { value: r }
          },
          vertexShader: Ls
        },
        yo(Is + Ls)
      )
    ] }),
    n && P.jsxs("mesh", { layers: le, position: [-1, 0, 0], raycast: () => null, children: [
      P.jsx("planeGeometry", { args: [5, 5] }),
      P.jsx("meshBasicMaterial", { map: t.texture })
    ] })
  ] });
}
function _u({ children: n, fallback: t }) {
  const [e, r] = (0, import_react.useState)(false);
  return (0, import_react.useEffect)(() => {
    r(true);
  }, []), e ? P.jsx(import_react.Suspense, { fallback: t, children: n }) : n;
}
function yu(n, t) {
  return typeof n == "function" ? n(t) : n && (n.current = t), n;
}
function Eu(n) {
  var t = null;
  return {
    get current() {
      return t;
    },
    set current(e) {
      var r = t;
      r !== e && (t = e, n(e, r));
    }
  };
}
function Su(n) {
  return Eu(function(t) {
    return n.forEach(function(e) {
      return yu(e, t);
    });
  });
}
var bu = class extends Camera {
};
var kr = new Vector3();
var kt = new bu();
var wu = class extends LineSegments {
  constructor(e) {
    const r = new BufferGeometry(), i = new LineBasicMaterial({
      color: 16777215,
      toneMapped: false,
      vertexColors: true
    }), s = [], o = [], a = {};
    c("n1", "n2"), c("n2", "n4"), c("n4", "n3"), c("n3", "n1"), c("p", "n1"), c("p", "n2"), c("p", "n3"), c("p", "n4"), c("u1", "u2"), c("u2", "u3"), c("u3", "u1"), c("cn1", "cn2"), c("cn3", "cn4");
    function c(b, S) {
      l(b), l(S);
    }
    function l(b) {
      s.push(0, 0, 0), o.push(0, 0, 0), a[b] === void 0 && (a[b] = []), a[b].push(s.length / 3 - 1);
    }
    r.setAttribute("position", new Float32BufferAttribute(s, 3)), r.setAttribute("color", new Float32BufferAttribute(o, 3));
    super(r, i);
    pn(this, "camera");
    pn(this, "pointMap");
    this.type = "CameraHelper", this.camera = e, this.camera.updateProjectionMatrix && this.camera.updateProjectionMatrix(), this.matrix = e.matrixWorld, this.matrixAutoUpdate = false, this.pointMap = a, this.update();
    const u = new Color(16755200), v = new Color(16711680), m = new Color(43775), p = new Color(3355443);
    this.setColors(u, v, m, p);
  }
  setColors(e, r, i, s) {
    const a = this.geometry.getAttribute("color");
    a.setXYZ(0, e.r, e.g, e.b), a.setXYZ(1, e.r, e.g, e.b), a.setXYZ(2, e.r, e.g, e.b), a.setXYZ(3, e.r, e.g, e.b), a.setXYZ(4, e.r, e.g, e.b), a.setXYZ(5, e.r, e.g, e.b), a.setXYZ(6, e.r, e.g, e.b), a.setXYZ(7, e.r, e.g, e.b), a.setXYZ(8, r.r, r.g, r.b), a.setXYZ(9, r.r, r.g, r.b), a.setXYZ(10, r.r, r.g, r.b), a.setXYZ(11, r.r, r.g, r.b), a.setXYZ(12, r.r, r.g, r.b), a.setXYZ(13, r.r, r.g, r.b), a.setXYZ(14, r.r, r.g, r.b), a.setXYZ(15, r.r, r.g, r.b), a.setXYZ(16, i.r, i.g, i.b), a.setXYZ(17, i.r, i.g, i.b), a.setXYZ(18, i.r, i.g, i.b), a.setXYZ(19, i.r, i.g, i.b), a.setXYZ(20, i.r, i.g, i.b), a.setXYZ(21, i.r, i.g, i.b), a.setXYZ(22, s.r, s.g, s.b), a.setXYZ(23, s.r, s.g, s.b), a.setXYZ(24, s.r, s.g, s.b), a.setXYZ(25, s.r, s.g, s.b), a.needsUpdate = true;
  }
  update() {
    const e = this.geometry, r = this.pointMap, i = 1, s = 1;
    kt.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse), Vt("c", r, e, kt, 0, 0, -1), Vt("t", r, e, kt, 0, 0, 1), Vt("n1", r, e, kt, -i, -s, -1), Vt("n2", r, e, kt, i, -s, -1), Vt("n3", r, e, kt, -i, s, -1), Vt("n4", r, e, kt, i, s, -1), Vt("u1", r, e, kt, i * 0.7, s * 1.1, -1), Vt("u2", r, e, kt, -i * 0.7, s * 1.1, -1), Vt("u3", r, e, kt, 0, s * 2, -1), Vt("cn1", r, e, kt, -i, 0, -1), Vt("cn2", r, e, kt, i, 0, -1), Vt("cn3", r, e, kt, 0, -s, -1), Vt("cn4", r, e, kt, 0, s, -1), e.getAttribute("position").needsUpdate = true;
  }
  dispose() {
    this.geometry.dispose(), "dispose" in this.material && this.material.dispose();
  }
};
function Vt(n, t, e, r, i, s, o) {
  kr.set(i, s, o).unproject(r);
  const a = t[n];
  if (a !== void 0) {
    const c = e.getAttribute("position");
    for (let l = 0, u = a.length; l < u; l++)
      c.setXYZ(a[l], kr.x, kr.y, kr.z);
  }
}
extend({ TriplexCameraHelper: wu });
var lr = 0.1;
var xu = (n) => {
  switch (n) {
    case "rectAreaLight":
    case "pointLight":
    case "ambientLight":
      return ["pointLightHelper", [lr]];
    case "hemisphereLight":
      return ["hemisphereLightHelper", [lr]];
    case "spotLight":
      return ["spotLightHelper", []];
    case "directionalLight":
      return ["directionalLightHelper", []];
    case "perspectiveCamera":
    case "orthographicCamera":
      return ["triplexCameraHelper", []];
    default:
      return;
  }
};
function Ou({
  onClick: n,
  target: t
}) {
  const e = (0, import_react.useRef)(null);
  return useFrame(() => {
    e.current.position.copy(t.position);
  }), P.jsx("group", { ref: e, children: P.jsx("mesh", { layers: le, onClick: n, visible: false, children: P.jsx(
    "boxGeometry",
    {
      args: [lr * 2, lr * 2, lr * 2]
    }
  ) }) });
}
function Tu({
  args: n = [],
  helperName: t,
  onClick: e,
  targetRef: r
}) {
  const [i, s] = (0, import_react.useState)(null), o = (0, import_react.useRef)(null), a = useThree((l) => l.scene), c = gi();
  return (0, import_react.useLayoutEffect)(() => {
    r && r.current && s(r.current);
  }, [r]), useFrame(() => {
    var l;
    (l = o.current) == null || l.update();
  }), i ? P.jsxs(P.Fragment, { children: [
    P.jsx(Ou, { onClick: e, target: i }),
    createPortal(
      // We portal to helper to be a direct descendent of the scene to prevent
      // position bugs when helpers are logically rendered inside a group.
      // See: https://discourse.threejs.org/t/pointlighthelper-position-problem/47760/2
      P.jsx(
        t,
        {
          args: [i, ...n],
          layers: fo,
          ref: o,
          visible: c !== "play"
        }
      ),
      a
    )
  ] }) : null;
}
function Cu(n) {
  return JSON.parse(n, (t, e) => e === "__UNDEFINED__" ? void 0 : e);
}
function Iu() {
  let n, t;
  return {
    promise: new Promise((r, i) => {
      n = r, t = i;
    }),
    reject: t,
    resolve: n
  };
}
function Ur(n, t) {
  let e = n;
  for (const r in t) {
    const i = t[r], s = i === void 0 ? "" : encodeURIComponent(i);
    e = e.replace(`:${r}`, s);
  }
  return e;
}
function Lu(n) {
  const t = /* @__PURE__ */ new Map(), e = /* @__PURE__ */ new Map();
  function r({
    onClose: l,
    onError: u,
    onMessage: v,
    path: m,
    url: p
  }) {
    let b = S();
    function S() {
      const x = new WebSocket(p);
      return x.addEventListener("open", () => {
        x.send(m);
      }), x.addEventListener("message", (d) => {
        const g = Cu(d.data);
        v(g);
      }), x.addEventListener("error", () => {
        u();
      }), x.addEventListener("close", ({ code: d }) => {
        d === 1006 ? setTimeout(() => {
          x.readyState === WebSocket.CLOSED && S();
        }, 1e3) : l();
      }), x;
    }
    return {
      close: () => b.close()
    };
  }
  function i(l) {
    function u() {
      if (e.has(l))
        return;
      const p = typeof n == "function" ? n() : n, b = Iu(), S = [];
      let x;
      const d = r({
        onClose: () => {
          e.delete(l);
        },
        onError: () => {
          b.reject();
        },
        onMessage: (E) => {
          t.set(l, E), S.forEach((f) => f()), b.resolve();
        },
        path: l,
        url: p.url
      });
      function g(E) {
        return S.push(E), () => {
          window.clearTimeout(x);
          const f = S.indexOf(E);
          S.splice(f, 1), x = window.setTimeout(() => {
            S.length === 0 && (e.delete(l), d.close());
          }, 9999);
        };
      }
      e.set(l, {
        deferred: b,
        subscribe: g
      });
    }
    function v(p = true) {
      const b = e.get(l);
      if (!b)
        throw new Error(`invariant: call load() first for ${l}`);
      const S = t.get(l);
      if (!S) {
        if (p)
          throw b.deferred.promise;
        return null;
      }
      if (typeof S == "object" && "error" in S)
        throw new Error(
          `Error reading "${decodeURIComponent(l)}" - [${S.error}]`
        );
      return S;
    }
    function m(p) {
      const b = e.get(l);
      if (!b)
        throw new Error(`invariant: call load() first for ${l}`);
      return b.subscribe(p);
    }
    return {
      load: u,
      read: v,
      subscribe: m
    };
  }
  function s(...l) {
    const [u, v = {}] = l;
    i(Ur(u, v)).load();
  }
  function o(...l) {
    const [u, v = {}] = l, m = i(
      Ur(u, v)
    );
    return m.load(), (0, import_react.useSyncExternalStore)(
      (0, import_react.useCallback)((b) => m.subscribe(b), [m]),
      m.read
    );
  }
  function a(...l) {
    const [u, v = {}] = l, m = i(
      Ur(u, v)
    );
    return (0, import_react.useSyncExternalStore)(
      (0, import_react.useCallback)((b) => m.subscribe(b), [m]),
      m.read
    );
  }
  function c(...l) {
    const [u, v = {}] = l, [m, p] = (0, import_react.useState)(null), b = Ur(u, v);
    return (0, import_react.useEffect)(() => {
      if (v.disabled) {
        p(null);
        return;
      }
      const S = i(b);
      return S.load(), p(S.read(false)), S.subscribe(() => {
        p(S.read(false));
      });
    }, [v.disabled, b]), m;
  }
  return {
    preloadSubscription: s,
    useLazySubscription: o,
    useSubscription: a,
    useSubscriptionEffect: c
  };
}
var Eo = Lu(() => ({
  url: `ws://localhost:${window.triplex.env.ports.ws}`
}));
var Du = Eo.preloadSubscription;
var Ds = Eo.useSubscriptionEffect;
var As = `varying vec2 v_uv;
uniform sampler2D u_texture;

void main() {
  gl_FragColor = texture2D(u_texture, v_uv);
  #include <tonemapping_fragment>
  #include <colorspace_fragment>
}`;
var Rs = `varying vec2 v_uv;

float PREVIEW_SIZE = 0.33;
float DEFAULT_Z_POS = 0.5;

void main() {
  v_uv = uv;
  vec3 offset = vec3(
    -DEFAULT_Z_POS / PREVIEW_SIZE + DEFAULT_Z_POS,
    -DEFAULT_Z_POS / PREVIEW_SIZE + DEFAULT_Z_POS,
    0.0
  );
  gl_Position = vec4(position + offset, DEFAULT_Z_POS / PREVIEW_SIZE);
}`;
function Au({ camera: n }) {
  const t = pi(), e = useThree((r) => r.scene);
  return useFrame((r) => {
    const i = n.layers.mask;
    r.gl.setRenderTarget(t), n.layers.set(Qc), r.gl.render(r.scene, n), n.layers.set(i), r.gl.setRenderTarget(null);
  }), createPortal(
    P.jsxs("mesh", { frustumCulled: false, layers: ho, children: [
      P.jsx("planeGeometry", {}),
      P.jsx(
        "shaderMaterial",
        {
          fragmentShader: As,
          uniforms: {
            u_texture: { value: t.texture }
          },
          vertexShader: Rs
        },
        yo(As + Rs)
      )
    ] }),
    e
  );
}
var Ru = ({
  enabled: n,
  ...t
}) => {
  const e = (0, import_react.useRef)(null), { camera: r, controls: i } = mr();
  return (0, import_react.useEffect)(() => {
    const s = (a) => {
      i.current && (i.current.enabled = !a.value);
    }, o = e.current;
    return o.addEventListener("dragging-changed", s), () => {
      o.removeEventListener("dragging-changed", s);
    };
  }, [r, i]), P.jsx(
    mc,
    {
      ...t,
      camera: r,
      enabled: n,
      ref: e
    }
  );
};
var So = (0, import_react.createContext)(() => {
});
function Pu() {
  return (0, import_react.useContext)(So);
}
function bo(n) {
  const t = [];
  for (const e of n) {
    const r = bo(e.children);
    for (const i of r)
      t.push(i);
    t.push(e);
  }
  return t;
}
var Mu = new Vector3();
function ku(n) {
  const t = { ...n.props };
  for (const e in t) {
    const r = t[e];
    r && typeof r == "object" && "$$typeof" in r && delete t[e];
  }
  if ("position" in t) {
    const e = n.sceneObject.getWorldPosition(Mu).toArray();
    return {
      ...t,
      position: e
    };
  }
  return t;
}
function Ps(n) {
  return +Number.parseFloat(Number(n).toPrecision(15));
}
var Uu = new Vector3();
var Ms = new Raycaster();
var wo = (0, import_react.createContext)(() => {
  throw new Error("invariant");
});
var Fu = () => (0, import_react.useContext)(wo);
function ju({
  children: n,
  filter: t,
  onBlur: e,
  onFocus: r,
  onNavigate: i
}) {
  const [s, o] = (0, import_react.useState)("world"), [a, c] = (0, import_react.useState)(), [l, u] = (0, import_react.useState)("none"), v = useThree((D) => D.scene), m = useThree((D) => D.gl), p = useThree((D) => D.camera), b = useThree((D) => D.size), [S, x] = (0, import_react.useState)(false), d = Ds(
    "/scene/:path/object/:line/:column",
    {
      column: a == null ? void 0 : a.column,
      disabled: !a || (a == null ? void 0 : a.line) === -1 && (a == null ? void 0 : a.column) === -1,
      line: a == null ? void 0 : a.line,
      path: a == null ? void 0 : a.parentPath
    }
  ), g = Ds("/scene/:path/:exportName", {
    disabled: !t.exportName || !t.path,
    exportName: t.exportName,
    path: t.path
  }), E = (0, import_react.useMemo)(
    () => bo((g == null ? void 0 : g.sceneObjects) || []),
    [g]
  ), [f, y] = (0, import_react.useState)(
    null
  ), h = (0, import_react.useRef)(false), { controls: _ } = mr();
  (0, import_react.useEffect)(() => mt("request-state-change", ({ state: D }) => {
    D === "play" ? (c(void 0), e(), h.current = true) : h.current = false;
  }), [e]), (0, import_react.useEffect)(() => mt("extension-point-triggered", (D) => {
    if (D.scope === "scene")
      switch (D.id) {
        case "translate":
        case "scale":
        case "rotate":
        case "none": {
          u(D.id);
          break;
        }
        case "transformlocal":
          return o("local"), { handled: true };
        case "transformworld":
          return o("world"), { handled: true };
      }
  }), []), (0, import_react.useEffect)(() => {
    if (!a) {
      y(null);
      return;
    }
    const D = ws(v, {
      column: a.column,
      line: a.line,
      path: a.parentPath,
      transform: l
    });
    y(D);
    const O = D == null ? void 0 : D.sceneObject;
    if (O)
      return O.traverse((F) => F.layers.enable(Wr)), () => {
        O.traverse(
          (F) => F.layers.disable(Wr)
        );
      };
  }, [v, a, l]), (0, import_react.useEffect)(() => {
    pt("ready", void 0);
  }, []), (0, import_react.useEffect)(() => dr([
    mt("request-open-component", (D) => {
      !D && (!f || !d) || (D ? (i({
        exportName: D.exportName,
        path: D.path,
        props: D.encodedProps ? JSON.parse(D.encodedProps) : {}
      }), c(void 0), e()) : f && d && d.type === "custom" && d.path && d.exportName && (i({
        exportName: d.exportName,
        path: d.path,
        props: ku(f)
      }), c(void 0), e()));
    }),
    mt("request-blur-element", () => {
      c((D) => {
        D && pt("track", { actionId: "element_blur" });
      }), e();
    }),
    mt("request-jump-to-element", (D) => {
      var U;
      const O = D ? mi(v, D) : f == null ? void 0 : f.sceneObject;
      if (!O)
        return;
      pt("track", { actionId: "element_jumpto" });
      const F = new Box3().setFromObject(O);
      F.min.x === Number.POSITIVE_INFINITY && F.setFromCenterAndSize(
        O.position,
        new Vector3(0.5, 0.5, 0.5)
      ), (U = _.current) == null || U.fitToBox(F, false, {
        paddingBottom: 0.5,
        paddingLeft: 0.5,
        paddingRight: 0.5,
        paddingTop: 0.5
      });
    }),
    mt("request-focus-element", (D) => {
      c(D), r(D), pt("track", { actionId: "element_focus" });
    })
  ]), [
    _,
    e,
    r,
    i,
    v,
    f,
    d
  ]), (0, import_react.useEffect)(() => {
    !d || d.type === "host" || Du("/scene/:path/:exportName", {
      exportName: d.exportName,
      path: d.path
    });
  }, [d]), (0, import_react.useEffect)(() => {
    const D = (O) => {
      S && O.key === "Escape" && O.preventDefault();
    };
    return document.addEventListener("keydown", D), () => document.removeEventListener("keydown", D);
  }, [S]), useFrame(() => {
    f && f.sceneObject.parent === null && c(void 0);
  });
  const T = nr((D) => {
    if (h.current)
      return;
    const O = po(D, {
      elements: E,
      path: t.path
    });
    if (O) {
      const F = {
        column: O.column,
        line: O.line,
        parentPath: t.path,
        path: O.path
      };
      return c(F), r(F), true;
    }
    return false;
  }), L = nr(() => {
    x(true);
  }), M = nr(
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    (D) => {
      if (x(false), !(!D || !f || !d)) {
        if (D.mode === "translate") {
          const O = f.space === "world" ? f.sceneObject.getWorldPosition(Uu).toArray() : f.sceneObject.position.toArray();
          pt("element-set-prop", {
            column: f.column,
            line: f.line,
            path: f.path,
            propName: "position",
            propValue: O.map(Ps)
          }), pt("track", { actionId: "element_transform_translate" });
        }
        if (D.mode === "rotate") {
          const O = f.sceneObject.rotation.toArray();
          O.pop(), pt("element-set-prop", {
            column: f.column,
            line: f.line,
            path: f.path,
            propName: "rotation",
            propValue: O
          }), pt("track", { actionId: "element_transform_rotate" });
        }
        if (D.mode === "scale") {
          const O = f.sceneObject.scale.toArray();
          pt("element-set-prop", {
            column: f.column,
            line: f.line,
            path: f.path,
            propName: "scale",
            propValue: O.map(Ps)
          }), pt("track", { actionId: "element_transform_scale" });
        }
      }
    }
  ), I = nr(
    (D, O, F) => {
      if (a && !f && a.path === D && a.line === O && a.column === F && l !== "none") {
        const U = ws(v, {
          column: a.column,
          line: a.line,
          path: a.parentPath,
          transform: l
        });
        y(U);
      }
    }
  );
  return (0, import_react.useEffect)(() => {
    let D = [-1, -1];
    const O = (U) => {
      D = [U.offsetX, U.offsetY];
    }, F = (U) => {
      if (Math.abs(U.offsetX - D[0]) + Math.abs(U.offsetY - D[1]) > 1)
        return;
      const $ = U.offsetX / b.width * 2 - 1, rt = -(U.offsetY / b.height) * 2 + 1;
      Ms.setFromCamera(new Vector2($, rt), p);
      const Y = Ms.intersectObject(v).filter((B) => su(B.object));
      for (const B of Y)
        if (T(B.object)) {
          pt("track", { actionId: "element_focus" });
          return;
        }
      c((B) => {
        B && pt("track", { actionId: "element_blur" });
      }), e();
    };
    return m.domElement.addEventListener("mousedown", O), m.domElement.addEventListener("mouseup", F), () => {
      m.domElement.removeEventListener("mousedown", O), m.domElement.removeEventListener("mouseup", F);
    };
  }, [
    p,
    b.height,
    b.width,
    m.domElement,
    e,
    v,
    T
  ]), P.jsxs(xo.Provider, { value: true, children: [
    P.jsx(So.Provider, { value: I, children: P.jsx(wo.Provider, { value: T, children: n }) }),
    f && l !== "none" && P.jsx(
      Ru,
      {
        enabled: !!d && d.transforms[l],
        mode: l,
        object: f.sceneObject,
        onMouseDown: L,
        onMouseUp: M,
        rotationSnap: Math.PI / 180,
        scaleSnap: 0.02,
        space: s,
        translationSnap: 0.02
      }
    ),
    f && f.sceneObject instanceof Camera && P.jsx(Au, { camera: f.sceneObject })
  ] });
}
var Vu = [/^Canvas$/];
var ks = [
  /^PresentationControls$/,
  /^ScrollControls$/
];
var zu = [/^Ecctrl$/, /Controls$/];
function Nu() {
  const [, n] = (0, import_react.useState)(false);
  return (0, import_react.useCallback)(() => n((t) => !t), []);
}
function Yu(n, t) {
  const e = Nu(), r = (0, import_react.useRef)({}), i = (0, import_react.useRef)({});
  Object.assign(i.current, t), (0, import_react.useEffect)(() => dr([
    mt("self:request-reset-file", ({ path: o }) => {
      n.path.endsWith(o) && (r.current = {});
    }),
    mt("request-reset-scene", () => {
      Object.keys(r.current).length && (r.current = {}, e());
    }),
    mt("request-set-element-prop", (o) => {
      "column" in o && o.column === n.column && o.line === n.line && o.path === n.path && (r.current[o.propName] = o.propValue, e());
    }),
    mt("request-reset-prop", (o) => {
      o.column === n.column && o.line === n.line && o.path === n.path && (delete r.current[o.propName], e());
    })
  ]), [n.column, n.line, n.name, n.path, e]);
  const s = { ...t, ...r.current };
  for (const o in s)
    s[o] === void 0 && delete s[o];
  return s;
}
var Wn = (0, import_react.createContext)([]);
function Bu({
  children: n,
  type: t,
  value: e
}) {
  const r = (0, import_react.useContext)(Wn), i = (0, import_react.useMemo)(() => [e, ...r], [r, e]);
  return t === "host" ? P.jsx(import_react.Fragment, { children: n }) : P.jsx(Wn.Provider, { value: i, children: n });
}
var xo = (0, import_react.createContext)(false);
var an = (0, import_react.forwardRef)(
  ({ __component: n, __meta: t, forceInsideSceneObjectContext: e, ...r }, i) => {
    const { children: s, ...o } = Yu(t, r), [a, c] = (0, import_react.useState)(false), l = Pu(), u = (0, import_react.useContext)(Wn), v = typeof n == "string" ? "host" : "custom", m = (0, import_react.useRef)(null), p = Fu(), b = (0, import_react.useContext)(xo), S = (0, import_react.useMemo)(() => Su([i, m]), [i]), { isTriplexCamera: x } = mr();
    if ((0, import_react.useEffect)(() => dr([
      mt("request-delete-element", (d) => {
        d.column === t.column && d.line === t.line && d.path === t.path && c(true);
      }),
      mt("request-restore-element", (d) => {
        d.column === t.column && d.line === t.line && d.parentPath === t.path && c(false);
      })
    ]), [t.column, t.line, t.path]), (0, import_react.useEffect)(() => {
      l(t.path, t.line, t.column);
    }, [t.column, t.line, t.path, l]), a)
      return null;
    if (Vu.some((d) => d.test(t.name)))
      return P.jsx(P.Fragment, { children: r.children });
    if (x && !ks.some((d) => d.test(t.name)) && zu.some((d) => d.test(t.name)))
      return P.jsx(P.Fragment, { children: r.children });
    if (e || b) {
      const d = typeof n == "string" ? xu(n) : void 0, g = {
        ...t,
        parents: u,
        props: r
      }, E = v === "custom" && x && ks.some((f) => f.test(t.name));
      return P.jsxs(Bu, { type: v, value: g, children: [
        P.jsx(
          n,
          {
            ref: v === "host" ? S : i,
            ...o,
            ...E ? { enabled: false } : void 0,
            children: v === "custom" ? (
              // This keeps any preconditions for custom components valid
              // e.g. they always take the same amount of children, no mutations.
              // React.Children.only() use case.
              s
            ) : (
              // For host elements we inject extra metadata for lookups but otherwise
              // keep things pretty much the same (no Three.js scene mutation).
              P.jsxs(P.Fragment, { children: [
                s,
                P.jsx("primitive", { attach: "__triplex", object: g })
              ] })
            )
          }
        ),
        d && P.jsx(
          Tu,
          {
            args: d[1],
            helperName: d[0],
            onClick: (f) => {
              f.delta > 1 || !m.current || (f.stopPropagation(), p(m.current));
            },
            targetRef: m
          }
        )
      ] });
    }
    return P.jsx(n, { ref: i, ...r, children: s });
  }
);
an.displayName = "SceneObject";
function Gu({
  component: n,
  exportName: t,
  path: e,
  props: r,
  triplexMeta: i
}) {
  const s = "lighting" in i && i.lighting === "default", [o, a] = (0, import_react.useState)(
    s
  );
  return (0, import_react.useEffect)(() => mt("extension-point-triggered", (c) => {
    if (c.scope === "scene")
      switch (c.id) {
        case "default_lights_on":
          return a(true), { handled: true };
        case "default_lights_off":
          return a(false), { handled: true };
      }
  }), []), (0, import_react.useLayoutEffect)(() => {
    pt("extension-point-triggered", {
      id: s ? "default_lights_off" : "default_lights_on"
    }), a(s);
  }, [s]), P.jsxs(P.Fragment, { children: [
    P.jsx(
      an,
      {
        __component: n,
        __meta: {
          column: -1,
          line: -1,
          name: t,
          path: e
        },
        forceInsideSceneObjectContext: true,
        ...r
      }
    ),
    o && P.jsxs(P.Fragment, { children: [
      P.jsx(
        "hemisphereLight",
        {
          color: "#87CEEB",
          groundColor: "#362907",
          intensity: 0.3
        }
      ),
      P.jsx("ambientLight", { intensity: 0.3 }),
      P.jsx("directionalLight", { intensity: 0.5, position: [2.5, 8, 5] }),
      P.jsx(
        "pointLight",
        {
          color: "#eef4aa",
          intensity: 0.5,
          position: [-10, 0, -20]
        }
      )
    ] }),
    false
  ] });
}
function Hu({ exportName: n }) {
  return (0, import_react.useEffect)(() => {
    pt("component-rendered", void 0);
  }, []), P.jsx(Zr.In, { children: P.jsx(
    "span",
    {
      "data-testid": "scene-loaded-meta",
      style: {
        height: 1,
        left: 0,
        opacity: 0,
        position: "absolute",
        top: 0,
        width: 1
      },
      children: n
    }
  ) });
}
function Ku({
  exportName: n,
  path: t,
  sceneProps: e
}) {
  const r = Zc(), i = Object.keys(r).find(
    (c) => t ? t.endsWith(c) : false
  );
  if (!i || !n)
    return null;
  const { SceneComponent: s, triplexMeta: o } = hc(async () => {
    const l = (await r[i]())[n];
    return {
      SceneComponent: l || import_react.Fragment,
      triplexMeta: l && "triplexMeta" in l ? l.triplexMeta : void 0
    };
  }, [n, r, i]), a = o && typeof o == "object" ? o : {};
  return P.jsxs(
    Xr,
    {
      fallbackRender: () => null,
      onError: (c) => pt("error", {
        message: c.message,
        source: t,
        stack: c.message,
        subtitle: "The scene could not be rendered because there was an error in a component. Resolve the errors and try again.",
        title: "Could not render scene"
      }),
      resetKeys: [s],
      children: [
        P.jsx(Hu, { exportName: n }),
        P.jsx(
          Gu,
          {
            component: s,
            exportName: n,
            path: t,
            props: e,
            triplexMeta: a
          }
        )
      ]
    }
  );
}
function Xu({
  children: n,
  component: t,
  exportName: e,
  id: r,
  path: i,
  staticSceneProps: s = {}
}) {
  return P.jsx(
    an,
    {
      __component: t,
      __meta: {
        column: r,
        line: r,
        name: e,
        path: i,
        rotate: false,
        scale: false,
        translate: false
      },
      forceInsideSceneObjectContext: true,
      ...s,
      children: n
    }
  );
}
function Zu({
  provider: n,
  providerPath: t
}) {
  const [e, r] = (0, import_react.useReducer)((l) => l + 1, 0), [i, s] = (0, import_react.useState)({ exportName: "", path: "", props: {} }), o = nr(
    (l) => {
      s({
        exportName: l.exportName,
        path: l.path,
        props: l.props
      }), pt("component-opened", {
        encodedProps: JSON.stringify(l.props),
        entered: true,
        exportName: l.exportName,
        path: l.path
      });
    }
  ), a = (0, import_react.useCallback)(
    (l) => {
      pt("element-focused", l);
    },
    []
  ), c = (0, import_react.useCallback)(() => {
    pt("element-blurred", void 0);
  }, []);
  return (0, import_react.useEffect)(() => dr([
    mt("request-refresh-scene", r),
    mt("request-state-change", ({ state: l }) => {
      l === "edit" && r();
    })
  ]), []), P.jsxs(eu, { children: [
    P.jsxs(au, { children: [
      P.jsx(
        Xr,
        {
          fallbackRender: () => null,
          onError: (l) => pt("error", {
            message: l.message,
            source: t,
            stack: l.stack,
            subtitle: "The scene could not be rendered because there was an error in the provider component. Resolve the errors and try again.",
            title: "Could not render scene"
          }),
          resetKeys: [i, n],
          children: P.jsxs(
            import_react.Suspense,
            {
              fallback: P.jsx(Zr.In, { children: P.jsx(Cs, {}) }),
              children: [
                P.jsx(
                  Xu,
                  {
                    component: n,
                    exportName: "__exclude__",
                    id: -999,
                    path: t,
                    children: P.jsx(
                      ju,
                      {
                        filter: i,
                        onBlur: c,
                        onFocus: a,
                        onNavigate: o,
                        children: P.jsx(
                          Xr,
                          {
                            fallbackRender: () => null,
                            resetKeys: [i],
                            children: P.jsx(
                              _u,
                              {
                                fallback: P.jsx(Zr.In, { children: P.jsx(Cs, {}) }),
                                children: P.jsx(
                                  ou,
                                  {
                                    id: i.path + i.exportName,
                                    children: P.jsx(
                                      Ku,
                                      {
                                        exportName: i.exportName,
                                        path: i.path,
                                        sceneProps: i.props
                                      },
                                      e
                                    )
                                  }
                                )
                              }
                            )
                          }
                        )
                      }
                    )
                  }
                ),
                P.jsx(gu, {})
              ]
            }
          )
        }
      ),
      P.jsx(vu, {})
    ] }),
    tc("selection_postprocessing") && P.jsx(mu, {})
  ] });
}
function Wu({
  files: n,
  provider: t,
  providerPath: e
}) {
  return (0, import_react.useEffect)(() => {
    pt("set-extension-points", {
      elements: [
        {
          buttons: [
            {
              icon: "camera",
              id: "camera_enter",
              label: "Enter Camera"
            },
            {
              icon: "exit",
              id: "camera_exit",
              label: "Exit Camera"
            }
          ],
          filter: "PerspectiveCamera|OrthographicCamera",
          groupId: "enter_camera",
          type: "toggle-button"
        }
      ],
      scene: [
        {
          buttons: [
            {
              icon: "world",
              id: "transformlocal",
              label: "Set Local Transform"
            },
            {
              icon: "local",
              id: "transformworld",
              label: "Set World Transform"
            }
          ],
          groupId: "transform_space",
          type: "toggle-button"
        },
        {
          type: "separator"
        },
        {
          buttons: [
            {
              icon: "cursor",
              id: "none",
              label: "Select"
            },
            {
              accelerator: "T",
              icon: "move",
              id: "translate",
              label: "Translate"
            },
            {
              accelerator: "R",
              icon: "angle",
              id: "rotate",
              label: "Rotate"
            },
            {
              accelerator: "S",
              icon: "transform",
              id: "scale",
              label: "Scale"
            }
          ],
          defaultSelected: "none",
          groupId: "transform_controls",
          type: "button-group"
        },
        {
          type: "separator"
        },
        {
          buttons: [
            {
              icon: "moon",
              id: "default_lights_on",
              label: "Turn On Default Lights"
            },
            {
              icon: "sun",
              id: "default_lights_off",
              label: "Turn Off Default Lights"
            }
          ],
          groupId: "lights",
          type: "toggle-button"
        },
        {
          type: "separator"
        },
        {
          buttons: [
            {
              icon: "grid-perspective",
              id: "orthographic",
              label: "Switch To Orthographic"
            },
            {
              icon: "grid",
              id: "perspective",
              label: "Switch To Perspective"
            }
          ],
          groupId: "camera_switcher",
          type: "toggle-button"
        }
      ]
    });
  }, []), P.jsxs(Wc, { value: n, children: [
    P.jsx(Zu, { provider: t, providerPath: e }),
    P.jsx(Zr.Out, {})
  ] });
}
ua({ RendererElement: an });
var ih = (n) => {
  const t = Kr(n);
  return async (e) => {
    await Jl({
      environment: e.fgEnvironmentOverride,
      userId: e.userId
    }), t.render(
      P.jsx(
        Wu,
        {
          files: e.files,
          provider: e.provider,
          providerPath: e.config.provider
        }
      )
    );
  };
};
function qu({ children: n }) {
  return (0, import_react.useEffect)(() => {
    console.log("screenshot!");
  }, []), P.jsx(P.Fragment, { children: n });
}
var sh = (n) => {
  const t = Kr(n);
  return ({ component: e, provider: r }) => {
    t.render(
      P.jsx(Canvas, { shadows: true, style: { inset: 0, position: "absolute" }, children: P.jsx(qu, { children: P.jsxs(Xr, { fallbackRender: () => null, children: [
        P.jsx(Pc, { fit: true, children: P.jsx(r, { children: P.jsx(e, {}) }) }),
        P.jsx("ambientLight", { intensity: 2 })
      ] }) }) })
    );
  };
};
export {
  ih as bootstrap,
  sh as thumbnail
};
/*! Bundled license information:

@triplex/renderer-r3f/dist/index.mjs:
  (**
   * @license React
   * react-jsx-runtime.production.min.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

@triplex/renderer-r3f/dist/index.mjs:
  (**
   * @license React
   * react-jsx-runtime.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)
  (**
   * [js-sha256]{@link https://github.com/emn178/js-sha256}
   *
   * @version 0.11.0
   * @author Chen, Yi-Cyuan [emn178@gmail.com]
   * @copyright Chen, Yi-Cyuan 2014-2024
   * @license MIT
   *)
  (*!
   * camera-controls
   * https://github.com/yomotsu/camera-controls
   * (c) 2017 @yomotsu
   * Released under the MIT License.
   *)

@triplex/renderer-r3f/dist/index.mjs:
  (**
   * @license React
   * use-sync-external-store-shim.production.min.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

@triplex/renderer-r3f/dist/index.mjs:
  (**
   * @license React
   * use-sync-external-store-shim.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)
  (**
   * @license React
   * use-sync-external-store-shim/with-selector.production.min.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

@triplex/renderer-r3f/dist/index.mjs:
  (**
   * @license React
   * use-sync-external-store-shim/with-selector.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)
*/
//# sourceMappingURL=__triplex_renderer__.js.map
